{"ast":null,"code":"var _ = require('lodash'),\n  createItemContext = require('./create-item-context'),\n  // total number of replays allowed\n  MAX_REPLAY_COUNT = 3,\n  ReplayController;\n\n/**\n * Handles replay logic with replayState from context.\n * Makes sure request replays do not go into an infinite loop.\n *\n * @param {ReplayState} replayState -\n * @param {Run} run -\n *\n * @constructor\n */\nReplayController = function ReplayController(replayState, run) {\n  // store state\n  this.count = replayState ? replayState.count : 0;\n  this.run = run;\n};\n_.assign(ReplayController.prototype, /** @lends ReplayController.prototype */{\n  /**\n   * Sends a request in the item. This takes care of limiting the total number of replays for a request.\n   *\n   * @param {Object} context -\n   * @param {Request} item -\n   * @param {Object} desiredPayload a partial payload to use for the replay request\n   * @param {Function} success this callback is invoked when replay controller sent the request\n   * @param {Function} failure this callback is invoked when replay controller decided not to send the request\n   */\n  requestReplay(context, item, desiredPayload, success, failure) {\n    // max retries exceeded\n    if (this.count >= MAX_REPLAY_COUNT) {\n      return failure(new Error('runtime: maximum intermediate request limit exceeded'));\n    }\n\n    // update replay count state\n    this.count++;\n\n    // update replay state to context\n    context.replayState = this.getReplayState();\n\n    // construct payload for request\n    var payload = _.defaults({\n      item: item,\n      // abortOnError makes sure request command bubbles errors\n      // so we can pass it on to the callback\n      abortOnError: true\n    }, desiredPayload);\n\n    // create item context from the new item\n    payload.context = createItemContext(payload, context);\n    this.run.immediate('httprequest', payload).done(function (response) {\n      success(null, response);\n    }).catch(success);\n  },\n  /**\n   * Returns a serialized version of current ReplayController\n   *\n   * @returns {ReplayState}\n   */\n  getReplayState() {\n    /**\n     * Defines the current replay state of a request.\n     *\n     * By replay state, we mean the number of requests sent\n     * as part of one Collection requests. It can be intermediate requests,\n     * or replays of the same collection requests.\n     *\n     * @typedef {Object} ReplayState\n     *\n     * @property {Number} count total number of requests, including Collection requests and replays\n     */\n    return {\n      count: this.count\n    };\n  }\n});\nmodule.exports = ReplayController;","map":{"version":3,"names":["_","require","createItemContext","MAX_REPLAY_COUNT","ReplayController","replayState","run","count","assign","prototype","requestReplay","context","item","desiredPayload","success","failure","Error","getReplayState","payload","defaults","abortOnError","immediate","done","response","catch","module","exports"],"sources":["/Users/Qusai.Qishta/node_modules/postman-runtime/lib/runner/replay-controller.js"],"sourcesContent":["var _ = require('lodash'),\n    createItemContext = require('./create-item-context'),\n\n    // total number of replays allowed\n    MAX_REPLAY_COUNT = 3,\n\n    ReplayController;\n\n/**\n * Handles replay logic with replayState from context.\n * Makes sure request replays do not go into an infinite loop.\n *\n * @param {ReplayState} replayState -\n * @param {Run} run -\n *\n * @constructor\n */\nReplayController = function ReplayController (replayState, run) {\n    // store state\n    this.count = replayState ? replayState.count : 0;\n    this.run = run;\n};\n\n_.assign(ReplayController.prototype, /** @lends ReplayController.prototype */{\n    /**\n     * Sends a request in the item. This takes care of limiting the total number of replays for a request.\n     *\n     * @param {Object} context -\n     * @param {Request} item -\n     * @param {Object} desiredPayload a partial payload to use for the replay request\n     * @param {Function} success this callback is invoked when replay controller sent the request\n     * @param {Function} failure this callback is invoked when replay controller decided not to send the request\n     */\n    requestReplay (context, item, desiredPayload, success, failure) {\n        // max retries exceeded\n        if (this.count >= MAX_REPLAY_COUNT) {\n            return failure(new Error('runtime: maximum intermediate request limit exceeded'));\n        }\n\n        // update replay count state\n        this.count++;\n\n        // update replay state to context\n        context.replayState = this.getReplayState();\n\n        // construct payload for request\n        var payload = _.defaults({\n            item: item,\n            // abortOnError makes sure request command bubbles errors\n            // so we can pass it on to the callback\n            abortOnError: true\n        }, desiredPayload);\n\n        // create item context from the new item\n        payload.context = createItemContext(payload, context);\n\n        this.run.immediate('httprequest', payload)\n            .done(function (response) {\n                success(null, response);\n            })\n            .catch(success);\n    },\n\n    /**\n     * Returns a serialized version of current ReplayController\n     *\n     * @returns {ReplayState}\n     */\n    getReplayState () {\n        /**\n         * Defines the current replay state of a request.\n         *\n         * By replay state, we mean the number of requests sent\n         * as part of one Collection requests. It can be intermediate requests,\n         * or replays of the same collection requests.\n         *\n         * @typedef {Object} ReplayState\n         *\n         * @property {Number} count total number of requests, including Collection requests and replays\n         */\n        return {\n            count: this.count\n        };\n    }\n});\n\n\nmodule.exports = ReplayController;\n"],"mappings":"AAAA,IAAIA,CAAC,GAAGC,OAAO,CAAC,QAAQ,CAAC;EACrBC,iBAAiB,GAAGD,OAAO,CAAC,uBAAuB,CAAC;EAEpD;EACAE,gBAAgB,GAAG,CAAC;EAEpBC,gBAAgB;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,gBAAgB,GAAG,SAASA,gBAAgB,CAAEC,WAAW,EAAEC,GAAG,EAAE;EAC5D;EACA,IAAI,CAACC,KAAK,GAAGF,WAAW,GAAGA,WAAW,CAACE,KAAK,GAAG,CAAC;EAChD,IAAI,CAACD,GAAG,GAAGA,GAAG;AAClB,CAAC;AAEDN,CAAC,CAACQ,MAAM,CAACJ,gBAAgB,CAACK,SAAS,EAAE,wCAAwC;EACzE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,aAAa,CAAEC,OAAO,EAAEC,IAAI,EAAEC,cAAc,EAAEC,OAAO,EAAEC,OAAO,EAAE;IAC5D;IACA,IAAI,IAAI,CAACR,KAAK,IAAIJ,gBAAgB,EAAE;MAChC,OAAOY,OAAO,CAAC,IAAIC,KAAK,CAAC,sDAAsD,CAAC,CAAC;IACrF;;IAEA;IACA,IAAI,CAACT,KAAK,EAAE;;IAEZ;IACAI,OAAO,CAACN,WAAW,GAAG,IAAI,CAACY,cAAc,EAAE;;IAE3C;IACA,IAAIC,OAAO,GAAGlB,CAAC,CAACmB,QAAQ,CAAC;MACrBP,IAAI,EAAEA,IAAI;MACV;MACA;MACAQ,YAAY,EAAE;IAClB,CAAC,EAAEP,cAAc,CAAC;;IAElB;IACAK,OAAO,CAACP,OAAO,GAAGT,iBAAiB,CAACgB,OAAO,EAAEP,OAAO,CAAC;IAErD,IAAI,CAACL,GAAG,CAACe,SAAS,CAAC,aAAa,EAAEH,OAAO,CAAC,CACrCI,IAAI,CAAC,UAAUC,QAAQ,EAAE;MACtBT,OAAO,CAAC,IAAI,EAAES,QAAQ,CAAC;IAC3B,CAAC,CAAC,CACDC,KAAK,CAACV,OAAO,CAAC;EACvB,CAAC;EAED;AACJ;AACA;AACA;AACA;EACIG,cAAc,GAAI;IACd;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,OAAO;MACHV,KAAK,EAAE,IAAI,CAACA;IAChB,CAAC;EACL;AACJ,CAAC,CAAC;AAGFkB,MAAM,CAACC,OAAO,GAAGtB,gBAAgB"},"metadata":{},"sourceType":"script"}