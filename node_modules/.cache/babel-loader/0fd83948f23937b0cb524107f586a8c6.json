{"ast":null,"code":"var _ = require('../util').lodash,\n  Property = require('./property').Property,\n  PropertyList = require('./property-list').PropertyList,\n  Url = require('./url').Url,\n  UrlMatchPattern = require('../url-pattern/url-match-pattern').UrlMatchPattern,\n  UrlMatchPatternList = require('../url-pattern/url-match-pattern-list').UrlMatchPatternList,\n  ProxyConfig,\n  PROTOCOL_DELIMITER = UrlMatchPattern.PROTOCOL_DELIMITER,\n  E = '',\n  COLON = ':',\n  DEFAULT_PORT = 8080,\n  PROTOCOL_HOST_SEPARATOR = '://',\n  MATCH_ALL_HOST_AND_PATH = '*:*/*',\n  AUTH_CREDENTIALS_SEPARATOR = '@',\n  DEFAULT_PROTOCOL = 'http',\n  ALLOWED_PROTOCOLS = ['http', 'https'],\n  // 'http+https://*:*/*'\n  DEFAULT_PATTERN = ALLOWED_PROTOCOLS.join(PROTOCOL_DELIMITER) + PROTOCOL_HOST_SEPARATOR + MATCH_ALL_HOST_AND_PATH;\n\n/**\n* The following is the object structure accepted as constructor parameter while calling `new ProxyConfig(...)`. It is\n* also the structure exported when {@link Property#toJSON} or {@link Property#toObjectResolved} is called on a\n* Proxy instance.\n *\n* @typedef ProxyConfig.definition\n*\n* @property {String=} [match = 'http+https://*\\/*'] The match for which the proxy needs to be configured.\n* @property {String=} [host = ''] The proxy server url.\n* @property {Number=} [port = 8080] The proxy server port number.\n* @property {Boolean=} [tunnel = false] The tunneling option for the proxy request.\n* @property {Boolean=} [disabled = false] To override the proxy for the particular url, you need to provide true.\n* @property {Boolean=} [authenticate = false] To enable authentication for the proxy, you need to provide true.\n* @property {String=} [username] The proxy authentication username\n* @property {String=} [password] The proxy authentication password\n*\n* @example <caption>JSON definition of an example proxy object</caption>\n* {\n*     \"match\": \"http+https://example.com/*\",\n*     \"host\": \"proxy.com\",\n*     \"port\": \"8080\",\n*     \"tunnel\": true,\n*     \"disabled\": false,\n*     \"authenticate\": true,\n*     \"username\": \"proxy_username\",\n*     \"password\": \"proxy_password\"\n* }\n*/\n_.inherit(\n/**\n * A ProxyConfig definition that represents the proxy configuration for an url match.\n * Properties can then use the `.toObjectResolved` function to procure an object representation of the property with\n * all the variable references replaced by corresponding values.\n *\n * @constructor\n * @extends {Property}\n * @param {ProxyConfig.definition=} [options] - Specifies object with props matches, server and tunnel.\n *\n * @example <caption>Create a new ProxyConfig</caption>\n * var ProxyConfig = require('postman-collection').ProxyConfig,\n *     myProxyConfig = new ProxyConfig({\n *          host: 'proxy.com',\n *          match: 'http+https://example.com/*',\n *          port: 8080,\n *          tunnel: true,\n *          disabled: false,\n *          authenticate: true,\n *          username: 'proxy_username',\n *          password: 'proxy_password'\n *     });\n */\nProxyConfig = function ProxyConfig(options) {\n  // this constructor is intended to inherit and as such the super constructor is required to be executed\n  ProxyConfig.super_.call(this, options);\n\n  // Assign defaults before proceeding\n  _.assign(this, /** @lends ProxyConfig */{\n    /**\n     * The proxy server host or ip\n     *\n     * @type {String}\n     */\n    host: E,\n    /**\n     * The url mach for which the proxy has been associated with.\n     *\n     * @type {String}\n     */\n    match: new UrlMatchPattern(DEFAULT_PATTERN),\n    /**\n     * The proxy server port number\n     *\n     * @type {Number}\n     */\n    port: DEFAULT_PORT,\n    /**\n     * This represents whether the tunneling needs to done while proxying this request.\n     *\n     * @type Boolean\n     */\n    tunnel: false,\n    /**\n     * Proxy bypass list\n     *\n     * @type {UrlMatchPatternList}\n     */\n    bypass: undefined,\n    /**\n     * Enable proxy authentication\n     *\n     * @type {Boolean}\n     */\n    authenticate: false,\n    /**\n     * Proxy auth username\n     *\n     * @type {String}\n     */\n    username: undefined,\n    /**\n     * Proxy auth password\n     *\n     * @type {String}\n     */\n    password: undefined\n  });\n  this.update(options);\n}, Property);\n_.assign(ProxyConfig.prototype, /** @lends ProxyConfig.prototype */{\n  /**\n   * Defines whether this property instances requires an id\n   *\n   * @private\n   * @readOnly\n   * @type {Boolean}\n   */\n  _postman_propertyRequiresId: true,\n  /**\n   * Updates the properties of the proxy object based on the options provided.\n   *\n   * @param {ProxyConfig.definition} options The proxy object structure.\n   */\n  update: function (options) {\n    if (!_.isObject(options)) {\n      return;\n    }\n    var parsedUrl,\n      port = _.get(options, 'port') >> 0;\n    if (_.isString(options.host)) {\n      // strip the protocol from given host\n      parsedUrl = new Url(options.host);\n      this.host = parsedUrl.getHost();\n    }\n    _.isString(options.match) && (this.match = new UrlMatchPattern(options.match));\n    _.isString(_.get(options, 'match.pattern')) && (this.match = new UrlMatchPattern(options.match.pattern));\n    port && (this.port = port);\n    _.isBoolean(options.tunnel) && (this.tunnel = options.tunnel);\n    // todo: Add update method in parent class Property and call that here\n    _.isBoolean(options.disabled) && (this.disabled = options.disabled);\n    _.isBoolean(options.authenticate) && (this.authenticate = options.authenticate);\n    _.isString(options.username) && (this.username = options.username);\n    _.isString(options.password) && (this.password = options.password);\n\n    // init bypass list from the given array\n    if (Array.isArray(options.bypass)) {\n      this.bypass = new UrlMatchPatternList(null, options.bypass);\n    }\n    // or, convert existing PropertyList or UrlMatchPatternList\n    else if (PropertyList.isPropertyList(options.bypass)) {\n      this.bypass = new UrlMatchPatternList(null, options.bypass.all());\n    }\n  },\n  /**\n   * Updates the protocols in the match pattern\n   *\n   * @param {Array.<String>} protocols The array of protocols\n   */\n  updateProtocols: function (protocols) {\n    if (!protocols) {\n      return;\n    }\n    var updatedProtocols,\n      hostAndPath = _.split(this.match.pattern, PROTOCOL_HOST_SEPARATOR)[1];\n    if (!hostAndPath) {\n      return;\n    }\n    updatedProtocols = _.intersection(ALLOWED_PROTOCOLS, _.castArray(protocols));\n    _.isEmpty(updatedProtocols) && (updatedProtocols = ALLOWED_PROTOCOLS);\n    this.match.update({\n      pattern: updatedProtocols.join(PROTOCOL_DELIMITER) + PROTOCOL_HOST_SEPARATOR + hostAndPath\n    });\n  },\n  /**\n   * Tests the url string with the match provided.\n   * Follows the https://developer.chrome.com/extensions/match_patterns pattern for pattern validation and matching\n   *\n   * @param {String=} [urlStr] The url string for which the proxy match needs to be done.\n   */\n  test: function (urlStr) {\n    var protocol = Url.isUrl(urlStr) ? urlStr.protocol : Url.parse(urlStr || E).protocol || E;\n\n    // to allow target URLs without any protocol. e.g.: 'foo.com/bar'\n    if (_.isEmpty(protocol)) {\n      protocol = DEFAULT_PROTOCOL;\n      urlStr = protocol + PROTOCOL_HOST_SEPARATOR + urlStr;\n    }\n\n    // this ensures we don't proceed any further for any non-supported protocol\n    if (!_.includes(ALLOWED_PROTOCOLS, protocol)) {\n      return false;\n    }\n\n    // don't proceed if the given URL should skip use of a proxy all together\n    if (this.bypass && this.bypass.test(urlStr)) {\n      return false;\n    }\n    return this.match.test(urlStr);\n  },\n  /**\n   * Returns the proxy server url.\n   *\n   * @returns {String}\n   */\n  getProxyUrl: function () {\n    var auth = E;\n\n    // Add authentication method to URL if the same is requested. We do it this way because\n    // this is how `postman-request` library accepts auth credentials in its proxy configuration.\n    if (this.authenticate) {\n      auth = encodeURIComponent(this.username || E);\n      if (this.password) {\n        auth += COLON + encodeURIComponent(this.password);\n      }\n      if (auth) {\n        auth += AUTH_CREDENTIALS_SEPARATOR;\n      }\n    }\n    return DEFAULT_PROTOCOL + PROTOCOL_HOST_SEPARATOR + auth + this.host + COLON + this.port;\n  },\n  /**\n   * Returns the protocols supported.\n   *\n   * @returns {Array.<String>}\n   */\n  getProtocols: function () {\n    return this.match.getProtocols();\n  }\n});\n_.assign(ProxyConfig, /** @lends ProxyConfig */{\n  /**\n   * Defines the name of this property for internal use.\n   *\n   * @private\n   * @readOnly\n   * @type {String}\n   */\n  _postman_propertyName: 'ProxyConfig',\n  /**\n   * Check whether an object is an instance of PostmanItem.\n   *\n   * @param {*} obj -\n   * @returns {Boolean}\n   */\n  isProxyConfig: function (obj) {\n    return Boolean(obj) && (obj instanceof ProxyConfig || _.inSuperChain(obj.constructor, '_postman_propertyName', ProxyConfig._postman_propertyName));\n  }\n});\nmodule.exports = {\n  ProxyConfig,\n  ALLOWED_PROTOCOLS,\n  DEFAULT_PATTERN\n};","map":{"version":3,"names":["_","require","lodash","Property","PropertyList","Url","UrlMatchPattern","UrlMatchPatternList","ProxyConfig","PROTOCOL_DELIMITER","E","COLON","DEFAULT_PORT","PROTOCOL_HOST_SEPARATOR","MATCH_ALL_HOST_AND_PATH","AUTH_CREDENTIALS_SEPARATOR","DEFAULT_PROTOCOL","ALLOWED_PROTOCOLS","DEFAULT_PATTERN","join","inherit","options","super_","call","assign","host","match","port","tunnel","bypass","undefined","authenticate","username","password","update","prototype","_postman_propertyRequiresId","isObject","parsedUrl","get","isString","getHost","pattern","isBoolean","disabled","Array","isArray","isPropertyList","all","updateProtocols","protocols","updatedProtocols","hostAndPath","split","intersection","castArray","isEmpty","test","urlStr","protocol","isUrl","parse","includes","getProxyUrl","auth","encodeURIComponent","getProtocols","_postman_propertyName","isProxyConfig","obj","Boolean","inSuperChain","constructor","module","exports"],"sources":["/Users/Qusai.Qishta/node_modules/postman-collection/lib/collection/proxy-config.js"],"sourcesContent":["var _ = require('../util').lodash,\n    Property = require('./property').Property,\n    PropertyList = require('./property-list').PropertyList,\n    Url = require('./url').Url,\n    UrlMatchPattern = require('../url-pattern/url-match-pattern').UrlMatchPattern,\n    UrlMatchPatternList = require('../url-pattern/url-match-pattern-list').UrlMatchPatternList,\n    ProxyConfig,\n    PROTOCOL_DELIMITER = UrlMatchPattern.PROTOCOL_DELIMITER,\n    E = '',\n    COLON = ':',\n    DEFAULT_PORT = 8080,\n    PROTOCOL_HOST_SEPARATOR = '://',\n    MATCH_ALL_HOST_AND_PATH = '*:*/*',\n    AUTH_CREDENTIALS_SEPARATOR = '@',\n    DEFAULT_PROTOCOL = 'http',\n    ALLOWED_PROTOCOLS = ['http', 'https'],\n    // 'http+https://*:*/*'\n    DEFAULT_PATTERN = ALLOWED_PROTOCOLS.join(PROTOCOL_DELIMITER) + PROTOCOL_HOST_SEPARATOR + MATCH_ALL_HOST_AND_PATH;\n\n/**\n* The following is the object structure accepted as constructor parameter while calling `new ProxyConfig(...)`. It is\n* also the structure exported when {@link Property#toJSON} or {@link Property#toObjectResolved} is called on a\n* Proxy instance.\n *\n* @typedef ProxyConfig.definition\n*\n* @property {String=} [match = 'http+https://*\\/*'] The match for which the proxy needs to be configured.\n* @property {String=} [host = ''] The proxy server url.\n* @property {Number=} [port = 8080] The proxy server port number.\n* @property {Boolean=} [tunnel = false] The tunneling option for the proxy request.\n* @property {Boolean=} [disabled = false] To override the proxy for the particular url, you need to provide true.\n* @property {Boolean=} [authenticate = false] To enable authentication for the proxy, you need to provide true.\n* @property {String=} [username] The proxy authentication username\n* @property {String=} [password] The proxy authentication password\n*\n* @example <caption>JSON definition of an example proxy object</caption>\n* {\n*     \"match\": \"http+https://example.com/*\",\n*     \"host\": \"proxy.com\",\n*     \"port\": \"8080\",\n*     \"tunnel\": true,\n*     \"disabled\": false,\n*     \"authenticate\": true,\n*     \"username\": \"proxy_username\",\n*     \"password\": \"proxy_password\"\n* }\n*/\n_.inherit((\n\n    /**\n     * A ProxyConfig definition that represents the proxy configuration for an url match.\n     * Properties can then use the `.toObjectResolved` function to procure an object representation of the property with\n     * all the variable references replaced by corresponding values.\n     *\n     * @constructor\n     * @extends {Property}\n     * @param {ProxyConfig.definition=} [options] - Specifies object with props matches, server and tunnel.\n     *\n     * @example <caption>Create a new ProxyConfig</caption>\n     * var ProxyConfig = require('postman-collection').ProxyConfig,\n     *     myProxyConfig = new ProxyConfig({\n     *          host: 'proxy.com',\n     *          match: 'http+https://example.com/*',\n     *          port: 8080,\n     *          tunnel: true,\n     *          disabled: false,\n     *          authenticate: true,\n     *          username: 'proxy_username',\n     *          password: 'proxy_password'\n     *     });\n     */\n    ProxyConfig = function ProxyConfig (options) {\n        // this constructor is intended to inherit and as such the super constructor is required to be executed\n        ProxyConfig.super_.call(this, options);\n\n        // Assign defaults before proceeding\n        _.assign(this, /** @lends ProxyConfig */ {\n            /**\n             * The proxy server host or ip\n             *\n             * @type {String}\n             */\n            host: E,\n\n            /**\n             * The url mach for which the proxy has been associated with.\n             *\n             * @type {String}\n             */\n            match: new UrlMatchPattern(DEFAULT_PATTERN),\n\n            /**\n             * The proxy server port number\n             *\n             * @type {Number}\n             */\n            port: DEFAULT_PORT,\n\n            /**\n             * This represents whether the tunneling needs to done while proxying this request.\n             *\n             * @type Boolean\n             */\n            tunnel: false,\n\n            /**\n             * Proxy bypass list\n             *\n             * @type {UrlMatchPatternList}\n             */\n            bypass: undefined,\n\n            /**\n             * Enable proxy authentication\n             *\n             * @type {Boolean}\n             */\n            authenticate: false,\n\n            /**\n             * Proxy auth username\n             *\n             * @type {String}\n             */\n            username: undefined,\n\n            /**\n             * Proxy auth password\n             *\n             * @type {String}\n             */\n            password: undefined\n        });\n\n        this.update(options);\n    }), Property);\n\n_.assign(ProxyConfig.prototype, /** @lends ProxyConfig.prototype */ {\n    /**\n     * Defines whether this property instances requires an id\n     *\n     * @private\n     * @readOnly\n     * @type {Boolean}\n     */\n    _postman_propertyRequiresId: true,\n\n    /**\n     * Updates the properties of the proxy object based on the options provided.\n     *\n     * @param {ProxyConfig.definition} options The proxy object structure.\n     */\n    update: function (options) {\n        if (!_.isObject(options)) {\n            return;\n        }\n\n        var parsedUrl,\n            port = _.get(options, 'port') >> 0;\n\n        if (_.isString(options.host)) {\n            // strip the protocol from given host\n            parsedUrl = new Url(options.host);\n            this.host = parsedUrl.getHost();\n        }\n\n        _.isString(options.match) && (this.match = new UrlMatchPattern(options.match));\n        _.isString(_.get(options, 'match.pattern')) && (this.match = new UrlMatchPattern(options.match.pattern));\n        port && (this.port = port);\n        _.isBoolean(options.tunnel) && (this.tunnel = options.tunnel);\n        // todo: Add update method in parent class Property and call that here\n        _.isBoolean(options.disabled) && (this.disabled = options.disabled);\n        _.isBoolean(options.authenticate) && (this.authenticate = options.authenticate);\n        _.isString(options.username) && (this.username = options.username);\n        _.isString(options.password) && (this.password = options.password);\n\n        // init bypass list from the given array\n        if (Array.isArray(options.bypass)) {\n            this.bypass = new UrlMatchPatternList(null, options.bypass);\n        }\n        // or, convert existing PropertyList or UrlMatchPatternList\n        else if (PropertyList.isPropertyList(options.bypass)) {\n            this.bypass = new UrlMatchPatternList(null, options.bypass.all());\n        }\n    },\n\n    /**\n     * Updates the protocols in the match pattern\n     *\n     * @param {Array.<String>} protocols The array of protocols\n     */\n    updateProtocols: function (protocols) {\n        if (!protocols) {\n            return;\n        }\n\n        var updatedProtocols,\n            hostAndPath = _.split(this.match.pattern, PROTOCOL_HOST_SEPARATOR)[1];\n\n        if (!hostAndPath) {\n            return;\n        }\n\n        updatedProtocols = _.intersection(ALLOWED_PROTOCOLS, _.castArray(protocols));\n        _.isEmpty(updatedProtocols) && (updatedProtocols = ALLOWED_PROTOCOLS);\n\n        this.match.update({\n            pattern: updatedProtocols.join(PROTOCOL_DELIMITER) + PROTOCOL_HOST_SEPARATOR + hostAndPath\n        });\n    },\n\n    /**\n     * Tests the url string with the match provided.\n     * Follows the https://developer.chrome.com/extensions/match_patterns pattern for pattern validation and matching\n     *\n     * @param {String=} [urlStr] The url string for which the proxy match needs to be done.\n     */\n    test: function (urlStr) {\n        var protocol = Url.isUrl(urlStr) ? urlStr.protocol : (Url.parse(urlStr || E).protocol || E);\n\n        // to allow target URLs without any protocol. e.g.: 'foo.com/bar'\n        if (_.isEmpty(protocol)) {\n            protocol = DEFAULT_PROTOCOL;\n            urlStr = protocol + PROTOCOL_HOST_SEPARATOR + urlStr;\n        }\n\n        // this ensures we don't proceed any further for any non-supported protocol\n        if (!_.includes(ALLOWED_PROTOCOLS, protocol)) {\n            return false;\n        }\n\n        // don't proceed if the given URL should skip use of a proxy all together\n        if (this.bypass && this.bypass.test(urlStr)) {\n            return false;\n        }\n\n        return this.match.test(urlStr);\n    },\n\n    /**\n     * Returns the proxy server url.\n     *\n     * @returns {String}\n     */\n    getProxyUrl: function () {\n        var auth = E;\n\n        // Add authentication method to URL if the same is requested. We do it this way because\n        // this is how `postman-request` library accepts auth credentials in its proxy configuration.\n        if (this.authenticate) {\n            auth = encodeURIComponent(this.username || E);\n\n            if (this.password) {\n                auth += COLON + encodeURIComponent(this.password);\n            }\n\n            if (auth) {\n                auth += AUTH_CREDENTIALS_SEPARATOR;\n            }\n        }\n\n        return DEFAULT_PROTOCOL + PROTOCOL_HOST_SEPARATOR + auth + this.host + COLON + this.port;\n    },\n\n    /**\n     * Returns the protocols supported.\n     *\n     * @returns {Array.<String>}\n     */\n    getProtocols: function () {\n        return this.match.getProtocols();\n    }\n});\n\n_.assign(ProxyConfig, /** @lends ProxyConfig */ {\n    /**\n     * Defines the name of this property for internal use.\n     *\n     * @private\n     * @readOnly\n     * @type {String}\n     */\n    _postman_propertyName: 'ProxyConfig',\n\n    /**\n     * Check whether an object is an instance of PostmanItem.\n     *\n     * @param {*} obj -\n     * @returns {Boolean}\n     */\n    isProxyConfig: function (obj) {\n        return Boolean(obj) && ((obj instanceof ProxyConfig) ||\n            _.inSuperChain(obj.constructor, '_postman_propertyName', ProxyConfig._postman_propertyName));\n    }\n});\n\nmodule.exports = {\n    ProxyConfig,\n    ALLOWED_PROTOCOLS,\n    DEFAULT_PATTERN\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}