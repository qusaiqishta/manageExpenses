{"ast":null,"code":"var util = require('../util'),\n  _ = util.lodash,\n  fileType = require('file-type'),\n  mimeType = require('mime-types'),\n  mimeFormat = require('mime-format'),\n  /**\n   * @private\n   * @const\n   * @type {String}\n   */\n  E = '',\n  /**\n   * @private\n   * @const\n   * @type {String}\n   */\n  DOT = '.',\n  /**\n   * @private\n   * @const\n   * @type {String}\n   */\n  QUESTION_MARK = '?',\n  /**\n   * @private\n   * @const\n   * @type {String}\n   */\n  DOUBLE_QUOTES = '\"',\n  /**\n   * @private\n   * @const\n   * @type {String}\n   */\n  TOKEN_$1 = '$1',\n  /**\n   * @private\n   * @const\n   * @type {String}\n   */\n  BINARY = 'binary',\n  /**\n   * @private\n   * @const\n   * @type {String}\n   */\n  CHARSET_UTF8 = 'utf8',\n  /**\n   * @private\n   * @const\n   * @type {String}\n   */\n  CONTENT_TYPE_TEXT_PLAIN = 'text/plain',\n  /**\n   * Enum for all the Content Headers\n   *\n   * @private\n   * @const\n   * @enum {String} HEADERS\n   */\n  HEADERS = {\n    CONTENT_TYPE: 'Content-Type',\n    CONTENT_DISPOSITION: 'Content-Disposition'\n  },\n  /**\n   * @private\n   * @const\n   * @type {String}\n   */\n  DEFAULT_RESPONSE_FILENAME = 'response',\n  /**\n   * @private\n   * @type {Boolean}\n   */\n  supportsBuffer = typeof Buffer !== undefined && _.isFunction(Buffer.byteLength),\n  /**\n   * Regexes for extracting and decoding the filename from content-disposition header\n   *\n   * @private\n   * @type {Object}\n   */\n  regexes = {\n    /**\n     * RegExp for extracting filename from content-disposition header\n     *\n     * RFC 2616 grammar\n     * parameter     = token \"=\" ( token | quoted-string )\n     * token         = 1*<any CHAR except CTLs or separators>\n     * separators    = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n     *               | \",\" | \";\" | \":\" | \"\\\" | <\">\n     *               | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n     *               | \"{\" | \"}\" | SP | HT\n     * quoted-string = ( <\"> *(qdtext | quoted-pair ) <\"> )\n     * qdtext        = <any TEXT except <\">>\n     * quoted-pair   = \"\\\" CHAR\n     * CHAR          = <any US-ASCII character (octets 0 - 127)>\n     * TEXT          = <any OCTET except CTLs, but including LWS>\n     * LWS           = [CRLF] 1*( SP | HT )\n     * CRLF          = CR LF\n     * CR            = <US-ASCII CR, carriage return (13)>\n     * LF            = <US-ASCII LF, linefeed (10)>\n     * SP            = <US-ASCII SP, space (32)>\n     * HT            = <US-ASCII HT, horizontal-tab (9)>\n     * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>\n     * OCTET         = <any 8-bit sequence of data>\n     *\n     * egHeader: inline; filename=testResponse.json\n     * egHeader: inline; filename=\"test Response.json\"\n     * Reference: https://github.com/jshttp/content-disposition\n     */\n    // eslint-disable-next-line max-len\n    fileNameRegex: /;[ \\t]*(?:filename)[ \\t]*=[ \\t]*(\"(?:[\\x20!\\x23-\\x5b\\x5d-\\x7e\\x80-\\xff]|\\\\[\\x20-\\x7e])*\"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[ \\t]*/,\n    /**\n     * RegExp for extracting filename* from content-disposition header\n     *\n     * RFC 5987 grammar\n     * parameter     = reg-parameter / ext-parameter\n     * ext-parameter = parmname \"*\" LWSP \"=\" LWSP ext-value\n     * parmname      = 1*attr-char\n     * ext-value     = charset  \"'\" [ language ] \"'\" value-chars\n                ; like RFC 2231's <extended-initial-value>\n                ; (see [RFC2231], Section 7)\n     * charset       = \"UTF-8\" / \"ISO-8859-1\" / mime-charset\n     * mime-charset  = 1*mime-charsetc\n     * mime-charsetc = ALPHA / DIGIT\n                / \"!\" / \"#\" / \"$\" / \"%\" / \"&\"\n                / \"+\" / \"-\" / \"^\" / \"_\" / \"`\"\n                / \"{\" / \"}\" / \"~\"\n                ; as <mime-charset> in Section 2.3 of [RFC2978]\n                ; except that the single quote is not included\n                ; SHOULD be registered in the IANA charset registry\n     * language      = <Language-Tag, defined in [RFC5646], Section 2.1>\n     * value-chars   = *( pct-encoded / attr-char )\n     * pct-encoded   = \"%\" HEXDIG HEXDIG\n                ; see [RFC3986], Section 2.1\n     * attr-char     = ALPHA / DIGIT\n                / \"!\" / \"#\" / \"$\" / \"&\" / \"+\" / \"-\" / \".\"\n                / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n                ; token except ( \"*\" / \"'\" / \"%\" )\n     *\n     * egHeader: attachment;filename*=utf-8''%E4%BD%A0%E5%A5%BD.txt\n     * Reference: https://github.com/jshttp/content-disposition\n     */\n    // eslint-disable-next-line max-len\n    encodedFileNameRegex: /;[ \\t]*(?:filename\\*)[ \\t]*=[ \\t]*([A-Za-z0-9!#$%&+\\-^_`{}~]+)'.*'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)[ \\t]*/,\n    /**\n     * RegExp to match quoted-pair in RFC 2616\n     *\n     * quoted-pair = \"\\\" CHAR\n     * CHAR        = <any US-ASCII character (octets 0 - 127)>\n     */\n    quotedPairRegex: /\\\\([ -~])/g,\n    /**\n     * Regex to match all the hexadecimal number inside encoded string\n     */\n    hexCharMatchRegex: /%([0-9A-Fa-f]{2})/g,\n    /**\n     * Regex to match non-latin characters\n     */\n    nonLatinCharMatchRegex: /[^\\x20-\\x7e\\xa0-\\xff]/g\n  },\n  /**\n   * Decodes the hexcode to charCode\n   *\n   * @private\n   * @param {String} str - The matched string part of a hexadecimal number\n   * @param {String} hex - The hexadecimal string which needs to be converted to charCode\n   * @returns {String} - String with decoded hexcode values\n   */\n  decodeHexcode = function (str, hex) {\n    return String.fromCharCode(parseInt(hex, 16));\n  },\n  /**\n   * HashMap for decoding string with supported characterSets\n   * iso-8859-1\n   * utf-8\n   *\n   * @private\n   * @type {Object}\n   */\n  characterDecoders = {\n    /**\n     * Replaces non-latin characters with '?'\n     *\n     * @private\n     * @param {String} val - Input encoded string\n     * @returns {String} - String with latin characters\n     */\n    'iso-8859-1'(val) {\n      return val.replace(regexes.nonLatinCharMatchRegex, QUESTION_MARK);\n    },\n    /**\n     * Decodes the given string with utf-8 character set\n     *\n     * @private\n     * @param {?String} encodedString - Input encoded string\n     * @returns {?String} - String with decoded character with utf-8\n     */\n    'utf-8'(encodedString) {\n      /* istanbul ignore if */\n      if (!supportsBuffer) {\n        return;\n      }\n      return Buffer.from(encodedString, BINARY).toString(CHARSET_UTF8);\n    }\n  },\n  /**\n   * Decodes the given filename with given charset\n   * The supported character sets are\n   * iso-8859-1\n   * utf-8\n   *\n   * @private\n   * @param {String} encodedFileName - Input encoded file name\n   * @param {String} charset - The character set to be used while decoding\n   * @returns {String} - Returns the decoded filename\n   */\n  decodeFileName = function (encodedFileName, charset) {\n    /* istanbul ignore if */\n    if (!encodedFileName) {\n      return;\n    }\n    if (!characterDecoders[charset]) {\n      return;\n    }\n\n    // decodes the hexadecimal numbers to charCode in encodedFileName and then decodes with given charset\n    return characterDecoders[charset](encodedFileName.replace(regexes.hexCharMatchRegex, decodeHexcode));\n  },\n  /**\n   * Takes the content-type header value and performs the mime sniffing with known mime types.\n   * If content-type header is not present, detects the mime type from the response stream or response body\n   * If content-type is not provided and not able to detect, then text/plain is taken as default\n   *\n   * @private\n   * @param {?String} contentType - The value of content type header\n   * @param {Stream|String} response - The response stream or body, for which content-info should be determined\n   * @returns {Object} - mime information from response headers\n   */\n  getMimeInfo = function (contentType, response) {\n    var normalized, detected, detectedExtension;\n    if (!contentType) {\n      detected = fileType(response);\n      detected && (contentType = detected.mime) && (detectedExtension = detected.ext);\n    }\n\n    // if contentType is not detected set text/plain as default\n    if (!contentType) {\n      contentType = CONTENT_TYPE_TEXT_PLAIN;\n    }\n    normalized = mimeFormat.lookup(contentType);\n    return {\n      contentType: normalized.source,\n      mimeType: normalized.type,\n      // sanitized mime type base\n      mimeFormat: normalized.format,\n      // format specific to the type returned\n      charset: normalized.charset || CHARSET_UTF8,\n      extension: detectedExtension || mimeType.extension(normalized.source) || E\n    };\n  },\n  /**\n   * Parses Content disposition header, and returns file name and extension\n   *\n   * @private\n   * @param {?String} dispositionHeader - Content-disposition Header from the response\n   * @returns {?String} - Returns file name from content disposition header if present\n   */\n  getFileNameFromDispositionHeader = function (dispositionHeader) {\n    if (!dispositionHeader) {\n      return;\n    }\n    var encodedFileName, fileName;\n\n    // Get filename* value from the dispositionHeader\n    encodedFileName = regexes.encodedFileNameRegex.exec(dispositionHeader);\n    if (encodedFileName) {\n      fileName = decodeFileName(encodedFileName[2], encodedFileName[1]);\n    }\n\n    // If filename* is not present or unparseable, then we are checking for filename in header\n    if (!fileName) {\n      fileName = regexes.fileNameRegex.exec(dispositionHeader);\n      fileName && (fileName = fileName[1]);\n\n      // check if file name is wrapped in double quotes\n      // file name can contain escaped characters if wrapped in quotes\n      if (fileName && fileName[0] === DOUBLE_QUOTES) {\n        // remove quotes and escapes\n        fileName = fileName.substr(1, fileName.length - 2).replace(regexes.quotedPairRegex, TOKEN_$1);\n      }\n    }\n    return fileName;\n  };\nmodule.exports = {\n  /**\n   * Extracts content related information from response.\n   * Includes response mime information, character set and file name.\n   *\n   * @private\n   * @param {Response} response - response instance\n   * @returns {Response.ResponseContentInfo} - Return contentInfo of the response\n   */\n  contentInfo(response) {\n    var contentType = response.headers.get(HEADERS.CONTENT_TYPE),\n      contentDisposition = response.headers.get(HEADERS.CONTENT_DISPOSITION),\n      mimeInfo = getMimeInfo(contentType, response.stream || response.body),\n      fileName = getFileNameFromDispositionHeader(contentDisposition),\n      fileExtension = mimeInfo.extension,\n      /**\n       * @typedef Response.ResponseContentInfo\n       *\n       * @property {String} mimeType sanitized mime type\n       * @property {String} mimeFormat format for the identified mime type\n       * @property {String} charset the normalized character set\n       * @property {String} fileExtension extension identified from the mime type\n       * @property {String} fileName file name extracted from disposition header\n       * @property {String} contentType sanitized content-type extracted from header\n       */\n      contentInfo = {};\n\n    // if file name is not present in the content disposition headers, use a default file name\n    if (!fileName) {\n      fileName = DEFAULT_RESPONSE_FILENAME;\n      // add extension to default if present\n      fileExtension && (fileName += DOT + fileExtension);\n    }\n\n    // create a compacted list of content info from mime info and file name\n    mimeInfo.contentType && (contentInfo.contentType = mimeInfo.contentType);\n    mimeInfo.mimeType && (contentInfo.mimeType = mimeInfo.mimeType);\n    mimeInfo.mimeFormat && (contentInfo.mimeFormat = mimeInfo.mimeFormat);\n    mimeInfo.charset && (contentInfo.charset = mimeInfo.charset);\n    fileExtension && (contentInfo.fileExtension = fileExtension);\n    fileName && (contentInfo.fileName = fileName);\n    return contentInfo;\n  },\n  // regexes are extracted for vulnerability tests\n  regexes\n};","map":{"version":3,"names":["util","require","_","lodash","fileType","mimeType","mimeFormat","E","DOT","QUESTION_MARK","DOUBLE_QUOTES","TOKEN_$1","BINARY","CHARSET_UTF8","CONTENT_TYPE_TEXT_PLAIN","HEADERS","CONTENT_TYPE","CONTENT_DISPOSITION","DEFAULT_RESPONSE_FILENAME","supportsBuffer","Buffer","undefined","isFunction","byteLength","regexes","fileNameRegex","encodedFileNameRegex","quotedPairRegex","hexCharMatchRegex","nonLatinCharMatchRegex","decodeHexcode","str","hex","String","fromCharCode","parseInt","characterDecoders","val","replace","encodedString","from","toString","decodeFileName","encodedFileName","charset","getMimeInfo","contentType","response","normalized","detected","detectedExtension","mime","ext","lookup","source","type","format","extension","getFileNameFromDispositionHeader","dispositionHeader","fileName","exec","substr","length","module","exports","contentInfo","headers","get","contentDisposition","mimeInfo","stream","body","fileExtension"],"sources":["/Users/Qusai.Qishta/node_modules/postman-collection/lib/content-info/index.js"],"sourcesContent":["var util = require('../util'),\n    _ = util.lodash,\n    fileType = require('file-type'),\n    mimeType = require('mime-types'),\n    mimeFormat = require('mime-format'),\n\n    /**\n     * @private\n     * @const\n     * @type {String}\n     */\n    E = '',\n\n    /**\n     * @private\n     * @const\n     * @type {String}\n     */\n    DOT = '.',\n\n    /**\n     * @private\n     * @const\n     * @type {String}\n     */\n    QUESTION_MARK = '?',\n\n    /**\n     * @private\n     * @const\n     * @type {String}\n     */\n    DOUBLE_QUOTES = '\"',\n\n    /**\n     * @private\n     * @const\n     * @type {String}\n     */\n    TOKEN_$1 = '$1',\n\n    /**\n     * @private\n     * @const\n     * @type {String}\n     */\n    BINARY = 'binary',\n\n    /**\n     * @private\n     * @const\n     * @type {String}\n     */\n    CHARSET_UTF8 = 'utf8',\n\n    /**\n     * @private\n     * @const\n     * @type {String}\n     */\n    CONTENT_TYPE_TEXT_PLAIN = 'text/plain',\n\n    /**\n     * Enum for all the Content Headers\n     *\n     * @private\n     * @const\n     * @enum {String} HEADERS\n     */\n    HEADERS = {\n        CONTENT_TYPE: 'Content-Type',\n        CONTENT_DISPOSITION: 'Content-Disposition'\n    },\n\n    /**\n     * @private\n     * @const\n     * @type {String}\n     */\n    DEFAULT_RESPONSE_FILENAME = 'response',\n\n    /**\n     * @private\n     * @type {Boolean}\n     */\n    supportsBuffer = (typeof Buffer !== undefined) && _.isFunction(Buffer.byteLength),\n\n    /**\n     * Regexes for extracting and decoding the filename from content-disposition header\n     *\n     * @private\n     * @type {Object}\n     */\n    regexes = {\n\n        /**\n         * RegExp for extracting filename from content-disposition header\n         *\n         * RFC 2616 grammar\n         * parameter     = token \"=\" ( token | quoted-string )\n         * token         = 1*<any CHAR except CTLs or separators>\n         * separators    = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n         *               | \",\" | \";\" | \":\" | \"\\\" | <\">\n         *               | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n         *               | \"{\" | \"}\" | SP | HT\n         * quoted-string = ( <\"> *(qdtext | quoted-pair ) <\"> )\n         * qdtext        = <any TEXT except <\">>\n         * quoted-pair   = \"\\\" CHAR\n         * CHAR          = <any US-ASCII character (octets 0 - 127)>\n         * TEXT          = <any OCTET except CTLs, but including LWS>\n         * LWS           = [CRLF] 1*( SP | HT )\n         * CRLF          = CR LF\n         * CR            = <US-ASCII CR, carriage return (13)>\n         * LF            = <US-ASCII LF, linefeed (10)>\n         * SP            = <US-ASCII SP, space (32)>\n         * HT            = <US-ASCII HT, horizontal-tab (9)>\n         * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>\n         * OCTET         = <any 8-bit sequence of data>\n         *\n         * egHeader: inline; filename=testResponse.json\n         * egHeader: inline; filename=\"test Response.json\"\n         * Reference: https://github.com/jshttp/content-disposition\n         */\n        // eslint-disable-next-line max-len\n        fileNameRegex: /;[ \\t]*(?:filename)[ \\t]*=[ \\t]*(\"(?:[\\x20!\\x23-\\x5b\\x5d-\\x7e\\x80-\\xff]|\\\\[\\x20-\\x7e])*\"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[ \\t]*/,\n\n        /**\n         * RegExp for extracting filename* from content-disposition header\n         *\n         * RFC 5987 grammar\n         * parameter     = reg-parameter / ext-parameter\n         * ext-parameter = parmname \"*\" LWSP \"=\" LWSP ext-value\n         * parmname      = 1*attr-char\n         * ext-value     = charset  \"'\" [ language ] \"'\" value-chars\n                    ; like RFC 2231's <extended-initial-value>\n                    ; (see [RFC2231], Section 7)\n         * charset       = \"UTF-8\" / \"ISO-8859-1\" / mime-charset\n         * mime-charset  = 1*mime-charsetc\n         * mime-charsetc = ALPHA / DIGIT\n                    / \"!\" / \"#\" / \"$\" / \"%\" / \"&\"\n                    / \"+\" / \"-\" / \"^\" / \"_\" / \"`\"\n                    / \"{\" / \"}\" / \"~\"\n                    ; as <mime-charset> in Section 2.3 of [RFC2978]\n                    ; except that the single quote is not included\n                    ; SHOULD be registered in the IANA charset registry\n         * language      = <Language-Tag, defined in [RFC5646], Section 2.1>\n         * value-chars   = *( pct-encoded / attr-char )\n         * pct-encoded   = \"%\" HEXDIG HEXDIG\n                    ; see [RFC3986], Section 2.1\n         * attr-char     = ALPHA / DIGIT\n                    / \"!\" / \"#\" / \"$\" / \"&\" / \"+\" / \"-\" / \".\"\n                    / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n                    ; token except ( \"*\" / \"'\" / \"%\" )\n         *\n         * egHeader: attachment;filename*=utf-8''%E4%BD%A0%E5%A5%BD.txt\n         * Reference: https://github.com/jshttp/content-disposition\n         */\n        // eslint-disable-next-line max-len\n        encodedFileNameRegex: /;[ \\t]*(?:filename\\*)[ \\t]*=[ \\t]*([A-Za-z0-9!#$%&+\\-^_`{}~]+)'.*'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)[ \\t]*/,\n\n        /**\n         * RegExp to match quoted-pair in RFC 2616\n         *\n         * quoted-pair = \"\\\" CHAR\n         * CHAR        = <any US-ASCII character (octets 0 - 127)>\n         */\n        quotedPairRegex: /\\\\([ -~])/g,\n\n        /**\n         * Regex to match all the hexadecimal number inside encoded string\n         */\n        hexCharMatchRegex: /%([0-9A-Fa-f]{2})/g,\n\n        /**\n         * Regex to match non-latin characters\n         */\n        nonLatinCharMatchRegex: /[^\\x20-\\x7e\\xa0-\\xff]/g\n    },\n\n    /**\n     * Decodes the hexcode to charCode\n     *\n     * @private\n     * @param {String} str - The matched string part of a hexadecimal number\n     * @param {String} hex - The hexadecimal string which needs to be converted to charCode\n     * @returns {String} - String with decoded hexcode values\n     */\n    decodeHexcode = function (str, hex) {\n        return String.fromCharCode(parseInt(hex, 16));\n    },\n\n    /**\n     * HashMap for decoding string with supported characterSets\n     * iso-8859-1\n     * utf-8\n     *\n     * @private\n     * @type {Object}\n     */\n    characterDecoders = {\n\n        /**\n         * Replaces non-latin characters with '?'\n         *\n         * @private\n         * @param {String} val - Input encoded string\n         * @returns {String} - String with latin characters\n         */\n        'iso-8859-1' (val) {\n            return val.replace(regexes.nonLatinCharMatchRegex, QUESTION_MARK);\n        },\n\n        /**\n         * Decodes the given string with utf-8 character set\n         *\n         * @private\n         * @param {?String} encodedString - Input encoded string\n         * @returns {?String} - String with decoded character with utf-8\n         */\n        'utf-8' (encodedString) {\n            /* istanbul ignore if */\n            if (!supportsBuffer) {\n                return;\n            }\n\n            return Buffer.from(encodedString, BINARY).toString(CHARSET_UTF8);\n        }\n    },\n\n    /**\n     * Decodes the given filename with given charset\n     * The supported character sets are\n     * iso-8859-1\n     * utf-8\n     *\n     * @private\n     * @param {String} encodedFileName - Input encoded file name\n     * @param {String} charset - The character set to be used while decoding\n     * @returns {String} - Returns the decoded filename\n     */\n    decodeFileName = function (encodedFileName, charset) {\n        /* istanbul ignore if */\n        if (!encodedFileName) {\n            return;\n        }\n\n        if (!characterDecoders[charset]) {\n            return;\n        }\n\n        // decodes the hexadecimal numbers to charCode in encodedFileName and then decodes with given charset\n        return characterDecoders[charset](encodedFileName.replace(regexes.hexCharMatchRegex, decodeHexcode));\n    },\n\n    /**\n     * Takes the content-type header value and performs the mime sniffing with known mime types.\n     * If content-type header is not present, detects the mime type from the response stream or response body\n     * If content-type is not provided and not able to detect, then text/plain is taken as default\n     *\n     * @private\n     * @param {?String} contentType - The value of content type header\n     * @param {Stream|String} response - The response stream or body, for which content-info should be determined\n     * @returns {Object} - mime information from response headers\n     */\n    getMimeInfo = function (contentType, response) {\n        var normalized,\n            detected,\n            detectedExtension;\n\n\n        if (!contentType) {\n            detected = fileType(response);\n            detected && (contentType = detected.mime) && (detectedExtension = detected.ext);\n        }\n\n        // if contentType is not detected set text/plain as default\n        if (!contentType) {\n            contentType = CONTENT_TYPE_TEXT_PLAIN;\n        }\n\n        normalized = mimeFormat.lookup(contentType);\n\n        return {\n            contentType: normalized.source,\n            mimeType: normalized.type, // sanitized mime type base\n            mimeFormat: normalized.format, // format specific to the type returned\n            charset: normalized.charset || CHARSET_UTF8,\n            extension: detectedExtension || mimeType.extension(normalized.source) || E\n        };\n    },\n\n    /**\n     * Parses Content disposition header, and returns file name and extension\n     *\n     * @private\n     * @param {?String} dispositionHeader - Content-disposition Header from the response\n     * @returns {?String} - Returns file name from content disposition header if present\n     */\n    getFileNameFromDispositionHeader = function (dispositionHeader) {\n        if (!dispositionHeader) {\n            return;\n        }\n\n        var encodedFileName,\n            fileName;\n\n        // Get filename* value from the dispositionHeader\n        encodedFileName = regexes.encodedFileNameRegex.exec(dispositionHeader);\n\n        if (encodedFileName) {\n            fileName = decodeFileName(encodedFileName[2], encodedFileName[1]);\n        }\n\n        // If filename* is not present or unparseable, then we are checking for filename in header\n        if (!fileName) {\n            fileName = regexes.fileNameRegex.exec(dispositionHeader);\n            fileName && (fileName = fileName[1]);\n\n            // check if file name is wrapped in double quotes\n            // file name can contain escaped characters if wrapped in quotes\n            if (fileName && fileName[0] === DOUBLE_QUOTES) {\n                // remove quotes and escapes\n                fileName = fileName\n                    .substr(1, fileName.length - 2)\n                    .replace(regexes.quotedPairRegex, TOKEN_$1);\n            }\n        }\n\n        return fileName;\n    };\n\n\nmodule.exports = {\n\n    /**\n     * Extracts content related information from response.\n     * Includes response mime information, character set and file name.\n     *\n     * @private\n     * @param {Response} response - response instance\n     * @returns {Response.ResponseContentInfo} - Return contentInfo of the response\n     */\n    contentInfo (response) {\n        var contentType = response.headers.get(HEADERS.CONTENT_TYPE),\n            contentDisposition = response.headers.get(HEADERS.CONTENT_DISPOSITION),\n            mimeInfo = getMimeInfo(contentType, response.stream || response.body),\n            fileName = getFileNameFromDispositionHeader(contentDisposition),\n            fileExtension = mimeInfo.extension,\n\n            /**\n             * @typedef Response.ResponseContentInfo\n             *\n             * @property {String} mimeType sanitized mime type\n             * @property {String} mimeFormat format for the identified mime type\n             * @property {String} charset the normalized character set\n             * @property {String} fileExtension extension identified from the mime type\n             * @property {String} fileName file name extracted from disposition header\n             * @property {String} contentType sanitized content-type extracted from header\n             */\n            contentInfo = {};\n\n\n        // if file name is not present in the content disposition headers, use a default file name\n        if (!fileName) {\n            fileName = DEFAULT_RESPONSE_FILENAME;\n            // add extension to default if present\n            fileExtension && (fileName += (DOT + fileExtension));\n        }\n\n        // create a compacted list of content info from mime info and file name\n        mimeInfo.contentType && (contentInfo.contentType = mimeInfo.contentType);\n        mimeInfo.mimeType && (contentInfo.mimeType = mimeInfo.mimeType);\n        mimeInfo.mimeFormat && (contentInfo.mimeFormat = mimeInfo.mimeFormat);\n        mimeInfo.charset && (contentInfo.charset = mimeInfo.charset);\n        fileExtension && (contentInfo.fileExtension = fileExtension);\n        fileName && (contentInfo.fileName = fileName);\n\n        return contentInfo;\n    },\n    // regexes are extracted for vulnerability tests\n    regexes\n};\n"],"mappings":"AAAA,IAAIA,IAAI,GAAGC,OAAO,CAAC,SAAS,CAAC;EACzBC,CAAC,GAAGF,IAAI,CAACG,MAAM;EACfC,QAAQ,GAAGH,OAAO,CAAC,WAAW,CAAC;EAC/BI,QAAQ,GAAGJ,OAAO,CAAC,YAAY,CAAC;EAChCK,UAAU,GAAGL,OAAO,CAAC,aAAa,CAAC;EAEnC;AACJ;AACA;AACA;AACA;EACIM,CAAC,GAAG,EAAE;EAEN;AACJ;AACA;AACA;AACA;EACIC,GAAG,GAAG,GAAG;EAET;AACJ;AACA;AACA;AACA;EACIC,aAAa,GAAG,GAAG;EAEnB;AACJ;AACA;AACA;AACA;EACIC,aAAa,GAAG,GAAG;EAEnB;AACJ;AACA;AACA;AACA;EACIC,QAAQ,GAAG,IAAI;EAEf;AACJ;AACA;AACA;AACA;EACIC,MAAM,GAAG,QAAQ;EAEjB;AACJ;AACA;AACA;AACA;EACIC,YAAY,GAAG,MAAM;EAErB;AACJ;AACA;AACA;AACA;EACIC,uBAAuB,GAAG,YAAY;EAEtC;AACJ;AACA;AACA;AACA;AACA;AACA;EACIC,OAAO,GAAG;IACNC,YAAY,EAAE,cAAc;IAC5BC,mBAAmB,EAAE;EACzB,CAAC;EAED;AACJ;AACA;AACA;AACA;EACIC,yBAAyB,GAAG,UAAU;EAEtC;AACJ;AACA;AACA;EACIC,cAAc,GAAI,OAAOC,MAAM,KAAKC,SAAS,IAAKnB,CAAC,CAACoB,UAAU,CAACF,MAAM,CAACG,UAAU,CAAC;EAEjF;AACJ;AACA;AACA;AACA;AACA;EACIC,OAAO,GAAG;IAEN;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ;IACAC,aAAa,EAAE,6HAA6H;IAE5I;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ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"},"metadata":{},"sourceType":"script"}