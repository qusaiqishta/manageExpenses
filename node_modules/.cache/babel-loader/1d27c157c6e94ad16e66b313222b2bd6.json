{"ast":null,"code":"var url = require('url');\nvar EMPTY = '';\nvar ZERO = '0';\nvar PERCENT = '%';\nvar STRING = 'string';\nvar AMPERSAND = '&';\nvar EQUALS = '=';\nvar QUESTION_MARK = '?';\nvar stringify;\nvar parse;\n\n/**\n * Percent encode a character with given code.\n *\n * @param {Number} c - character code of the character to encode\n * @returns {String} - percent encoding of given character\n */\nvar percentEncode = function (c) {\n  var hex = c.toString(16).toUpperCase();\n  hex.length === 1 && (hex = ZERO + hex);\n  return PERCENT + hex;\n};\n\n/**\n * Checks if character with given code is valid hexadecimal digit or not.\n *\n * @param {Number} byte\n * @returns {Boolean}\n */\nvar isPreEncodedCharacter = function (byte) {\n  return byte >= 0x30 && byte <= 0x39 ||\n  // 0-9\n  byte >= 0x41 && byte <= 0x46 ||\n  // A-F\n  byte >= 0x61 && byte <= 0x66; // a-f\n};\n\n/**\n * Checks if character at given index in the buffer is already percent encoded or not.\n *\n * @param {Buffer} buffer\n * @param {Number} i\n * @returns {Boolean}\n */\nvar isPreEncoded = function (buffer, i) {\n  // If it is % check next two bytes for percent encode characters\n  // looking for pattern %00 - %FF\n  return buffer[i] === 0x25 && isPreEncodedCharacter(buffer[i + 1]) && isPreEncodedCharacter(buffer[i + 2]);\n};\n\n/**\n * Checks whether given character should be percent encoded or not for fixture.\n *\n * @param {Number} byte\n * @returns {Boolean}\n */\nvar charactersToPercentEncode = function (byte) {\n  return byte < 0x23 || byte > 0x7E ||\n  // Below # and after ~\n  byte === 0x3C || byte === 0x3E ||\n  // > and <\n  byte === 0x28 || byte === 0x29 ||\n  // ( and )\n  byte === 0x25 ||\n  // %\n  byte === 0x27 ||\n  // '\n  byte === 0x2A // *\n  ;\n};\n\n/**\n * Percent encode a query string according to RFC 3986.\n * Note: This function is supposed to be used on top of node's inbuilt url encoding\n *       to solve issue https://github.com/nodejs/node/issues/8321\n *\n * @param {String} value\n * @returns {String}\n */\nvar encode = function (value) {\n  if (!value) {\n    return EMPTY;\n  }\n  var buffer = Buffer.from(value);\n  var ret = EMPTY;\n  var i;\n  var ii;\n  for (i = 0, ii = buffer.length; i < ii; ++i) {\n    if (charactersToPercentEncode(buffer[i]) && !isPreEncoded(buffer, i)) {\n      ret += percentEncode(buffer[i]);\n    } else {\n      ret += String.fromCodePoint(buffer[i]); // Only works in ES6 (available in Node v4+)\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Parses a query string into an array, preserving parameter values\n *\n * @param string\n * @returns {*}\n */\nparse = function (string) {\n  var parts;\n  if (typeof string === STRING) {\n    // eslint-disable-line valid-typeof\n    parts = string.split(AMPERSAND);\n    return parts.map(function (param, idx) {\n      if (param === EMPTY && idx !== parts.length - 1) {\n        return {\n          key: null,\n          value: null\n        };\n      }\n      var index = typeof param === STRING ? param.indexOf(EQUALS) : -1; // eslint-disable-line valid-typeof\n      var paramObj = {};\n\n      // this means that there was no value for this key (not even blank, so we store this info) and the value is set\n      // to null\n      if (index < 0) {\n        paramObj.key = param.substr(0, param.length);\n        paramObj.value = null;\n      } else {\n        paramObj.key = param.substr(0, index);\n        paramObj.value = param.substr(index + 1);\n      }\n      return paramObj;\n    });\n  }\n  return [];\n};\n\n/**\n * Stringifies a query string, from an array of parameters\n *\n * @param parameters\n * @returns {string}\n */\nstringify = function (parameters) {\n  return parameters ? parameters.map(function (param) {\n    var key = param.key;\n    var value = param.value;\n    if (value === undefined) {\n      return EMPTY;\n    }\n    if (key === null) {\n      key = EMPTY;\n    }\n    if (value === null) {\n      return encode(key);\n    }\n    return encode(key) + EQUALS + encode(value);\n  }).join(AMPERSAND) : EMPTY;\n};\n\n/**\n * Correctly URL encodes query parameters in a URL and returns the final parsed URL.\n *\n * @param str\n */\nmodule.exports = function (str) {\n  var parsed = url.parse(str);\n  var rawQs;\n  var search;\n  var path;\n  var qs;\n  rawQs = parsed.query;\n  if (rawQs && rawQs.length) {\n    qs = stringify(parse(parsed.query));\n    search = QUESTION_MARK + qs;\n    path = parsed.pathname + search;\n    parsed.query = qs;\n    parsed.search = search;\n    parsed.path = path;\n    str = url.format(parsed);\n  }\n\n  // Parse again, because Node does not guarantee consistency of properties\n  return url.parse(str);\n};\nmodule.exports.parse = parse;\nmodule.exports.stringify = stringify;","map":{"version":3,"names":["url","require","EMPTY","ZERO","PERCENT","STRING","AMPERSAND","EQUALS","QUESTION_MARK","stringify","parse","percentEncode","c","hex","toString","toUpperCase","length","isPreEncodedCharacter","byte","isPreEncoded","buffer","i","charactersToPercentEncode","encode","value","Buffer","from","ret","ii","String","fromCodePoint","string","parts","split","map","param","idx","key","index","indexOf","paramObj","substr","parameters","undefined","join","module","exports","str","parsed","rawQs","search","path","qs","query","pathname","format"],"sources":["/Users/Qusai.Qishta/node_modules/postman-request/lib/url-parse.js"],"sourcesContent":["var url = require('url')\nvar EMPTY = ''\nvar ZERO = '0'\nvar PERCENT = '%'\nvar STRING = 'string'\nvar AMPERSAND = '&'\nvar EQUALS = '='\nvar QUESTION_MARK = '?'\nvar stringify\nvar parse\n\n/**\n * Percent encode a character with given code.\n *\n * @param {Number} c - character code of the character to encode\n * @returns {String} - percent encoding of given character\n */\nvar percentEncode = function (c) {\n  var hex = c.toString(16).toUpperCase()\n  hex.length === 1 && (hex = ZERO + hex)\n  return PERCENT + hex\n}\n\n/**\n * Checks if character with given code is valid hexadecimal digit or not.\n *\n * @param {Number} byte\n * @returns {Boolean}\n */\nvar isPreEncodedCharacter = function (byte) {\n  return (byte >= 0x30 && byte <= 0x39) || // 0-9\n    (byte >= 0x41 && byte <= 0x46) || // A-F\n    (byte >= 0x61 && byte <= 0x66) // a-f\n}\n\n/**\n * Checks if character at given index in the buffer is already percent encoded or not.\n *\n * @param {Buffer} buffer\n * @param {Number} i\n * @returns {Boolean}\n */\nvar isPreEncoded = function (buffer, i) {\n  // If it is % check next two bytes for percent encode characters\n  // looking for pattern %00 - %FF\n  return (buffer[i] === 0x25 &&\n    (isPreEncodedCharacter(buffer[i + 1]) &&\n    isPreEncodedCharacter(buffer[i + 2]))\n  )\n}\n\n/**\n * Checks whether given character should be percent encoded or not for fixture.\n *\n * @param {Number} byte\n * @returns {Boolean}\n */\nvar charactersToPercentEncode = function (byte) {\n  return (byte < 0x23 || byte > 0x7E || // Below # and after ~\n    byte === 0x3C || byte === 0x3E || // > and <\n    byte === 0x28 || byte === 0x29 || // ( and )\n    byte === 0x25 || // %\n    byte === 0x27 || // '\n    byte === 0x2A // *\n  )\n}\n\n/**\n * Percent encode a query string according to RFC 3986.\n * Note: This function is supposed to be used on top of node's inbuilt url encoding\n *       to solve issue https://github.com/nodejs/node/issues/8321\n *\n * @param {String} value\n * @returns {String}\n */\nvar encode = function (value) {\n  if (!value) { return EMPTY }\n\n  var buffer = Buffer.from(value)\n  var ret = EMPTY\n  var i\n  var ii\n\n  for (i = 0, ii = buffer.length; i < ii; ++i) {\n    if (charactersToPercentEncode(buffer[i]) && !isPreEncoded(buffer, i)) {\n      ret += percentEncode(buffer[i])\n    } else {\n      ret += String.fromCodePoint(buffer[i]) // Only works in ES6 (available in Node v4+)\n    }\n  }\n\n  return ret\n}\n\n/**\n * Parses a query string into an array, preserving parameter values\n *\n * @param string\n * @returns {*}\n */\nparse = function (string) {\n  var parts\n  if (typeof string === STRING) { // eslint-disable-line valid-typeof\n    parts = string.split(AMPERSAND)\n    return parts.map(function (param, idx) {\n      if (param === EMPTY && idx !== (parts.length - 1)) {\n        return { key: null, value: null }\n      }\n\n      var index = (typeof param === STRING) ? param.indexOf(EQUALS) : -1 // eslint-disable-line valid-typeof\n      var paramObj = {}\n\n      // this means that there was no value for this key (not even blank, so we store this info) and the value is set\n      // to null\n      if (index < 0) {\n        paramObj.key = param.substr(0, param.length)\n        paramObj.value = null\n      } else {\n        paramObj.key = param.substr(0, index)\n        paramObj.value = param.substr(index + 1)\n      }\n\n      return paramObj\n    })\n  }\n  return []\n}\n\n/**\n * Stringifies a query string, from an array of parameters\n *\n * @param parameters\n * @returns {string}\n */\nstringify = function (parameters) {\n  return parameters ? parameters.map(function (param) {\n    var key = param.key\n    var value = param.value\n\n    if (value === undefined) {\n      return EMPTY\n    }\n\n    if (key === null) {\n      key = EMPTY\n    }\n\n    if (value === null) {\n      return encode(key)\n    }\n\n    return encode(key) + EQUALS + encode(value)\n  }).join(AMPERSAND) : EMPTY\n}\n\n/**\n * Correctly URL encodes query parameters in a URL and returns the final parsed URL.\n *\n * @param str\n */\nmodule.exports = function (str) {\n  var parsed = url.parse(str)\n  var rawQs\n  var search\n  var path\n  var qs\n\n  rawQs = parsed.query\n\n  if (rawQs && rawQs.length) {\n    qs = stringify(parse(parsed.query))\n    search = QUESTION_MARK + qs\n    path = parsed.pathname + search\n\n    parsed.query = qs\n    parsed.search = search\n    parsed.path = path\n\n    str = url.format(parsed)\n  }\n\n  // Parse again, because Node does not guarantee consistency of properties\n  return url.parse(str)\n}\n\nmodule.exports.parse = parse\nmodule.exports.stringify = stringify\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}