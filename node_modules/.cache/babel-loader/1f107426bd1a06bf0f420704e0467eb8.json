{"ast":null,"code":"var _ = require('lodash'),\n  sdk = require('postman-collection'),\n  SerialiseError = require('serialised-error'),\n  RunSummary;\n\n/**\n * Creates and returns a RunSummary instance for the current collection run.\n *\n * @constructor\n * @param {EventEmitter} emitter - An EventEmitter instance with event handler attachments to add run information to.\n * @param {Object} options - A set of run summary creation options.\n */\nRunSummary = function RunSummary(emitter, options) {\n  // keep a copy of this instance since, we need to refer to this from various events\n  var summary = this;\n\n  // and store the trackers and failures in the summary object itself\n  _.assign(summary, /** @lends RunSummary.prototype */{\n    /**\n     * The collection that is being executed.\n     *\n     * @type {Collection}\n     */\n    collection: _.get(options, 'collection'),\n    /**\n     * The environment that is being used during the run\n     *\n     * @type {VariableScope}\n     *\n     */\n    environment: _.get(options, 'environment'),\n    /**\n     * Global variables being used during the run\n     *\n     * @type {VariableScope}\n     */\n    globals: _.get(options, 'globals'),\n    /**\n     * Holds information related to the run.\n     */\n    run: {\n      /**\n       * Holds the statistics of the run. Each property in it is the item being tracked and has three numeric\n       * properties - total, failed, pending\n       *\n       * @type {Object.<Object>}\n       */\n      stats: {\n        iterations: {},\n        items: {},\n        scripts: {},\n        prerequests: {},\n        requests: {},\n        tests: {},\n        assertions: {},\n        testScripts: {},\n        prerequestScripts: {}\n      },\n      /**\n       * Stores all generic timing information\n       *\n       * @type {Object}\n       */\n      timings: {\n        /**\n         * The average response time of the run\n         *\n         * @type {number}\n         */\n        responseAverage: 0,\n        /**\n         * The miminum response time of the run\n         *\n         * @type {number}\n         */\n        responseMin: 0,\n        /**\n         * The maximum response time of the run\n         *\n         * @type {number}\n         */\n        responseMax: 0,\n        /**\n         * Standard deviation of response time of the run\n         *\n         * @type {number}\n         */\n        responseSd: 0,\n        /**\n         * The average DNS lookup time of the run\n         *\n         * @type {number}\n         */\n        dnsAverage: 0,\n        /**\n         * The minimum DNS lookup time of the run\n         *\n         * @type {number}\n         */\n        dnsMin: 0,\n        /**\n         * The maximum DNS lookup time of the run\n         *\n         * @type {number}\n         */\n        dnsMax: 0,\n        /**\n         * Standard deviation of DNS lookup time of the run\n         *\n         * @type {number}\n         */\n        dnsSd: 0,\n        /**\n         * The average first byte time of the run\n         *\n         * @type {number}\n         */\n        firstByteAverage: 0,\n        /**\n         * The minimum first byte time of the run\n         *\n         * @type {number}\n         */\n        firstByteMin: 0,\n        /**\n         * The maximum first byte time of the run\n         *\n         * @type {number}\n         */\n        firstByteMax: 0,\n        /**\n         * Standard deviation of first byte time of the run\n         *\n         * @type {number}\n         */\n        firstByteSd: 0\n      },\n      /**\n       * Stores detailed information about the order of execution, request, response and assertions\n       *\n       * @type {Array<Object>}\n       */\n      executions: [],\n      /**\n       * Stores information on data transfer made during the collection\n       *\n       * @type {Object}\n       */\n      transfers: {\n        /**\n         * The total data received as response to every request\n         *\n         * @type {number}\n         */\n        responseTotal: 0\n      },\n      /**\n       * An array of all errors encountered during the run\n       *\n       * @type {Array.<Error>}\n       */\n      failures: [],\n      /**\n       * This stores any fatal error during the run that caused the run to abort prematurely.\n       *\n       * @type {Error}\n       */\n      error: null\n    }\n  });\n\n  // track run timings (start and end)\n  RunSummary.attachTimingTrackers(this, emitter);\n\n  // accumulate statistics on all event\n  // for all types of events track the counters for the event and its corresponding \"before\" counterpart\n  RunSummary.attachStatisticTrackers(this, emitter);\n\n  // accumulate statistics on requests - such as size and time\n  RunSummary.attachRequestTracker(this, emitter);\n\n  // accumulate errors (failures) from all events\n  RunSummary.attachFailureTrackers(this, emitter);\n\n  // accumulate all execution specific data in collection\n  RunSummary.attachReportingTrackers(this, emitter);\n};\n_.assign(RunSummary, {\n  attachReportingTrackers(summary, emitter) {\n    var cache = {},\n      executions = summary.run.executions;\n    emitter.on('beforeItem', function (err, o) {\n      if (err || !_.get(o, 'cursor.ref')) {\n        return;\n      }\n      cache[o.cursor.ref] = _.assignIn(cache[o.cursor.ref] || {}, {\n        cursor: o.cursor,\n        item: o.item\n      });\n    });\n\n    // save all responses in executions array\n    emitter.on('request', function (err, o) {\n      if (!_.get(o, 'cursor.ref')) {\n        return;\n      }\n      var execution = cache[o.cursor.ref] = cache[o.cursor.ref] || {};\n      executions.push(_.assignIn(execution, {\n        cursor: o.cursor,\n        request: o.request,\n        response: o.response,\n        id: _.get(o, 'item.id')\n      }, err && {\n        requestError: err || undefined\n      }));\n    });\n\n    // save all script execution errors in each execution\n    emitter.on('script', function (err, o) {\n      if (!_.get(o, 'cursor.ref')) {\n        return;\n      }\n      var execution = cache[o.cursor.ref] = cache[o.cursor.ref] || {},\n        eventName = o && o.event && o.event.listen + 'Script';\n\n      // store the script error corresponding to the script event name\n      err && execution && eventName && (execution[eventName] || (execution[eventName] = [])).push({\n        error: err\n      });\n    });\n\n    // save all assertions in each execution\n    emitter.on('assertion', function (err, o) {\n      if (!_.get(o, 'cursor.ref')) {\n        return;\n      }\n      var execution = cache[o.cursor.ref] = cache[o.cursor.ref] || {};\n      if (!execution) {\n        return;\n      }\n      (execution.assertions || (execution.assertions = [])).push({\n        assertion: o.assertion,\n        skipped: o.skipped,\n        error: err || undefined\n      });\n    });\n  },\n  attachTimingTrackers(summary, emitter) {\n    // mark the point when the run started\n    // also mark the point when run completed and also store error if needed\n    emitter.on('start', function () {\n      summary.run.timings.started = Date.now();\n    });\n    emitter.on('beforeDone', function () {\n      summary.run.timings.completed = Date.now();\n    });\n    emitter.on('done', function (err) {\n      err && (summary.error = err);\n    });\n  },\n  attachStatisticTrackers(summary, emitter) {\n    // accumulate statistics on all event\n    // for all types of events track the counters for the event and its corresponding \"before\" counterpart\n    _.forEach(summary.run.stats, function (tracker, name) {\n      // the actual event names are singular than their plural trackers, so we make the name singular\n      name = name.slice(0, -1); // remove last character\n\n      // populate initial values of trackers\n      _.assign(tracker, {\n        total: 0,\n        pending: 0,\n        failed: 0\n      });\n\n      // Set up common listeners for a set of events, which tracks how many times they were executed and records\n      // the ones which had an error passed as first argument\n      emitter.on(_.camelCase('before-' + name), function () {\n        tracker.pending += 1;\n      });\n      emitter.on(name, function (err) {\n        // check pending so that, it does not negate for items that do not have a `before` counterpart\n        tracker.pending && (tracker.pending -= 1);\n        err && (tracker.failed += 1);\n        tracker.total += 1;\n      });\n    });\n  },\n  attachRequestTracker(summary, emitter) {\n    // accumulate statistics on requests\n    emitter.on('request', function (err, o) {\n      if (err || !(o && o.response)) {\n        return;\n      }\n      var size = _.isFunction(o.response.size) && o.response.size(),\n        time = o.response.responseTime,\n        requestCount = summary.run.stats.requests.total,\n        timings,\n        timingPhases;\n\n      // compute the response size total\n      size && (summary.run.transfers.responseTotal += size.body || 0 + size.headers || 0);\n\n      // if there are redirects, get timings for the last request sent\n      timings = _.last(_.get(o, 'history.execution.data'));\n      timings = timings && timings.timings;\n      timingPhases = timings && sdk.Response.timingPhases(timings);\n      (timingPhases || time) && _.forEach(['dns', 'firstByte', 'response'], value => {\n        var currentValue = value === 'response' ? time : timingPhases && timingPhases[value],\n          previousAverage = summary.run.timings[`${value}Average`],\n          previousVariance = Math.pow(summary.run.timings[`${value}Sd`], 2),\n          delta1 = currentValue - previousAverage,\n          delta2,\n          currentVariance;\n        if (!currentValue) {\n          return;\n        }\n\n        // compute average time for the given phase of request\n        summary.run.timings[`${value}Average`] = (previousAverage * (requestCount - 1) + currentValue) / requestCount;\n\n        // compute minimum time for the given phase of request\n        if (!summary.run.timings[`${value}Min`]) {\n          summary.run.timings[`${value}Min`] = currentValue;\n        } else {\n          summary.run.timings[`${value}Min`] = Math.min(summary.run.timings[`${value}Min`], currentValue);\n        }\n\n        // compute maximum time the given phase of request\n        summary.run.timings[`${value}Max`] = Math.max(summary.run.timings[`${value}Max`], currentValue);\n\n        // compute standard deviation for the given phase of request\n        // refer Welford's online algorithm from\n        // https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance\n        delta2 = currentValue - summary.run.timings[`${value}Average`];\n        currentVariance = (previousVariance * (requestCount - 1) + delta1 * delta2) / requestCount;\n        summary.run.timings[`${value}Sd`] = Math.sqrt(currentVariance);\n      });\n    });\n  },\n  attachFailureTrackers(summary, emitter) {\n    var eventsToTrack = ['beforeIteration', 'iteration', 'beforeItem', 'item', 'beforeScript', 'script', 'beforePrerequest', 'prerequest', 'beforeRequest', 'request', 'beforeTest', 'test', 'beforeAssertion', 'assertion'];\n\n    // accumulate failures of all events\n    // NOTE that surrogate events (which throw duplicate arguments) are not recorded\n    _.forEach(eventsToTrack, function (event) {\n      // push failures sent from \"before\" events\n      emitter.on(event, function (err, o) {\n        if (!err) {\n          return;\n        }\n        var item = o && o.item,\n          source = event;\n\n        // in case of user script error, point to the line and column of the script and its type\n        if (event === 'script') {\n          o.event && (source = o.event.listen + '-script');\n          if (err.stacktrace && err.stacktrace[0] && err.stacktrace[0].lineNumber) {\n            source += ':' + (err.stacktrace[0].lineNumber - 2);\n            err.stacktrace[0].columnNumber && (source += ':' + err.stacktrace[0].columnNumber);\n          }\n        }\n        // assertion errors need to know which assertion in the test was this\n        else if (event === 'assertion') {\n          _.has(err, 'index') && (source += ':' + err.index);\n          source += ' in test-script';\n        }\n\n        // if this is a plain error, convert it to serialised error\n        if (err.stack && !err.stacktrace) {\n          err = new SerialiseError(err, true);\n        }\n        summary.run.failures.push({\n          error: err,\n          at: source,\n          source: item || undefined,\n          parent: item && item.__parent && item.__parent.__parent || undefined,\n          cursor: o.cursor || {}\n        });\n      });\n    });\n  }\n});\nmodule.exports = RunSummary;","map":{"version":3,"names":["_","require","sdk","SerialiseError","RunSummary","emitter","options","summary","assign","collection","get","environment","globals","run","stats","iterations","items","scripts","prerequests","requests","tests","assertions","testScripts","prerequestScripts","timings","responseAverage","responseMin","responseMax","responseSd","dnsAverage","dnsMin","dnsMax","dnsSd","firstByteAverage","firstByteMin","firstByteMax","firstByteSd","executions","transfers","responseTotal","failures","error","attachTimingTrackers","attachStatisticTrackers","attachRequestTracker","attachFailureTrackers","attachReportingTrackers","cache","on","err","o","cursor","ref","assignIn","item","execution","push","request","response","id","requestError","undefined","eventName","event","listen","assertion","skipped","started","Date","now","completed","forEach","tracker","name","slice","total","pending","failed","camelCase","size","isFunction","time","responseTime","requestCount","timingPhases","body","headers","last","Response","value","currentValue","previousAverage","previousVariance","Math","pow","delta1","delta2","currentVariance","min","max","sqrt","eventsToTrack","source","stacktrace","lineNumber","columnNumber","has","index","stack","at","parent","__parent","module","exports"],"sources":["/Users/Qusai.Qishta/node_modules/newman/lib/run/summary.js"],"sourcesContent":["var _ = require('lodash'),\n    sdk = require('postman-collection'),\n    SerialiseError = require('serialised-error'),\n    RunSummary;\n\n/**\n * Creates and returns a RunSummary instance for the current collection run.\n *\n * @constructor\n * @param {EventEmitter} emitter - An EventEmitter instance with event handler attachments to add run information to.\n * @param {Object} options - A set of run summary creation options.\n */\nRunSummary = function RunSummary (emitter, options) {\n    // keep a copy of this instance since, we need to refer to this from various events\n    var summary = this;\n\n    // and store the trackers and failures in the summary object itself\n    _.assign(summary, /** @lends RunSummary.prototype */ {\n        /**\n         * The collection that is being executed.\n         *\n         * @type {Collection}\n         */\n        collection: _.get(options, 'collection'),\n\n        /**\n         * The environment that is being used during the run\n         *\n         * @type {VariableScope}\n         *\n         */\n        environment: _.get(options, 'environment'),\n\n        /**\n         * Global variables being used during the run\n         *\n         * @type {VariableScope}\n         */\n        globals: _.get(options, 'globals'),\n\n        /**\n         * Holds information related to the run.\n         */\n        run: {\n            /**\n             * Holds the statistics of the run. Each property in it is the item being tracked and has three numeric\n             * properties - total, failed, pending\n             *\n             * @type {Object.<Object>}\n             */\n            stats: {\n                iterations: {},\n                items: {},\n                scripts: {},\n                prerequests: {},\n                requests: {},\n                tests: {},\n                assertions: {},\n                testScripts: {},\n                prerequestScripts: {}\n            },\n\n            /**\n             * Stores all generic timing information\n             *\n             * @type {Object}\n             */\n            timings: {\n                /**\n                 * The average response time of the run\n                 *\n                 * @type {number}\n                 */\n                responseAverage: 0,\n\n                /**\n                 * The miminum response time of the run\n                 *\n                 * @type {number}\n                 */\n                responseMin: 0,\n\n                /**\n                 * The maximum response time of the run\n                 *\n                 * @type {number}\n                 */\n                responseMax: 0,\n\n                /**\n                 * Standard deviation of response time of the run\n                 *\n                 * @type {number}\n                 */\n                responseSd: 0,\n\n                /**\n                 * The average DNS lookup time of the run\n                 *\n                 * @type {number}\n                 */\n                dnsAverage: 0,\n\n                /**\n                 * The minimum DNS lookup time of the run\n                 *\n                 * @type {number}\n                 */\n                dnsMin: 0,\n\n                /**\n                 * The maximum DNS lookup time of the run\n                 *\n                 * @type {number}\n                 */\n                dnsMax: 0,\n\n                /**\n                 * Standard deviation of DNS lookup time of the run\n                 *\n                 * @type {number}\n                 */\n                dnsSd: 0,\n\n                /**\n                 * The average first byte time of the run\n                 *\n                 * @type {number}\n                 */\n                firstByteAverage: 0,\n\n                /**\n                 * The minimum first byte time of the run\n                 *\n                 * @type {number}\n                 */\n                firstByteMin: 0,\n\n                /**\n                 * The maximum first byte time of the run\n                 *\n                 * @type {number}\n                 */\n                firstByteMax: 0,\n\n                /**\n                 * Standard deviation of first byte time of the run\n                 *\n                 * @type {number}\n                 */\n                firstByteSd: 0\n            },\n\n            /**\n             * Stores detailed information about the order of execution, request, response and assertions\n             *\n             * @type {Array<Object>}\n             */\n            executions: [],\n\n            /**\n             * Stores information on data transfer made during the collection\n             *\n             * @type {Object}\n             */\n            transfers: {\n                /**\n                 * The total data received as response to every request\n                 *\n                 * @type {number}\n                 */\n                responseTotal: 0\n            },\n\n            /**\n             * An array of all errors encountered during the run\n             *\n             * @type {Array.<Error>}\n             */\n            failures: [],\n\n            /**\n             * This stores any fatal error during the run that caused the run to abort prematurely.\n             *\n             * @type {Error}\n             */\n            error: null\n        }\n    });\n\n    // track run timings (start and end)\n    RunSummary.attachTimingTrackers(this, emitter);\n\n    // accumulate statistics on all event\n    // for all types of events track the counters for the event and its corresponding \"before\" counterpart\n    RunSummary.attachStatisticTrackers(this, emitter);\n\n    // accumulate statistics on requests - such as size and time\n    RunSummary.attachRequestTracker(this, emitter);\n\n    // accumulate errors (failures) from all events\n    RunSummary.attachFailureTrackers(this, emitter);\n\n    // accumulate all execution specific data in collection\n    RunSummary.attachReportingTrackers(this, emitter);\n};\n\n_.assign(RunSummary, {\n    attachReportingTrackers (summary, emitter) {\n        var cache = {},\n            executions = summary.run.executions;\n\n        emitter.on('beforeItem', function (err, o) {\n            if (err || !_.get(o, 'cursor.ref')) { return; }\n\n            cache[o.cursor.ref] = _.assignIn(cache[o.cursor.ref] || {}, {\n                cursor: o.cursor,\n                item: o.item\n            });\n        });\n\n        // save all responses in executions array\n        emitter.on('request', function (err, o) {\n            if (!_.get(o, 'cursor.ref')) { return; }\n\n            var execution = cache[o.cursor.ref] = (cache[o.cursor.ref] || {});\n\n            executions.push(_.assignIn(execution, {\n                cursor: o.cursor,\n                request: o.request,\n                response: o.response,\n                id: _.get(o, 'item.id')\n            }, err && {\n                requestError: err || undefined\n            }));\n        });\n\n        // save all script execution errors in each execution\n        emitter.on('script', function (err, o) {\n            if (!_.get(o, 'cursor.ref')) { return; }\n\n            var execution = cache[o.cursor.ref] = (cache[o.cursor.ref] || {}),\n                eventName = o && o.event && (o.event.listen + 'Script');\n\n            // store the script error corresponding to the script event name\n            err && (execution && eventName) && (execution[eventName] || (execution[eventName] = [])).push({\n                error: err\n            });\n        });\n\n        // save all assertions in each execution\n        emitter.on('assertion', function (err, o) {\n            if (!_.get(o, 'cursor.ref')) { return; }\n\n            var execution = cache[o.cursor.ref] = (cache[o.cursor.ref] || {});\n\n            if (!execution) { return; }\n\n            (execution.assertions || (execution.assertions = [])).push({\n                assertion: o.assertion,\n                skipped: o.skipped,\n                error: err || undefined\n            });\n        });\n    },\n\n    attachTimingTrackers (summary, emitter) {\n        // mark the point when the run started\n        // also mark the point when run completed and also store error if needed\n        emitter.on('start', function () { summary.run.timings.started = Date.now(); });\n        emitter.on('beforeDone', function () {\n            summary.run.timings.completed = Date.now();\n        });\n        emitter.on('done', function (err) {\n            err && (summary.error = err);\n        });\n    },\n    attachStatisticTrackers (summary, emitter) {\n        // accumulate statistics on all event\n        // for all types of events track the counters for the event and its corresponding \"before\" counterpart\n        _.forEach(summary.run.stats, function (tracker, name) {\n            // the actual event names are singular than their plural trackers, so we make the name singular\n            name = name.slice(0, -1); // remove last character\n\n            // populate initial values of trackers\n            _.assign(tracker, { total: 0, pending: 0, failed: 0 });\n\n            // Set up common listeners for a set of events, which tracks how many times they were executed and records\n            // the ones which had an error passed as first argument\n            emitter.on(_.camelCase('before-' + name), function () {\n                tracker.pending += 1;\n            });\n\n            emitter.on(name, function (err) {\n                // check pending so that, it does not negate for items that do not have a `before` counterpart\n                tracker.pending && (tracker.pending -= 1);\n                err && (tracker.failed += 1);\n                tracker.total += 1;\n            });\n        });\n    },\n\n    attachRequestTracker (summary, emitter) {\n        // accumulate statistics on requests\n        emitter.on('request', function (err, o) {\n            if (err || !(o && o.response)) { return; }\n\n            var size = _.isFunction(o.response.size) && o.response.size(),\n                time = o.response.responseTime,\n                requestCount = summary.run.stats.requests.total,\n                timings,\n                timingPhases;\n\n            // compute the response size total\n            size && (summary.run.transfers.responseTotal += (size.body || 0 + size.headers || 0));\n\n            // if there are redirects, get timings for the last request sent\n            timings = _.last(_.get(o, 'history.execution.data'));\n            timings = timings && timings.timings;\n            timingPhases = timings && sdk.Response.timingPhases(timings);\n\n            (timingPhases || time) && _.forEach([\n                'dns',\n                'firstByte',\n                'response'\n            ], (value) => {\n                var currentValue = (value === 'response') ? time : (timingPhases && timingPhases[value]),\n                    previousAverage = summary.run.timings[`${value}Average`],\n                    previousVariance = Math.pow(summary.run.timings[`${value}Sd`], 2),\n                    delta1 = currentValue - previousAverage,\n                    delta2,\n                    currentVariance;\n\n                if (!currentValue) { return; }\n\n                // compute average time for the given phase of request\n                summary.run.timings[`${value}Average`] =\n                    (previousAverage * (requestCount - 1) + currentValue) / requestCount;\n\n                // compute minimum time for the given phase of request\n                if (!summary.run.timings[`${value}Min`]) {\n                    summary.run.timings[`${value}Min`] = currentValue;\n                }\n                else {\n                    summary.run.timings[`${value}Min`] =\n                        Math.min(summary.run.timings[`${value}Min`], currentValue);\n                }\n\n                // compute maximum time the given phase of request\n                summary.run.timings[`${value}Max`] = Math.max(summary.run.timings[`${value}Max`], currentValue);\n\n                // compute standard deviation for the given phase of request\n                // refer Welford's online algorithm from\n                // https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance\n                delta2 = currentValue - summary.run.timings[`${value}Average`];\n                currentVariance = (previousVariance * (requestCount - 1) + (delta1 * delta2)) / requestCount;\n                summary.run.timings[`${value}Sd`] = Math.sqrt(currentVariance);\n            });\n        });\n    },\n\n    attachFailureTrackers (summary, emitter) {\n        var eventsToTrack = ['beforeIteration', 'iteration', 'beforeItem', 'item', 'beforeScript', 'script',\n            'beforePrerequest', 'prerequest', 'beforeRequest', 'request', 'beforeTest', 'test', 'beforeAssertion',\n            'assertion'];\n\n        // accumulate failures of all events\n        // NOTE that surrogate events (which throw duplicate arguments) are not recorded\n        _.forEach(eventsToTrack, function (event) {\n            // push failures sent from \"before\" events\n            emitter.on(event, function (err, o) {\n                if (!err) { return; }\n\n                var item = o && o.item,\n                    source = event;\n\n                // in case of user script error, point to the line and column of the script and its type\n                if (event === 'script') {\n                    o.event && (source = o.event.listen + '-script');\n                    if (err.stacktrace && err.stacktrace[0] && err.stacktrace[0].lineNumber) {\n                        source += (':' + (err.stacktrace[0].lineNumber - 2));\n                        err.stacktrace[0].columnNumber && (source += (':' + err.stacktrace[0].columnNumber));\n                    }\n                }\n                // assertion errors need to know which assertion in the test was this\n                else if (event === 'assertion') {\n                    _.has(err, 'index') && (source += (':' + err.index));\n                    source += ' in test-script';\n                }\n\n                // if this is a plain error, convert it to serialised error\n                if (err.stack && !err.stacktrace) {\n                    err = new SerialiseError(err, true);\n                }\n\n                summary.run.failures.push({\n                    error: err,\n                    at: source,\n                    source: item || undefined,\n                    parent: item && item.__parent && item.__parent.__parent || undefined,\n                    cursor: o.cursor || {}\n                });\n            });\n        });\n    }\n});\n\nmodule.exports = RunSummary;\n"],"mappings":"AAAA,IAAIA,CAAC,GAAGC,OAAO,CAAC,QAAQ,CAAC;EACrBC,GAAG,GAAGD,OAAO,CAAC,oBAAoB,CAAC;EACnCE,cAAc,GAAGF,OAAO,CAAC,kBAAkB,CAAC;EAC5CG,UAAU;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,UAAU,GAAG,SAASA,UAAU,CAAEC,OAAO,EAAEC,OAAO,EAAE;EAChD;EACA,IAAIC,OAAO,GAAG,IAAI;;EAElB;EACAP,CAAC,CAACQ,MAAM,CAACD,OAAO,EAAE,kCAAmC;IACjD;AACR;AACA;AACA;AACA;IACQE,UAAU,EAAET,CAAC,CAACU,GAAG,CAACJ,OAAO,EAAE,YAAY,CAAC;IAExC;AACR;AACA;AACA;AACA;AACA;IACQK,WAAW,EAAEX,CAAC,CAACU,GAAG,CAACJ,OAAO,EAAE,aAAa,CAAC;IAE1C;AACR;AACA;AACA;AACA;IACQM,OAAO,EAAEZ,CAAC,CAACU,GAAG,CAACJ,OAAO,EAAE,SAAS,CAAC;IAElC;AACR;AACA;IACQO,GAAG,EAAE;MACD;AACZ;AACA;AACA;AACA;AACA;MACYC,KAAK,EAAE;QACHC,UAAU,EAAE,CAAC,CAAC;QACdC,KAAK,EAAE,CAAC,CAAC;QACTC,OAAO,EAAE,CAAC,CAAC;QACXC,WAAW,EAAE,CAAC,CAAC;QACfC,QAAQ,EAAE,CAAC,CAAC;QACZC,KAAK,EAAE,CAAC,CAAC;QACTC,UAAU,EAAE,CAAC,CAAC;QACdC,WAAW,EAAE,CAAC,CAAC;QACfC,iBAAiB,EAAE,CAAC;MACxB,CAAC;MAED;AACZ;AACA;AACA;AACA;MACYC,OAAO,EAAE;QACL;AAChB;AACA;AACA;AACA;QACgBC,eAAe,EAAE,CAAC;QAElB;AAChB;AACA;AACA;AACA;QACgBC,WAAW,EAAE,CAAC;QAEd;AAChB;AACA;AACA;AACA;QACgBC,WAAW,EAAE,CAAC;QAEd;AAChB;AACA;AACA;AACA;QACgBC,UAAU,EAAE,CAAC;QAEb;AAChB;AACA;AACA;AACA;QACgBC,UAAU,EAAE,CAAC;QAEb;AAChB;AACA;AACA;AACA;QACgBC,MAAM,EAAE,CAAC;QAET;AAChB;AACA;AACA;AACA;QACgBC,MAAM,EAAE,CAAC;QAET;AAChB;AACA;AACA;AACA;QACgBC,KAAK,EAAE,CAAC;QAER;AAChB;AACA;AACA;AACA;QACgBC,gBAAgB,EAAE,CAAC;QAEnB;AAChB;AACA;AACA;AACA;QACgBC,YAAY,EAAE,CAAC;QAEf;AAChB;AACA;AACA;AACA;QACgBC,YAAY,EAAE,CAAC;QAEf;AAChB;AACA;AACA;AACA;QACgBC,WAAW,EAAE;MACjB,CAAC;MAED;AACZ;AACA;AACA;AACA;MACYC,UAAU,EAAE,EAAE;MAEd;AACZ;AACA;AACA;AACA;MACYC,SAAS,EAAE;QACP;AAChB;AACA;AACA;AACA;QACgBC,aAAa,EAAE;MACnB,CAAC;MAED;AACZ;AACA;AACA;AACA;MACYC,QAAQ,EAAE,EAAE;MAEZ;AACZ;AACA;AACA;AACA;MACYC,KAAK,EAAE;IACX;EACJ,CAAC,CAAC;;EAEF;EACArC,UAAU,CAACsC,oBAAoB,CAAC,IAAI,EAAErC,OAAO,CAAC;;EAE9C;EACA;EACAD,UAAU,CAACuC,uBAAuB,CAAC,IAAI,EAAEtC,OAAO,CAAC;;EAEjD;EACAD,UAAU,CAACwC,oBAAoB,CAAC,IAAI,EAAEvC,OAAO,CAAC;;EAE9C;EACAD,UAAU,CAACyC,qBAAqB,CAAC,IAAI,EAAExC,OAAO,CAAC;;EAE/C;EACAD,UAAU,CAAC0C,uBAAuB,CAAC,IAAI,EAAEzC,OAAO,CAAC;AACrD,CAAC;AAEDL,CAAC,CAACQ,MAAM,CAACJ,UAAU,EAAE;EACjB0C,uBAAuB,CAAEvC,OAAO,EAAEF,OAAO,EAAE;IACvC,IAAI0C,KAAK,GAAG,CAAC,CAAC;MACVV,UAAU,GAAG9B,OAAO,CAACM,GAAG,CAACwB,UAAU;IAEvChC,OAAO,CAAC2C,EAAE,CAAC,YAAY,EAAE,UAAUC,GAAG,EAAEC,CAAC,EAAE;MACvC,IAAID,GAAG,IAAI,CAACjD,CAAC,CAACU,GAAG,CAACwC,CAAC,EAAE,YAAY,CAAC,EAAE;QAAE;MAAQ;MAE9CH,KAAK,CAACG,CAAC,CAACC,MAAM,CAACC,GAAG,CAAC,GAAGpD,CAAC,CAACqD,QAAQ,CAACN,KAAK,CAACG,CAAC,CAACC,MAAM,CAACC,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE;QACxDD,MAAM,EAAED,CAAC,CAACC,MAAM;QAChBG,IAAI,EAAEJ,CAAC,CAACI;MACZ,CAAC,CAAC;IACN,CAAC,CAAC;;IAEF;IACAjD,OAAO,CAAC2C,EAAE,CAAC,SAAS,EAAE,UAAUC,GAAG,EAAEC,CAAC,EAAE;MACpC,IAAI,CAAClD,CAAC,CAACU,GAAG,CAACwC,CAAC,EAAE,YAAY,CAAC,EAAE;QAAE;MAAQ;MAEvC,IAAIK,SAAS,GAAGR,KAAK,CAACG,CAAC,CAACC,MAAM,CAACC,GAAG,CAAC,GAAIL,KAAK,CAACG,CAAC,CAACC,MAAM,CAACC,GAAG,CAAC,IAAI,CAAC,CAAE;MAEjEf,UAAU,CAACmB,IAAI,CAACxD,CAAC,CAACqD,QAAQ,CAACE,SAAS,EAAE;QAClCJ,MAAM,EAAED,CAAC,CAACC,MAAM;QAChBM,OAAO,EAAEP,CAAC,CAACO,OAAO;QAClBC,QAAQ,EAAER,CAAC,CAACQ,QAAQ;QACpBC,EAAE,EAAE3D,CAAC,CAACU,GAAG,CAACwC,CAAC,EAAE,SAAS;MAC1B,CAAC,EAAED,GAAG,IAAI;QACNW,YAAY,EAAEX,GAAG,IAAIY;MACzB,CAAC,CAAC,CAAC;IACP,CAAC,CAAC;;IAEF;IACAxD,OAAO,CAAC2C,EAAE,CAAC,QAAQ,EAAE,UAAUC,GAAG,EAAEC,CAAC,EAAE;MACnC,IAAI,CAAClD,CAAC,CAACU,GAAG,CAACwC,CAAC,EAAE,YAAY,CAAC,EAAE;QAAE;MAAQ;MAEvC,IAAIK,SAAS,GAAGR,KAAK,CAACG,CAAC,CAACC,MAAM,CAACC,GAAG,CAAC,GAAIL,KAAK,CAACG,CAAC,CAACC,MAAM,CAACC,GAAG,CAAC,IAAI,CAAC,CAAE;QAC7DU,SAAS,GAAGZ,CAAC,IAAIA,CAAC,CAACa,KAAK,IAAKb,CAAC,CAACa,KAAK,CAACC,MAAM,GAAG,QAAS;;MAE3D;MACAf,GAAG,IAAKM,SAAS,IAAIO,SAAU,IAAI,CAACP,SAAS,CAACO,SAAS,CAAC,KAAKP,SAAS,CAACO,SAAS,CAAC,GAAG,EAAE,CAAC,EAAEN,IAAI,CAAC;QAC1Ff,KAAK,EAAEQ;MACX,CAAC,CAAC;IACN,CAAC,CAAC;;IAEF;IACA5C,OAAO,CAAC2C,EAAE,CAAC,WAAW,EAAE,UAAUC,GAAG,EAAEC,CAAC,EAAE;MACtC,IAAI,CAAClD,CAAC,CAACU,GAAG,CAACwC,CAAC,EAAE,YAAY,CAAC,EAAE;QAAE;MAAQ;MAEvC,IAAIK,SAAS,GAAGR,KAAK,CAACG,CAAC,CAACC,MAAM,CAACC,GAAG,CAAC,GAAIL,KAAK,CAACG,CAAC,CAACC,MAAM,CAACC,GAAG,CAAC,IAAI,CAAC,CAAE;MAEjE,IAAI,CAACG,SAAS,EAAE;QAAE;MAAQ;MAE1B,CAACA,SAAS,CAAClC,UAAU,KAAKkC,SAAS,CAAClC,UAAU,GAAG,EAAE,CAAC,EAAEmC,IAAI,CAAC;QACvDS,SAAS,EAAEf,CAAC,CAACe,SAAS;QACtBC,OAAO,EAAEhB,CAAC,CAACgB,OAAO;QAClBzB,KAAK,EAAEQ,GAAG,IAAIY;MAClB,CAAC,CAAC;IACN,CAAC,CAAC;EACN,CAAC;EAEDnB,oBAAoB,CAAEnC,OAAO,EAAEF,OAAO,EAAE;IACpC;IACA;IACAA,OAAO,CAAC2C,EAAE,CAAC,OAAO,EAAE,YAAY;MAAEzC,OAAO,CAACM,GAAG,CAACW,OAAO,CAAC2C,OAAO,GAAGC,IAAI,CAACC,GAAG,EAAE;IAAE,CAAC,CAAC;IAC9EhE,OAAO,CAAC2C,EAAE,CAAC,YAAY,EAAE,YAAY;MACjCzC,OAAO,CAACM,GAAG,CAACW,OAAO,CAAC8C,SAAS,GAAGF,IAAI,CAACC,GAAG,EAAE;IAC9C,CAAC,CAAC;IACFhE,OAAO,CAAC2C,EAAE,CAAC,MAAM,EAAE,UAAUC,GAAG,EAAE;MAC9BA,GAAG,KAAK1C,OAAO,CAACkC,KAAK,GAAGQ,GAAG,CAAC;IAChC,CAAC,CAAC;EACN,CAAC;EACDN,uBAAuB,CAAEpC,OAAO,EAAEF,OAAO,EAAE;IACvC;IACA;IACAL,CAAC,CAACuE,OAAO,CAAChE,OAAO,CAACM,GAAG,CAACC,KAAK,EAAE,UAAU0D,OAAO,EAAEC,IAAI,EAAE;MAClD;MACAA,IAAI,GAAGA,IAAI,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;;MAE1B;MACA1E,CAAC,CAACQ,MAAM,CAACgE,OAAO,EAAE;QAAEG,KAAK,EAAE,CAAC;QAAEC,OAAO,EAAE,CAAC;QAAEC,MAAM,EAAE;MAAE,CAAC,CAAC;;MAEtD;MACA;MACAxE,OAAO,CAAC2C,EAAE,CAAChD,CAAC,CAAC8E,SAAS,CAAC,SAAS,GAAGL,IAAI,CAAC,EAAE,YAAY;QAClDD,OAAO,CAACI,OAAO,IAAI,CAAC;MACxB,CAAC,CAAC;MAEFvE,OAAO,CAAC2C,EAAE,CAACyB,IAAI,EAAE,UAAUxB,GAAG,EAAE;QAC5B;QACAuB,OAAO,CAACI,OAAO,KAAKJ,OAAO,CAACI,OAAO,IAAI,CAAC,CAAC;QACzC3B,GAAG,KAAKuB,OAAO,CAACK,MAAM,IAAI,CAAC,CAAC;QAC5BL,OAAO,CAACG,KAAK,IAAI,CAAC;MACtB,CAAC,CAAC;IACN,CAAC,CAAC;EACN,CAAC;EAED/B,oBAAoB,CAAErC,OAAO,EAAEF,OAAO,EAAE;IACpC;IACAA,OAAO,CAAC2C,EAAE,CAAC,SAAS,EAAE,UAAUC,GAAG,EAAEC,CAAC,EAAE;MACpC,IAAID,GAAG,IAAI,EAAEC,CAAC,IAAIA,CAAC,CAACQ,QAAQ,CAAC,EAAE;QAAE;MAAQ;MAEzC,IAAIqB,IAAI,GAAG/E,CAAC,CAACgF,UAAU,CAAC9B,CAAC,CAACQ,QAAQ,CAACqB,IAAI,CAAC,IAAI7B,CAAC,CAACQ,QAAQ,CAACqB,IAAI,EAAE;QACzDE,IAAI,GAAG/B,CAAC,CAACQ,QAAQ,CAACwB,YAAY;QAC9BC,YAAY,GAAG5E,OAAO,CAACM,GAAG,CAACC,KAAK,CAACK,QAAQ,CAACwD,KAAK;QAC/CnD,OAAO;QACP4D,YAAY;;MAEhB;MACAL,IAAI,KAAKxE,OAAO,CAACM,GAAG,CAACyB,SAAS,CAACC,aAAa,IAAKwC,IAAI,CAACM,IAAI,IAAI,CAAC,GAAGN,IAAI,CAACO,OAAO,IAAI,CAAE,CAAC;;MAErF;MACA9D,OAAO,GAAGxB,CAAC,CAACuF,IAAI,CAACvF,CAAC,CAACU,GAAG,CAACwC,CAAC,EAAE,wBAAwB,CAAC,CAAC;MACpD1B,OAAO,GAAGA,OAAO,IAAIA,OAAO,CAACA,OAAO;MACpC4D,YAAY,GAAG5D,OAAO,IAAItB,GAAG,CAACsF,QAAQ,CAACJ,YAAY,CAAC5D,OAAO,CAAC;MAE5D,CAAC4D,YAAY,IAAIH,IAAI,KAAKjF,CAAC,CAACuE,OAAO,CAAC,CAChC,KAAK,EACL,WAAW,EACX,UAAU,CACb,EAAGkB,KAAK,IAAK;QACV,IAAIC,YAAY,GAAID,KAAK,KAAK,UAAU,GAAIR,IAAI,GAAIG,YAAY,IAAIA,YAAY,CAACK,KAAK,CAAE;UACpFE,eAAe,GAAGpF,OAAO,CAACM,GAAG,CAACW,OAAO,CAAE,GAAEiE,KAAM,SAAQ,CAAC;UACxDG,gBAAgB,GAAGC,IAAI,CAACC,GAAG,CAACvF,OAAO,CAACM,GAAG,CAACW,OAAO,CAAE,GAAEiE,KAAM,IAAG,CAAC,EAAE,CAAC,CAAC;UACjEM,MAAM,GAAGL,YAAY,GAAGC,eAAe;UACvCK,MAAM;UACNC,eAAe;QAEnB,IAAI,CAACP,YAAY,EAAE;UAAE;QAAQ;;QAE7B;QACAnF,OAAO,CAACM,GAAG,CAACW,OAAO,CAAE,GAAEiE,KAAM,SAAQ,CAAC,GAClC,CAACE,eAAe,IAAIR,YAAY,GAAG,CAAC,CAAC,GAAGO,YAAY,IAAIP,YAAY;;QAExE;QACA,IAAI,CAAC5E,OAAO,CAACM,GAAG,CAACW,OAAO,CAAE,GAAEiE,KAAM,KAAI,CAAC,EAAE;UACrClF,OAAO,CAACM,GAAG,CAACW,OAAO,CAAE,GAAEiE,KAAM,KAAI,CAAC,GAAGC,YAAY;QACrD,CAAC,MACI;UACDnF,OAAO,CAACM,GAAG,CAACW,OAAO,CAAE,GAAEiE,KAAM,KAAI,CAAC,GAC9BI,IAAI,CAACK,GAAG,CAAC3F,OAAO,CAACM,GAAG,CAACW,OAAO,CAAE,GAAEiE,KAAM,KAAI,CAAC,EAAEC,YAAY,CAAC;QAClE;;QAEA;QACAnF,OAAO,CAACM,GAAG,CAACW,OAAO,CAAE,GAAEiE,KAAM,KAAI,CAAC,GAAGI,IAAI,CAACM,GAAG,CAAC5F,OAAO,CAACM,GAAG,CAACW,OAAO,CAAE,GAAEiE,KAAM,KAAI,CAAC,EAAEC,YAAY,CAAC;;QAE/F;QACA;QACA;QACAM,MAAM,GAAGN,YAAY,GAAGnF,OAAO,CAACM,GAAG,CAACW,OAAO,CAAE,GAAEiE,KAAM,SAAQ,CAAC;QAC9DQ,eAAe,GAAG,CAACL,gBAAgB,IAAIT,YAAY,GAAG,CAAC,CAAC,GAAIY,MAAM,GAAGC,MAAO,IAAIb,YAAY;QAC5F5E,OAAO,CAACM,GAAG,CAACW,OAAO,CAAE,GAAEiE,KAAM,IAAG,CAAC,GAAGI,IAAI,CAACO,IAAI,CAACH,eAAe,CAAC;MAClE,CAAC,CAAC;IACN,CAAC,CAAC;EACN,CAAC;EAEDpD,qBAAqB,CAAEtC,OAAO,EAAEF,OAAO,EAAE;IACrC,IAAIgG,aAAa,GAAG,CAAC,iBAAiB,EAAE,WAAW,EAAE,YAAY,EAAE,MAAM,EAAE,cAAc,EAAE,QAAQ,EAC/F,kBAAkB,EAAE,YAAY,EAAE,eAAe,EAAE,SAAS,EAAE,YAAY,EAAE,MAAM,EAAE,iBAAiB,EACrG,WAAW,CAAC;;IAEhB;IACA;IACArG,CAAC,CAACuE,OAAO,CAAC8B,aAAa,EAAE,UAAUtC,KAAK,EAAE;MACtC;MACA1D,OAAO,CAAC2C,EAAE,CAACe,KAAK,EAAE,UAAUd,GAAG,EAAEC,CAAC,EAAE;QAChC,IAAI,CAACD,GAAG,EAAE;UAAE;QAAQ;QAEpB,IAAIK,IAAI,GAAGJ,CAAC,IAAIA,CAAC,CAACI,IAAI;UAClBgD,MAAM,GAAGvC,KAAK;;QAElB;QACA,IAAIA,KAAK,KAAK,QAAQ,EAAE;UACpBb,CAAC,CAACa,KAAK,KAAKuC,MAAM,GAAGpD,CAAC,CAACa,KAAK,CAACC,MAAM,GAAG,SAAS,CAAC;UAChD,IAAIf,GAAG,CAACsD,UAAU,IAAItD,GAAG,CAACsD,UAAU,CAAC,CAAC,CAAC,IAAItD,GAAG,CAACsD,UAAU,CAAC,CAAC,CAAC,CAACC,UAAU,EAAE;YACrEF,MAAM,IAAK,GAAG,IAAIrD,GAAG,CAACsD,UAAU,CAAC,CAAC,CAAC,CAACC,UAAU,GAAG,CAAC,CAAE;YACpDvD,GAAG,CAACsD,UAAU,CAAC,CAAC,CAAC,CAACE,YAAY,KAAKH,MAAM,IAAK,GAAG,GAAGrD,GAAG,CAACsD,UAAU,CAAC,CAAC,CAAC,CAACE,YAAa,CAAC;UACxF;QACJ;QACA;QAAA,KACK,IAAI1C,KAAK,KAAK,WAAW,EAAE;UAC5B/D,CAAC,CAAC0G,GAAG,CAACzD,GAAG,EAAE,OAAO,CAAC,KAAKqD,MAAM,IAAK,GAAG,GAAGrD,GAAG,CAAC0D,KAAM,CAAC;UACpDL,MAAM,IAAI,iBAAiB;QAC/B;;QAEA;QACA,IAAIrD,GAAG,CAAC2D,KAAK,IAAI,CAAC3D,GAAG,CAACsD,UAAU,EAAE;UAC9BtD,GAAG,GAAG,IAAI9C,cAAc,CAAC8C,GAAG,EAAE,IAAI,CAAC;QACvC;QAEA1C,OAAO,CAACM,GAAG,CAAC2B,QAAQ,CAACgB,IAAI,CAAC;UACtBf,KAAK,EAAEQ,GAAG;UACV4D,EAAE,EAAEP,MAAM;UACVA,MAAM,EAAEhD,IAAI,IAAIO,SAAS;UACzBiD,MAAM,EAAExD,IAAI,IAAIA,IAAI,CAACyD,QAAQ,IAAIzD,IAAI,CAACyD,QAAQ,CAACA,QAAQ,IAAIlD,SAAS;UACpEV,MAAM,EAAED,CAAC,CAACC,MAAM,IAAI,CAAC;QACzB,CAAC,CAAC;MACN,CAAC,CAAC;IACN,CAAC,CAAC;EACN;AACJ,CAAC,CAAC;AAEF6D,MAAM,CAACC,OAAO,GAAG7G,UAAU"},"metadata":{},"sourceType":"script"}