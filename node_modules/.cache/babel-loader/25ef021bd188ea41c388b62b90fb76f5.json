{"ast":null,"code":"var _ = require('../util').lodash,\n  url_parse = require('postman-url-encoder/parser').parse,\n  PropertyBase = require('./property-base').PropertyBase,\n  QueryParam = require('./query-param').QueryParam,\n  PropertyList = require('./property-list').PropertyList,\n  VariableList = require('./variable-list').VariableList,\n  E = '',\n  STRING = 'string',\n  FUNCTION = 'function',\n  PROTOCOL_HTTPS = 'https',\n  PROTOCOL_HTTP = 'http',\n  HTTPS_PORT = '443',\n  HTTP_PORT = '80',\n  PATH_SEPARATOR = '/',\n  PATH_VARIABLE_IDENTIFIER = ':',\n  PORT_SEPARATOR = ':',\n  DOMAIN_SEPARATOR = '.',\n  PROTOCOL_SEPARATOR = '://',\n  AUTH_SEPARATOR = ':',\n  AUTH_CREDENTIALS_SEPARATOR = '@',\n  QUERY_SEPARATOR = '?',\n  SEARCH_SEPARATOR = '#',\n  DEFAULT_PROTOCOL = PROTOCOL_HTTP + PROTOCOL_SEPARATOR,\n  MATCH_1 = '$1',\n  regexes = {\n    trimPath: /^\\/((.+))$/,\n    splitDomain: /\\.(?![^{]*\\}{2})/g\n  },\n  Url;\n_.inherit(\n/**\n * Defines a URL.\n *\n * @constructor\n * @extends {PropertyBase}\n * @param {Object|String} options -\n */\nUrl = function PostmanUrl(options) {\n  // this constructor is intended to inherit and as such the super constructor is required to be executed\n  Url.super_.apply(this, arguments);\n\n  // create the url properties\n  this.update(options);\n}, PropertyBase);\n_.assign(Url.prototype, /** @lends Url.prototype */{\n  /**\n   * Set a URL.\n   *\n   * @draft\n   * @param {String|Object} url -\n   */\n  update(url) {\n    !url && (url = E);\n    var parsedUrl = _.isString(url) ? Url.parse(url) : url,\n      auth = parsedUrl.auth,\n      protocol = parsedUrl.protocol,\n      port = parsedUrl.port,\n      path = parsedUrl.path,\n      hash = parsedUrl.hash,\n      host = parsedUrl.host,\n      query = parsedUrl.query,\n      variable = parsedUrl.variable;\n\n    // convert object based query string to array\n    // @todo: create a key value parser\n    if (query) {\n      if (_.isString(query)) {\n        query = QueryParam.parse(query);\n      }\n      if (!_.isArray(query) && _.keys(query).length) {\n        query = _.map(_.keys(query), function (key) {\n          return {\n            key: key,\n            value: query[key]\n          };\n        });\n      }\n    }\n\n    // backward compatibility with path variables being storing thins with `id`\n    if (_.isArray(variable)) {\n      variable = _.map(variable, function (v) {\n        _.isObject(v) && (v.key = v.key || v.id); // @todo Remove once path variables are deprecated\n\n        return v;\n      });\n    }\n\n    // expand string path name\n    if (_.isString(path)) {\n      path && (path = path.replace(regexes.trimPath, MATCH_1)); // remove leading slash for valid path\n      // if path is blank string, we set it to undefined, if '/' then single blank string array\n      path = path ? path === PATH_SEPARATOR ? [E] : path.split(PATH_SEPARATOR) : undefined;\n    }\n\n    // expand host string\n    _.isString(host) && (host = host.split(regexes.splitDomain));\n    _.assign(this, /** @lends Url.prototype */{\n      /**\n       * @type {{ user: String, password: String }}\n       */\n      auth: auth,\n      /**\n       * @type {String}\n       */\n      protocol: protocol,\n      /**\n       * @type {String}\n       */\n      port: port,\n      /**\n       * @type {Array<String>}\n       */\n      path: path,\n      /**\n       * @type {String}\n       */\n      hash: hash,\n      /**\n       * @type {Array<String>}\n       */\n      host: host,\n      /**\n       * @type {PropertyList<QueryParam>}\n       *\n       * @todo consider setting this as undefined in v4 otherwise it's\n       * difficult to detect URL like `localhost/?`.\n       * currently it's replying upon a single member with empty key.\n       */\n      query: new PropertyList(QueryParam, this, query || []),\n      /**\n       * @type {VariableList}\n       */\n      variables: new VariableList(this, variable || [])\n    });\n  },\n  /**\n   * Add query parameters to the URL.\n   *\n   * @param {Object|String} params Key value pairs to add to the URL.\n   */\n  addQueryParams(params) {\n    params = _.isString(params) ? QueryParam.parse(params) : params;\n    this.query.populate(params);\n  },\n  /**\n   * Removes query parameters from the URL.\n   *\n   * @param {Array<QueryParam>|Array<String>|String} params Params should be an array of strings, or an array of\n   * actual query parameters, or a string containing the parameter key.\n   * @note Input should *not* be a query string.\n   */\n  removeQueryParams(params) {\n    params = _.isArray(params) ? _.map(params, function (param) {\n      return param.key ? param.key : param;\n    }) : [params];\n    this.query.remove(function (param) {\n      return _.includes(params, param.key);\n    });\n  },\n  /**\n   * @private\n   * @deprecated discontinued in v4.0\n   */\n  getRaw() {\n    throw new Error('`Url#getRaw` has been discontinued, use `Url#toString` instead.');\n  },\n  /**\n   * Unparses a {PostmanUrl} into a string.\n   *\n   * @param {Boolean=} forceProtocol - Forces the URL to have a protocol\n   * @returns {String}\n   */\n  toString(forceProtocol) {\n    var rawUrl = E,\n      protocol = this.protocol,\n      queryString,\n      authString;\n    forceProtocol && !protocol && (protocol = DEFAULT_PROTOCOL);\n    if (protocol) {\n      rawUrl += _.endsWith(protocol, PROTOCOL_SEPARATOR) ? protocol : protocol + PROTOCOL_SEPARATOR;\n    }\n    if (this.auth) {\n      if (typeof this.auth.user === STRING) {\n        authString = this.auth.user;\n      }\n      if (typeof this.auth.password === STRING) {\n        !authString && (authString = E);\n        authString += AUTH_SEPARATOR + this.auth.password;\n      }\n      if (typeof authString === STRING) {\n        rawUrl += authString + AUTH_CREDENTIALS_SEPARATOR;\n      }\n    }\n    if (this.host) {\n      rawUrl += this.getHost();\n    }\n    if (typeof _.get(this.port, 'toString') === FUNCTION) {\n      rawUrl += PORT_SEPARATOR + this.port.toString();\n    }\n    if (this.path) {\n      rawUrl += this.getPath();\n    }\n    if (this.query && this.query.count()) {\n      queryString = this.getQueryString();\n\n      // either all the params are disabled or a single param is like { key: '' } (http://localhost?)\n      // in that case, query separator ? must be included in the raw URL.\n      // @todo return undefined or string from getQueryString method to distinguish\n      // no params vs empty param.\n      if (queryString === E) {\n        // check if there's any enabled param, if so, set queryString to empty string\n        // otherwise (all disabled), it will be set as undefined\n        queryString = this.query.find(function (param) {\n          return !(param && param.disabled);\n        }) && E;\n      }\n      if (typeof queryString === STRING) {\n        rawUrl += QUERY_SEPARATOR + queryString;\n      }\n    }\n    if (typeof this.hash === STRING) {\n      rawUrl += SEARCH_SEPARATOR + this.hash;\n    }\n    return rawUrl;\n  },\n  /**\n   * Returns the request path, with a leading '/'.\n   *\n   * @param {?Boolean=} [unresolved=false] -\n   * @returns {String}\n   */\n  getPath(unresolved) {\n    // for unresolved case, this is super simple as that is how raw data is stored\n    if (unresolved) {\n      return PATH_SEPARATOR + this.path.join(PATH_SEPARATOR);\n    }\n    var self = this,\n      segments;\n    segments = _.transform(this.path, function (res, segment) {\n      var variable;\n\n      // check if the segment has path variable prefix followed by the variable name.\n      if (_.startsWith(segment, PATH_VARIABLE_IDENTIFIER) && segment !== PATH_VARIABLE_IDENTIFIER) {\n        variable = self.variables.one(segment.slice(1)); // remove path variable prefix.\n      }\n\n      variable = variable && variable.valueOf && variable.valueOf();\n      res.push(_.isString(variable) ? variable : segment);\n    }, []);\n    return PATH_SEPARATOR + segments.join(PATH_SEPARATOR); // add leading slash\n  },\n\n  /**\n   * Returns the stringified query string for this URL.\n   *\n   * @returns {String}\n   */\n  getQueryString() {\n    if (!this.query.count()) {\n      return E;\n    }\n    return QueryParam.unparse(this.query.all());\n  },\n  /**\n   * Returns the complete path, including the query string.\n   *\n   * @returns {*|String}\n   * @example /something/postman?hi=notbye\n   */\n  getPathWithQuery() {\n    var path = this.getPath(),\n      queryString = this.getQueryString();\n\n    // Check if the queryString exists to figure out if we need to add a `?` alongside the queryString\n    if (queryString) {\n      path += QUERY_SEPARATOR + queryString;\n    }\n    return path;\n  },\n  /**\n   * Returns the host part of the URL\n   *\n   * @returns {String}\n   */\n  getHost() {\n    if (!this.host) {\n      return E;\n    }\n    return _.isArray(this.host) ? this.host.join(DOMAIN_SEPARATOR) : this.host.toString();\n  },\n  /**\n   * Returns the host *and* port (if any), separated by a \":\"\n   *\n   * @param {?Boolean} [forcePort=false] - forces the port to be added even for the protocol default ones (89, 443)\n   * @returns {String}\n   */\n  getRemote(forcePort) {\n    var host = this.getHost(),\n      port = this.port && this.port.toString();\n    if (forcePort && !port) {\n      // this (!port) works since it assumes port as a string\n      port = this.protocol && this.protocol === PROTOCOL_HTTPS ? HTTPS_PORT : HTTP_PORT;\n    }\n    return port ? host + PORT_SEPARATOR + port : host;\n  },\n  /**\n   * Returns a OAuth1.0-a compatible representation of the request URL, also called \"Base URL\".\n   * For details, http://oauth.net/core/1.0a/#anchor13\n   *\n   * todo: should we ignore the auth parameters of the URL or not? (the standard does not mention them)\n   * we currently are.\n   *\n   * @private\n   * @returns {String}\n   *\n   * @deprecated since v3.5 in favour of getBaseUrl\n   * @note not discontinue yet because it's used in Twitter APIs public collections\n   */\n  getOAuth1BaseUrl() {\n    var protocol = this.protocol || PROTOCOL_HTTP,\n      port = this.port ? this.port.toString() : undefined,\n      host = (port === HTTP_PORT || port === HTTPS_PORT || port === undefined) && this.host.join(DOMAIN_SEPARATOR) || this.host.join(DOMAIN_SEPARATOR) + PORT_SEPARATOR + port,\n      path = this.getPath();\n    protocol = _.endsWith(protocol, PROTOCOL_SEPARATOR) ? protocol : protocol + PROTOCOL_SEPARATOR;\n    return protocol.toLowerCase() + host.toLowerCase() + path;\n  }\n});\n_.assign(Url, /** @lends Url */{\n  /**\n   * Defines the name of this property for internal use.\n   *\n   * @private\n   * @readOnly\n   * @type {String}\n   */\n  _postman_propertyName: 'Url',\n  /**\n   * Parses a string to a PostmanUrl, decomposing the URL into it's constituent parts,\n   * such as path, host, port, etc.\n   *\n   * @param {String} url -\n   * @returns {Object}\n   */\n  parse: function (url) {\n    url = url_parse(url);\n    var pathVariables,\n      pathVariableKeys = {};\n    if (url.auth) {\n      url.auth = {\n        user: url.auth[0],\n        password: url.auth[1]\n      };\n    }\n    if (url.query) {\n      url.query = url.query.map(QueryParam.parseSingle);\n    }\n\n    // extract path variables\n    pathVariables = _.transform(url.path, function (res, segment) {\n      // check if the segment has path variable prefix followed by the variable name and\n      // the variable is not already added in the list.\n      if (_.startsWith(segment, PATH_VARIABLE_IDENTIFIER) && segment !== PATH_VARIABLE_IDENTIFIER && !pathVariableKeys[segment]) {\n        pathVariableKeys[segment] = true;\n        res.push({\n          key: segment.slice(1)\n        }); // remove path variable prefix.\n      }\n    }, []);\n    url.variable = pathVariables.length ? pathVariables : undefined;\n    return url;\n  },\n  /**\n   * Checks whether an object is a Url\n   *\n   * @param {*} obj -\n   * @returns {Boolean}\n   */\n  isUrl: function (obj) {\n    return Boolean(obj) && (obj instanceof Url || _.inSuperChain(obj.constructor, '_postman_propertyName', Url._postman_propertyName));\n  }\n});\nmodule.exports = {\n  Url\n};","map":{"version":3,"names":["_","require","lodash","url_parse","parse","PropertyBase","QueryParam","PropertyList","VariableList","E","STRING","FUNCTION","PROTOCOL_HTTPS","PROTOCOL_HTTP","HTTPS_PORT","HTTP_PORT","PATH_SEPARATOR","PATH_VARIABLE_IDENTIFIER","PORT_SEPARATOR","DOMAIN_SEPARATOR","PROTOCOL_SEPARATOR","AUTH_SEPARATOR","AUTH_CREDENTIALS_SEPARATOR","QUERY_SEPARATOR","SEARCH_SEPARATOR","DEFAULT_PROTOCOL","MATCH_1","regexes","trimPath","splitDomain","Url","inherit","PostmanUrl","options","super_","apply","arguments","update","assign","prototype","url","parsedUrl","isString","auth","protocol","port","path","hash","host","query","variable","isArray","keys","length","map","key","value","v","isObject","id","replace","split","undefined","variables","addQueryParams","params","populate","removeQueryParams","param","remove","includes","getRaw","Error","toString","forceProtocol","rawUrl","queryString","authString","endsWith","user","password","getHost","get","getPath","count","getQueryString","find","disabled","unresolved","join","self","segments","transform","res","segment","startsWith","one","slice","valueOf","push","unparse","all","getPathWithQuery","getRemote","forcePort","getOAuth1BaseUrl","toLowerCase","_postman_propertyName","pathVariables","pathVariableKeys","parseSingle","isUrl","obj","Boolean","inSuperChain","constructor","module","exports"],"sources":["/Users/Qusai.Qishta/node_modules/postman-collection/lib/collection/url.js"],"sourcesContent":["var _ = require('../util').lodash,\n    url_parse = require('postman-url-encoder/parser').parse,\n    PropertyBase = require('./property-base').PropertyBase,\n    QueryParam = require('./query-param').QueryParam,\n    PropertyList = require('./property-list').PropertyList,\n    VariableList = require('./variable-list').VariableList,\n\n    E = '',\n    STRING = 'string',\n    FUNCTION = 'function',\n    PROTOCOL_HTTPS = 'https',\n    PROTOCOL_HTTP = 'http',\n    HTTPS_PORT = '443',\n    HTTP_PORT = '80',\n    PATH_SEPARATOR = '/',\n    PATH_VARIABLE_IDENTIFIER = ':',\n    PORT_SEPARATOR = ':',\n    DOMAIN_SEPARATOR = '.',\n    PROTOCOL_SEPARATOR = '://',\n    AUTH_SEPARATOR = ':',\n    AUTH_CREDENTIALS_SEPARATOR = '@',\n    QUERY_SEPARATOR = '?',\n    SEARCH_SEPARATOR = '#',\n\n    DEFAULT_PROTOCOL = PROTOCOL_HTTP + PROTOCOL_SEPARATOR,\n\n    MATCH_1 = '$1',\n\n    regexes = {\n        trimPath: /^\\/((.+))$/,\n        splitDomain: /\\.(?![^{]*\\}{2})/g\n    },\n\n    Url;\n\n_.inherit((\n\n    /**\n     * Defines a URL.\n     *\n     * @constructor\n     * @extends {PropertyBase}\n     * @param {Object|String} options -\n     */\n    Url = function PostmanUrl (options) {\n        // this constructor is intended to inherit and as such the super constructor is required to be executed\n        Url.super_.apply(this, arguments);\n\n        // create the url properties\n        this.update(options);\n    }), PropertyBase);\n\n_.assign(Url.prototype, /** @lends Url.prototype */ {\n    /**\n     * Set a URL.\n     *\n     * @draft\n     * @param {String|Object} url -\n     */\n    update (url) {\n        !url && (url = E);\n        var parsedUrl = _.isString(url) ? Url.parse(url) : url,\n            auth = parsedUrl.auth,\n            protocol = parsedUrl.protocol,\n            port = parsedUrl.port,\n            path = parsedUrl.path,\n            hash = parsedUrl.hash,\n            host = parsedUrl.host,\n            query = parsedUrl.query,\n            variable = parsedUrl.variable;\n\n        // convert object based query string to array\n        // @todo: create a key value parser\n        if (query) {\n            if (_.isString(query)) {\n                query = QueryParam.parse(query);\n            }\n\n            if (!_.isArray(query) && _.keys(query).length) {\n                query = _.map(_.keys(query), function (key) {\n                    return {\n                        key: key,\n                        value: query[key]\n                    };\n                });\n            }\n        }\n\n        // backward compatibility with path variables being storing thins with `id`\n        if (_.isArray(variable)) {\n            variable = _.map(variable, function (v) {\n                _.isObject(v) && (v.key = v.key || v.id); // @todo Remove once path variables are deprecated\n\n                return v;\n            });\n        }\n\n        // expand string path name\n        if (_.isString(path)) {\n            path && (path = path.replace(regexes.trimPath, MATCH_1)); // remove leading slash for valid path\n            // if path is blank string, we set it to undefined, if '/' then single blank string array\n            path = path ? (path === PATH_SEPARATOR ? [E] : path.split(PATH_SEPARATOR)) : undefined;\n        }\n\n        // expand host string\n        _.isString(host) && (host = host.split(regexes.splitDomain));\n\n        _.assign(this, /** @lends Url.prototype */ {\n            /**\n             * @type {{ user: String, password: String }}\n             */\n            auth: auth,\n\n            /**\n             * @type {String}\n             */\n            protocol: protocol,\n\n            /**\n             * @type {String}\n             */\n            port: port,\n\n            /**\n             * @type {Array<String>}\n             */\n            path: path,\n\n            /**\n             * @type {String}\n             */\n            hash: hash,\n\n            /**\n             * @type {Array<String>}\n             */\n            host: host,\n\n            /**\n             * @type {PropertyList<QueryParam>}\n             *\n             * @todo consider setting this as undefined in v4 otherwise it's\n             * difficult to detect URL like `localhost/?`.\n             * currently it's replying upon a single member with empty key.\n             */\n            query: new PropertyList(QueryParam, this, query || []),\n\n            /**\n             * @type {VariableList}\n             */\n            variables: new VariableList(this, variable || [])\n        });\n    },\n\n    /**\n     * Add query parameters to the URL.\n     *\n     * @param {Object|String} params Key value pairs to add to the URL.\n     */\n    addQueryParams (params) {\n        params = _.isString(params) ? QueryParam.parse(params) : params;\n        this.query.populate(params);\n    },\n\n    /**\n     * Removes query parameters from the URL.\n     *\n     * @param {Array<QueryParam>|Array<String>|String} params Params should be an array of strings, or an array of\n     * actual query parameters, or a string containing the parameter key.\n     * @note Input should *not* be a query string.\n     */\n    removeQueryParams (params) {\n        params = _.isArray(params) ? _.map(params, function (param) {\n            return param.key ? param.key : param;\n        }) : [params];\n        this.query.remove(function (param) {\n            return _.includes(params, param.key);\n        });\n    },\n\n    /**\n     * @private\n     * @deprecated discontinued in v4.0\n     */\n    getRaw () {\n        throw new Error('`Url#getRaw` has been discontinued, use `Url#toString` instead.');\n    },\n\n    /**\n     * Unparses a {PostmanUrl} into a string.\n     *\n     * @param {Boolean=} forceProtocol - Forces the URL to have a protocol\n     * @returns {String}\n     */\n    toString (forceProtocol) {\n        var rawUrl = E,\n            protocol = this.protocol,\n            queryString,\n            authString;\n\n        forceProtocol && !protocol && (protocol = DEFAULT_PROTOCOL);\n\n        if (protocol) {\n            rawUrl += (_.endsWith(protocol, PROTOCOL_SEPARATOR) ? protocol : protocol + PROTOCOL_SEPARATOR);\n        }\n\n        if (this.auth) {\n            if (typeof this.auth.user === STRING) {\n                authString = this.auth.user;\n            }\n\n\n            if (typeof this.auth.password === STRING) {\n                !authString && (authString = E);\n                authString += AUTH_SEPARATOR + this.auth.password;\n            }\n\n            if (typeof authString === STRING) {\n                rawUrl += authString + AUTH_CREDENTIALS_SEPARATOR;\n            }\n        }\n\n        if (this.host) {\n            rawUrl += this.getHost();\n        }\n\n        if (typeof _.get(this.port, 'toString') === FUNCTION) {\n            rawUrl += PORT_SEPARATOR + this.port.toString();\n        }\n\n        if (this.path) {\n            rawUrl += this.getPath();\n        }\n\n        if (this.query && this.query.count()) {\n            queryString = this.getQueryString();\n\n            // either all the params are disabled or a single param is like { key: '' } (http://localhost?)\n            // in that case, query separator ? must be included in the raw URL.\n            // @todo return undefined or string from getQueryString method to distinguish\n            // no params vs empty param.\n            if (queryString === E) {\n                // check if there's any enabled param, if so, set queryString to empty string\n                // otherwise (all disabled), it will be set as undefined\n                queryString = this.query.find(function (param) { return !(param && param.disabled); }) && E;\n            }\n\n            if (typeof queryString === STRING) {\n                rawUrl += QUERY_SEPARATOR + queryString;\n            }\n        }\n\n        if (typeof this.hash === STRING) {\n            rawUrl += SEARCH_SEPARATOR + this.hash;\n        }\n\n        return rawUrl;\n    },\n\n    /**\n     * Returns the request path, with a leading '/'.\n     *\n     * @param {?Boolean=} [unresolved=false] -\n     * @returns {String}\n     */\n    getPath (unresolved) {\n        // for unresolved case, this is super simple as that is how raw data is stored\n        if (unresolved) {\n            return PATH_SEPARATOR + this.path.join(PATH_SEPARATOR);\n        }\n\n        var self = this,\n            segments;\n\n        segments = _.transform(this.path, function (res, segment) {\n            var variable;\n\n            // check if the segment has path variable prefix followed by the variable name.\n            if (_.startsWith(segment, PATH_VARIABLE_IDENTIFIER) && segment !== PATH_VARIABLE_IDENTIFIER) {\n                variable = self.variables.one(segment.slice(1)); // remove path variable prefix.\n            }\n\n            variable = variable && variable.valueOf && variable.valueOf();\n            res.push(_.isString(variable) ? variable : segment);\n        }, []);\n\n        return PATH_SEPARATOR + segments.join(PATH_SEPARATOR); // add leading slash\n    },\n\n    /**\n     * Returns the stringified query string for this URL.\n     *\n     * @returns {String}\n     */\n    getQueryString () {\n        if (!this.query.count()) {\n            return E;\n        }\n\n        return QueryParam.unparse(this.query.all());\n    },\n\n    /**\n     * Returns the complete path, including the query string.\n     *\n     * @returns {*|String}\n     * @example /something/postman?hi=notbye\n     */\n    getPathWithQuery () {\n        var path = this.getPath(),\n            queryString = this.getQueryString();\n\n        // Check if the queryString exists to figure out if we need to add a `?` alongside the queryString\n        if (queryString) {\n            path += (QUERY_SEPARATOR + queryString);\n        }\n\n        return path;\n    },\n\n    /**\n     * Returns the host part of the URL\n     *\n     * @returns {String}\n     */\n    getHost () {\n        if (!this.host) {\n            return E;\n        }\n\n        return _.isArray(this.host) ? this.host.join(DOMAIN_SEPARATOR) : this.host.toString();\n    },\n\n    /**\n     * Returns the host *and* port (if any), separated by a \":\"\n     *\n     * @param {?Boolean} [forcePort=false] - forces the port to be added even for the protocol default ones (89, 443)\n     * @returns {String}\n     */\n    getRemote (forcePort) {\n        var host = this.getHost(),\n            port = this.port && this.port.toString();\n\n        if (forcePort && !port) { // this (!port) works since it assumes port as a string\n            port = this.protocol && (this.protocol === PROTOCOL_HTTPS) ? HTTPS_PORT : HTTP_PORT;\n        }\n\n        return port ? (host + PORT_SEPARATOR + port) : host;\n    },\n\n    /**\n     * Returns a OAuth1.0-a compatible representation of the request URL, also called \"Base URL\".\n     * For details, http://oauth.net/core/1.0a/#anchor13\n     *\n     * todo: should we ignore the auth parameters of the URL or not? (the standard does not mention them)\n     * we currently are.\n     *\n     * @private\n     * @returns {String}\n     *\n     * @deprecated since v3.5 in favour of getBaseUrl\n     * @note not discontinue yet because it's used in Twitter APIs public collections\n     */\n    getOAuth1BaseUrl () {\n        var protocol = this.protocol || PROTOCOL_HTTP,\n            port = this.port ? this.port.toString() : undefined,\n            host = ((port === HTTP_PORT ||\n                port === HTTPS_PORT ||\n                port === undefined) && this.host.join(DOMAIN_SEPARATOR)) || (this.host.join(DOMAIN_SEPARATOR) +\n                    PORT_SEPARATOR + port),\n            path = this.getPath();\n\n        protocol = (_.endsWith(protocol, PROTOCOL_SEPARATOR) ? protocol : protocol + PROTOCOL_SEPARATOR);\n\n        return protocol.toLowerCase() + host.toLowerCase() + path;\n    }\n});\n\n_.assign(Url, /** @lends Url */ {\n\n    /**\n     * Defines the name of this property for internal use.\n     *\n     * @private\n     * @readOnly\n     * @type {String}\n     */\n    _postman_propertyName: 'Url',\n\n    /**\n     * Parses a string to a PostmanUrl, decomposing the URL into it's constituent parts,\n     * such as path, host, port, etc.\n     *\n     * @param {String} url -\n     * @returns {Object}\n     */\n    parse: function (url) {\n        url = url_parse(url);\n\n        var pathVariables,\n            pathVariableKeys = {};\n\n        if (url.auth) {\n            url.auth = {\n                user: url.auth[0],\n                password: url.auth[1]\n            };\n        }\n\n        if (url.query) {\n            url.query = url.query.map(QueryParam.parseSingle);\n        }\n\n        // extract path variables\n        pathVariables = _.transform(url.path, function (res, segment) {\n            // check if the segment has path variable prefix followed by the variable name and\n            // the variable is not already added in the list.\n            if (_.startsWith(segment, PATH_VARIABLE_IDENTIFIER) &&\n                segment !== PATH_VARIABLE_IDENTIFIER &&\n                !pathVariableKeys[segment]) {\n                pathVariableKeys[segment] = true;\n                res.push({ key: segment.slice(1) }); // remove path variable prefix.\n            }\n        }, []);\n        url.variable = pathVariables.length ? pathVariables : undefined;\n\n        return url;\n    },\n\n    /**\n     * Checks whether an object is a Url\n     *\n     * @param {*} obj -\n     * @returns {Boolean}\n     */\n    isUrl: function (obj) {\n        return Boolean(obj) && ((obj instanceof Url) ||\n            _.inSuperChain(obj.constructor, '_postman_propertyName', Url._postman_propertyName));\n    }\n});\n\nmodule.exports = {\n    Url\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}