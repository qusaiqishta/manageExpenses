{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\nvar _base = require('../base');\nvar _exception = require('../exception');\nvar _exception2 = _interopRequireDefault(_exception);\nvar _utils = require('../utils');\nvar _codeGen = require('./code-gen');\nvar _codeGen2 = _interopRequireDefault(_codeGen);\nfunction Literal(value) {\n  this.value = value;\n}\nfunction JavaScriptCompiler() {}\nJavaScriptCompiler.prototype = {\n  // PUBLIC API: You can override these methods in a subclass to provide\n  // alternative compiled forms for name lookup and buffering semantics\n  nameLookup: function nameLookup(parent, name /*,  type */) {\n    return this.internalNameLookup(parent, name);\n  },\n  depthedLookup: function depthedLookup(name) {\n    return [this.aliasable('container.lookup'), '(depths, ', JSON.stringify(name), ')'];\n  },\n  compilerInfo: function compilerInfo() {\n    var revision = _base.COMPILER_REVISION,\n      versions = _base.REVISION_CHANGES[revision];\n    return [revision, versions];\n  },\n  appendToBuffer: function appendToBuffer(source, location, explicit) {\n    // Force a source as this simplifies the merge logic.\n    if (!_utils.isArray(source)) {\n      source = [source];\n    }\n    source = this.source.wrap(source, location);\n    if (this.environment.isSimple) {\n      return ['return ', source, ';'];\n    } else if (explicit) {\n      // This is a case where the buffer operation occurs as a child of another\n      // construct, generally braces. We have to explicitly output these buffer\n      // operations to ensure that the emitted code goes in the correct location.\n      return ['buffer += ', source, ';'];\n    } else {\n      source.appendToBuffer = true;\n      return source;\n    }\n  },\n  initializeBuffer: function initializeBuffer() {\n    return this.quotedString('');\n  },\n  // END PUBLIC API\n  internalNameLookup: function internalNameLookup(parent, name) {\n    this.lookupPropertyFunctionIsUsed = true;\n    return ['lookupProperty(', parent, ',', JSON.stringify(name), ')'];\n  },\n  lookupPropertyFunctionIsUsed: false,\n  compile: function compile(environment, options, context, asObject) {\n    this.environment = environment;\n    this.options = options;\n    this.stringParams = this.options.stringParams;\n    this.trackIds = this.options.trackIds;\n    this.precompile = !asObject;\n    this.name = this.environment.name;\n    this.isChild = !!context;\n    this.context = context || {\n      decorators: [],\n      programs: [],\n      environments: []\n    };\n    this.preamble();\n    this.stackSlot = 0;\n    this.stackVars = [];\n    this.aliases = {};\n    this.registers = {\n      list: []\n    };\n    this.hashes = [];\n    this.compileStack = [];\n    this.inlineStack = [];\n    this.blockParams = [];\n    this.compileChildren(environment, options);\n    this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;\n    this.useBlockParams = this.useBlockParams || environment.useBlockParams;\n    var opcodes = environment.opcodes,\n      opcode = undefined,\n      firstLoc = undefined,\n      i = undefined,\n      l = undefined;\n    for (i = 0, l = opcodes.length; i < l; i++) {\n      opcode = opcodes[i];\n      this.source.currentLocation = opcode.loc;\n      firstLoc = firstLoc || opcode.loc;\n      this[opcode.opcode].apply(this, opcode.args);\n    }\n\n    // Flush any trailing content that might be pending.\n    this.source.currentLocation = firstLoc;\n    this.pushSource('');\n\n    /* istanbul ignore next */\n    if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {\n      throw new _exception2['default']('Compile completed with content left on stack');\n    }\n    if (!this.decorators.isEmpty()) {\n      this.useDecorators = true;\n      this.decorators.prepend(['var decorators = container.decorators, ', this.lookupPropertyFunctionVarDeclaration(), ';\\n']);\n      this.decorators.push('return fn;');\n      if (asObject) {\n        this.decorators = Function.apply(this, ['fn', 'props', 'container', 'depth0', 'data', 'blockParams', 'depths', this.decorators.merge()]);\n      } else {\n        this.decorators.prepend('function(fn, props, container, depth0, data, blockParams, depths) {\\n');\n        this.decorators.push('}\\n');\n        this.decorators = this.decorators.merge();\n      }\n    } else {\n      this.decorators = undefined;\n    }\n    var fn = this.createFunctionContext(asObject);\n    if (!this.isChild) {\n      var ret = {\n        compiler: this.compilerInfo(),\n        main: fn\n      };\n      if (this.decorators) {\n        ret.main_d = this.decorators; // eslint-disable-line camelcase\n        ret.useDecorators = true;\n      }\n      var _context = this.context;\n      var programs = _context.programs;\n      var decorators = _context.decorators;\n      for (i = 0, l = programs.length; i < l; i++) {\n        if (programs[i]) {\n          ret[i] = programs[i];\n          if (decorators[i]) {\n            ret[i + '_d'] = decorators[i];\n            ret.useDecorators = true;\n          }\n        }\n      }\n      if (this.environment.usePartial) {\n        ret.usePartial = true;\n      }\n      if (this.options.data) {\n        ret.useData = true;\n      }\n      if (this.useDepths) {\n        ret.useDepths = true;\n      }\n      if (this.useBlockParams) {\n        ret.useBlockParams = true;\n      }\n      if (this.options.compat) {\n        ret.compat = true;\n      }\n      if (!asObject) {\n        ret.compiler = JSON.stringify(ret.compiler);\n        this.source.currentLocation = {\n          start: {\n            line: 1,\n            column: 0\n          }\n        };\n        ret = this.objectLiteral(ret);\n        if (options.srcName) {\n          ret = ret.toStringWithSourceMap({\n            file: options.destName\n          });\n          ret.map = ret.map && ret.map.toString();\n        } else {\n          ret = ret.toString();\n        }\n      } else {\n        ret.compilerOptions = this.options;\n      }\n      return ret;\n    } else {\n      return fn;\n    }\n  },\n  preamble: function preamble() {\n    // track the last context pushed into place to allow skipping the\n    // getContext opcode when it would be a noop\n    this.lastContext = 0;\n    this.source = new _codeGen2['default'](this.options.srcName);\n    this.decorators = new _codeGen2['default'](this.options.srcName);\n  },\n  createFunctionContext: function createFunctionContext(asObject) {\n    // istanbul ignore next\n\n    var _this = this;\n    var varDeclarations = '';\n    var locals = this.stackVars.concat(this.registers.list);\n    if (locals.length > 0) {\n      varDeclarations += ', ' + locals.join(', ');\n    }\n\n    // Generate minimizer alias mappings\n    //\n    // When using true SourceNodes, this will update all references to the given alias\n    // as the source nodes are reused in situ. For the non-source node compilation mode,\n    // aliases will not be used, but this case is already being run on the client and\n    // we aren't concern about minimizing the template size.\n    var aliasCount = 0;\n    Object.keys(this.aliases).forEach(function (alias) {\n      var node = _this.aliases[alias];\n      if (node.children && node.referenceCount > 1) {\n        varDeclarations += ', alias' + ++aliasCount + '=' + alias;\n        node.children[0] = 'alias' + aliasCount;\n      }\n    });\n    if (this.lookupPropertyFunctionIsUsed) {\n      varDeclarations += ', ' + this.lookupPropertyFunctionVarDeclaration();\n    }\n    var params = ['container', 'depth0', 'helpers', 'partials', 'data'];\n    if (this.useBlockParams || this.useDepths) {\n      params.push('blockParams');\n    }\n    if (this.useDepths) {\n      params.push('depths');\n    }\n\n    // Perform a second pass over the output to merge content when possible\n    var source = this.mergeSource(varDeclarations);\n    if (asObject) {\n      params.push(source);\n      return Function.apply(this, params);\n    } else {\n      return this.source.wrap(['function(', params.join(','), ') {\\n  ', source, '}']);\n    }\n  },\n  mergeSource: function mergeSource(varDeclarations) {\n    var isSimple = this.environment.isSimple,\n      appendOnly = !this.forceBuffer,\n      appendFirst = undefined,\n      sourceSeen = undefined,\n      bufferStart = undefined,\n      bufferEnd = undefined;\n    this.source.each(function (line) {\n      if (line.appendToBuffer) {\n        if (bufferStart) {\n          line.prepend('  + ');\n        } else {\n          bufferStart = line;\n        }\n        bufferEnd = line;\n      } else {\n        if (bufferStart) {\n          if (!sourceSeen) {\n            appendFirst = true;\n          } else {\n            bufferStart.prepend('buffer += ');\n          }\n          bufferEnd.add(';');\n          bufferStart = bufferEnd = undefined;\n        }\n        sourceSeen = true;\n        if (!isSimple) {\n          appendOnly = false;\n        }\n      }\n    });\n    if (appendOnly) {\n      if (bufferStart) {\n        bufferStart.prepend('return ');\n        bufferEnd.add(';');\n      } else if (!sourceSeen) {\n        this.source.push('return \"\";');\n      }\n    } else {\n      varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());\n      if (bufferStart) {\n        bufferStart.prepend('return buffer + ');\n        bufferEnd.add(';');\n      } else {\n        this.source.push('return buffer;');\n      }\n    }\n    if (varDeclarations) {\n      this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\\n'));\n    }\n    return this.source.merge();\n  },\n  lookupPropertyFunctionVarDeclaration: function lookupPropertyFunctionVarDeclaration() {\n    return '\\n      lookupProperty = container.lookupProperty || function(parent, propertyName) {\\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\\n          return parent[propertyName];\\n        }\\n        return undefined\\n    }\\n    '.trim();\n  },\n  // [blockValue]\n  //\n  // On stack, before: hash, inverse, program, value\n  // On stack, after: return value of blockHelperMissing\n  //\n  // The purpose of this opcode is to take a block of the form\n  // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and\n  // replace it on the stack with the result of properly\n  // invoking blockHelperMissing.\n  blockValue: function blockValue(name) {\n    var blockHelperMissing = this.aliasable('container.hooks.blockHelperMissing'),\n      params = [this.contextName(0)];\n    this.setupHelperArgs(name, 0, params);\n    var blockName = this.popStack();\n    params.splice(1, 0, blockName);\n    this.push(this.source.functionCall(blockHelperMissing, 'call', params));\n  },\n  // [ambiguousBlockValue]\n  //\n  // On stack, before: hash, inverse, program, value\n  // Compiler value, before: lastHelper=value of last found helper, if any\n  // On stack, after, if no lastHelper: same as [blockValue]\n  // On stack, after, if lastHelper: value\n  ambiguousBlockValue: function ambiguousBlockValue() {\n    // We're being a bit cheeky and reusing the options value from the prior exec\n    var blockHelperMissing = this.aliasable('container.hooks.blockHelperMissing'),\n      params = [this.contextName(0)];\n    this.setupHelperArgs('', 0, params, true);\n    this.flushInline();\n    var current = this.topStack();\n    params.splice(1, 0, current);\n    this.pushSource(['if (!', this.lastHelper, ') { ', current, ' = ', this.source.functionCall(blockHelperMissing, 'call', params), '}']);\n  },\n  // [appendContent]\n  //\n  // On stack, before: ...\n  // On stack, after: ...\n  //\n  // Appends the string value of `content` to the current buffer\n  appendContent: function appendContent(content) {\n    if (this.pendingContent) {\n      content = this.pendingContent + content;\n    } else {\n      this.pendingLocation = this.source.currentLocation;\n    }\n    this.pendingContent = content;\n  },\n  // [append]\n  //\n  // On stack, before: value, ...\n  // On stack, after: ...\n  //\n  // Coerces `value` to a String and appends it to the current buffer.\n  //\n  // If `value` is truthy, or 0, it is coerced into a string and appended\n  // Otherwise, the empty string is appended\n  append: function append() {\n    if (this.isInline()) {\n      this.replaceStack(function (current) {\n        return [' != null ? ', current, ' : \"\"'];\n      });\n      this.pushSource(this.appendToBuffer(this.popStack()));\n    } else {\n      var local = this.popStack();\n      this.pushSource(['if (', local, ' != null) { ', this.appendToBuffer(local, undefined, true), ' }']);\n      if (this.environment.isSimple) {\n        this.pushSource(['else { ', this.appendToBuffer(\"''\", undefined, true), ' }']);\n      }\n    }\n  },\n  // [appendEscaped]\n  //\n  // On stack, before: value, ...\n  // On stack, after: ...\n  //\n  // Escape `value` and append it to the buffer\n  appendEscaped: function appendEscaped() {\n    this.pushSource(this.appendToBuffer([this.aliasable('container.escapeExpression'), '(', this.popStack(), ')']));\n  },\n  // [getContext]\n  //\n  // On stack, before: ...\n  // On stack, after: ...\n  // Compiler value, after: lastContext=depth\n  //\n  // Set the value of the `lastContext` compiler value to the depth\n  getContext: function getContext(depth) {\n    this.lastContext = depth;\n  },\n  // [pushContext]\n  //\n  // On stack, before: ...\n  // On stack, after: currentContext, ...\n  //\n  // Pushes the value of the current context onto the stack.\n  pushContext: function pushContext() {\n    this.pushStackLiteral(this.contextName(this.lastContext));\n  },\n  // [lookupOnContext]\n  //\n  // On stack, before: ...\n  // On stack, after: currentContext[name], ...\n  //\n  // Looks up the value of `name` on the current context and pushes\n  // it onto the stack.\n  lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {\n    var i = 0;\n    if (!scoped && this.options.compat && !this.lastContext) {\n      // The depthed query is expected to handle the undefined logic for the root level that\n      // is implemented below, so we evaluate that directly in compat mode\n      this.push(this.depthedLookup(parts[i++]));\n    } else {\n      this.pushContext();\n    }\n    this.resolvePath('context', parts, i, falsy, strict);\n  },\n  // [lookupBlockParam]\n  //\n  // On stack, before: ...\n  // On stack, after: blockParam[name], ...\n  //\n  // Looks up the value of `parts` on the given block param and pushes\n  // it onto the stack.\n  lookupBlockParam: function lookupBlockParam(blockParamId, parts) {\n    this.useBlockParams = true;\n    this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);\n    this.resolvePath('context', parts, 1);\n  },\n  // [lookupData]\n  //\n  // On stack, before: ...\n  // On stack, after: data, ...\n  //\n  // Push the data lookup operator\n  lookupData: function lookupData(depth, parts, strict) {\n    if (!depth) {\n      this.pushStackLiteral('data');\n    } else {\n      this.pushStackLiteral('container.data(data, ' + depth + ')');\n    }\n    this.resolvePath('data', parts, 0, true, strict);\n  },\n  resolvePath: function resolvePath(type, parts, i, falsy, strict) {\n    // istanbul ignore next\n\n    var _this2 = this;\n    if (this.options.strict || this.options.assumeObjects) {\n      this.push(strictLookup(this.options.strict && strict, this, parts, type));\n      return;\n    }\n    var len = parts.length;\n    for (; i < len; i++) {\n      /* eslint-disable no-loop-func */\n      this.replaceStack(function (current) {\n        var lookup = _this2.nameLookup(current, parts[i], type);\n        // We want to ensure that zero and false are handled properly if the context (falsy flag)\n        // needs to have the special handling for these values.\n        if (!falsy) {\n          return [' != null ? ', lookup, ' : ', current];\n        } else {\n          // Otherwise we can use generic falsy handling\n          return [' && ', lookup];\n        }\n      });\n      /* eslint-enable no-loop-func */\n    }\n  },\n\n  // [resolvePossibleLambda]\n  //\n  // On stack, before: value, ...\n  // On stack, after: resolved value, ...\n  //\n  // If the `value` is a lambda, replace it on the stack by\n  // the return value of the lambda\n  resolvePossibleLambda: function resolvePossibleLambda() {\n    this.push([this.aliasable('container.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);\n  },\n  // [pushStringParam]\n  //\n  // On stack, before: ...\n  // On stack, after: string, currentContext, ...\n  //\n  // This opcode is designed for use in string mode, which\n  // provides the string value of a parameter along with its\n  // depth rather than resolving it immediately.\n  pushStringParam: function pushStringParam(string, type) {\n    this.pushContext();\n    this.pushString(type);\n\n    // If it's a subexpression, the string result\n    // will be pushed after this opcode.\n    if (type !== 'SubExpression') {\n      if (typeof string === 'string') {\n        this.pushString(string);\n      } else {\n        this.pushStackLiteral(string);\n      }\n    }\n  },\n  emptyHash: function emptyHash(omitEmpty) {\n    if (this.trackIds) {\n      this.push('{}'); // hashIds\n    }\n\n    if (this.stringParams) {\n      this.push('{}'); // hashContexts\n      this.push('{}'); // hashTypes\n    }\n\n    this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');\n  },\n  pushHash: function pushHash() {\n    if (this.hash) {\n      this.hashes.push(this.hash);\n    }\n    this.hash = {\n      values: {},\n      types: [],\n      contexts: [],\n      ids: []\n    };\n  },\n  popHash: function popHash() {\n    var hash = this.hash;\n    this.hash = this.hashes.pop();\n    if (this.trackIds) {\n      this.push(this.objectLiteral(hash.ids));\n    }\n    if (this.stringParams) {\n      this.push(this.objectLiteral(hash.contexts));\n      this.push(this.objectLiteral(hash.types));\n    }\n    this.push(this.objectLiteral(hash.values));\n  },\n  // [pushString]\n  //\n  // On stack, before: ...\n  // On stack, after: quotedString(string), ...\n  //\n  // Push a quoted version of `string` onto the stack\n  pushString: function pushString(string) {\n    this.pushStackLiteral(this.quotedString(string));\n  },\n  // [pushLiteral]\n  //\n  // On stack, before: ...\n  // On stack, after: value, ...\n  //\n  // Pushes a value onto the stack. This operation prevents\n  // the compiler from creating a temporary variable to hold\n  // it.\n  pushLiteral: function pushLiteral(value) {\n    this.pushStackLiteral(value);\n  },\n  // [pushProgram]\n  //\n  // On stack, before: ...\n  // On stack, after: program(guid), ...\n  //\n  // Push a program expression onto the stack. This takes\n  // a compile-time guid and converts it into a runtime-accessible\n  // expression.\n  pushProgram: function pushProgram(guid) {\n    if (guid != null) {\n      this.pushStackLiteral(this.programExpression(guid));\n    } else {\n      this.pushStackLiteral(null);\n    }\n  },\n  // [registerDecorator]\n  //\n  // On stack, before: hash, program, params..., ...\n  // On stack, after: ...\n  //\n  // Pops off the decorator's parameters, invokes the decorator,\n  // and inserts the decorator into the decorators list.\n  registerDecorator: function registerDecorator(paramSize, name) {\n    var foundDecorator = this.nameLookup('decorators', name, 'decorator'),\n      options = this.setupHelperArgs(name, paramSize);\n    this.decorators.push(['fn = ', this.decorators.functionCall(foundDecorator, '', ['fn', 'props', 'container', options]), ' || fn;']);\n  },\n  // [invokeHelper]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of helper invocation\n  //\n  // Pops off the helper's parameters, invokes the helper,\n  // and pushes the helper's return value onto the stack.\n  //\n  // If the helper is not found, `helperMissing` is called.\n  invokeHelper: function invokeHelper(paramSize, name, isSimple) {\n    var nonHelper = this.popStack(),\n      helper = this.setupHelper(paramSize, name);\n    var possibleFunctionCalls = [];\n    if (isSimple) {\n      // direct call to helper\n      possibleFunctionCalls.push(helper.name);\n    }\n    // call a function from the input object\n    possibleFunctionCalls.push(nonHelper);\n    if (!this.options.strict) {\n      possibleFunctionCalls.push(this.aliasable('container.hooks.helperMissing'));\n    }\n    var functionLookupCode = ['(', this.itemsSeparatedBy(possibleFunctionCalls, '||'), ')'];\n    var functionCall = this.source.functionCall(functionLookupCode, 'call', helper.callParams);\n    this.push(functionCall);\n  },\n  itemsSeparatedBy: function itemsSeparatedBy(items, separator) {\n    var result = [];\n    result.push(items[0]);\n    for (var i = 1; i < items.length; i++) {\n      result.push(separator, items[i]);\n    }\n    return result;\n  },\n  // [invokeKnownHelper]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of helper invocation\n  //\n  // This operation is used when the helper is known to exist,\n  // so a `helperMissing` fallback is not required.\n  invokeKnownHelper: function invokeKnownHelper(paramSize, name) {\n    var helper = this.setupHelper(paramSize, name);\n    this.push(this.source.functionCall(helper.name, 'call', helper.callParams));\n  },\n  // [invokeAmbiguous]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of disambiguation\n  //\n  // This operation is used when an expression like `{{foo}}`\n  // is provided, but we don't know at compile-time whether it\n  // is a helper or a path.\n  //\n  // This operation emits more code than the other options,\n  // and can be avoided by passing the `knownHelpers` and\n  // `knownHelpersOnly` flags at compile-time.\n  invokeAmbiguous: function invokeAmbiguous(name, helperCall) {\n    this.useRegister('helper');\n    var nonHelper = this.popStack();\n    this.emptyHash();\n    var helper = this.setupHelper(0, name, helperCall);\n    var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');\n    var lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];\n    if (!this.options.strict) {\n      lookup[0] = '(helper = ';\n      lookup.push(' != null ? helper : ', this.aliasable('container.hooks.helperMissing'));\n    }\n    this.push(['(', lookup, helper.paramsInit ? ['),(', helper.paramsInit] : [], '),', '(typeof helper === ', this.aliasable('\"function\"'), ' ? ', this.source.functionCall('helper', 'call', helper.callParams), ' : helper))']);\n  },\n  // [invokePartial]\n  //\n  // On stack, before: context, ...\n  // On stack after: result of partial invocation\n  //\n  // This operation pops off a context, invokes a partial with that context,\n  // and pushes the result of the invocation back.\n  invokePartial: function invokePartial(isDynamic, name, indent) {\n    var params = [],\n      options = this.setupParams(name, 1, params);\n    if (isDynamic) {\n      name = this.popStack();\n      delete options.name;\n    }\n    if (indent) {\n      options.indent = JSON.stringify(indent);\n    }\n    options.helpers = 'helpers';\n    options.partials = 'partials';\n    options.decorators = 'container.decorators';\n    if (!isDynamic) {\n      params.unshift(this.nameLookup('partials', name, 'partial'));\n    } else {\n      params.unshift(name);\n    }\n    if (this.options.compat) {\n      options.depths = 'depths';\n    }\n    options = this.objectLiteral(options);\n    params.push(options);\n    this.push(this.source.functionCall('container.invokePartial', '', params));\n  },\n  // [assignToHash]\n  //\n  // On stack, before: value, ..., hash, ...\n  // On stack, after: ..., hash, ...\n  //\n  // Pops a value off the stack and assigns it to the current hash\n  assignToHash: function assignToHash(key) {\n    var value = this.popStack(),\n      context = undefined,\n      type = undefined,\n      id = undefined;\n    if (this.trackIds) {\n      id = this.popStack();\n    }\n    if (this.stringParams) {\n      type = this.popStack();\n      context = this.popStack();\n    }\n    var hash = this.hash;\n    if (context) {\n      hash.contexts[key] = context;\n    }\n    if (type) {\n      hash.types[key] = type;\n    }\n    if (id) {\n      hash.ids[key] = id;\n    }\n    hash.values[key] = value;\n  },\n  pushId: function pushId(type, name, child) {\n    if (type === 'BlockParam') {\n      this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));\n    } else if (type === 'PathExpression') {\n      this.pushString(name);\n    } else if (type === 'SubExpression') {\n      this.pushStackLiteral('true');\n    } else {\n      this.pushStackLiteral('null');\n    }\n  },\n  // HELPERS\n\n  compiler: JavaScriptCompiler,\n  compileChildren: function compileChildren(environment, options) {\n    var children = environment.children,\n      child = undefined,\n      compiler = undefined;\n    for (var i = 0, l = children.length; i < l; i++) {\n      child = children[i];\n      compiler = new this.compiler(); // eslint-disable-line new-cap\n\n      var existing = this.matchExistingProgram(child);\n      if (existing == null) {\n        this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children\n        var index = this.context.programs.length;\n        child.index = index;\n        child.name = 'program' + index;\n        this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);\n        this.context.decorators[index] = compiler.decorators;\n        this.context.environments[index] = child;\n        this.useDepths = this.useDepths || compiler.useDepths;\n        this.useBlockParams = this.useBlockParams || compiler.useBlockParams;\n        child.useDepths = this.useDepths;\n        child.useBlockParams = this.useBlockParams;\n      } else {\n        child.index = existing.index;\n        child.name = 'program' + existing.index;\n        this.useDepths = this.useDepths || existing.useDepths;\n        this.useBlockParams = this.useBlockParams || existing.useBlockParams;\n      }\n    }\n  },\n  matchExistingProgram: function matchExistingProgram(child) {\n    for (var i = 0, len = this.context.environments.length; i < len; i++) {\n      var environment = this.context.environments[i];\n      if (environment && environment.equals(child)) {\n        return environment;\n      }\n    }\n  },\n  programExpression: function programExpression(guid) {\n    var child = this.environment.children[guid],\n      programParams = [child.index, 'data', child.blockParams];\n    if (this.useBlockParams || this.useDepths) {\n      programParams.push('blockParams');\n    }\n    if (this.useDepths) {\n      programParams.push('depths');\n    }\n    return 'container.program(' + programParams.join(', ') + ')';\n  },\n  useRegister: function useRegister(name) {\n    if (!this.registers[name]) {\n      this.registers[name] = true;\n      this.registers.list.push(name);\n    }\n  },\n  push: function push(expr) {\n    if (!(expr instanceof Literal)) {\n      expr = this.source.wrap(expr);\n    }\n    this.inlineStack.push(expr);\n    return expr;\n  },\n  pushStackLiteral: function pushStackLiteral(item) {\n    this.push(new Literal(item));\n  },\n  pushSource: function pushSource(source) {\n    if (this.pendingContent) {\n      this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));\n      this.pendingContent = undefined;\n    }\n    if (source) {\n      this.source.push(source);\n    }\n  },\n  replaceStack: function replaceStack(callback) {\n    var prefix = ['('],\n      stack = undefined,\n      createdStack = undefined,\n      usedLiteral = undefined;\n\n    /* istanbul ignore next */\n    if (!this.isInline()) {\n      throw new _exception2['default']('replaceStack on non-inline');\n    }\n\n    // We want to merge the inline statement into the replacement statement via ','\n    var top = this.popStack(true);\n    if (top instanceof Literal) {\n      // Literals do not need to be inlined\n      stack = [top.value];\n      prefix = ['(', stack];\n      usedLiteral = true;\n    } else {\n      // Get or create the current stack name for use by the inline\n      createdStack = true;\n      var _name = this.incrStack();\n      prefix = ['((', this.push(_name), ' = ', top, ')'];\n      stack = this.topStack();\n    }\n    var item = callback.call(this, stack);\n    if (!usedLiteral) {\n      this.popStack();\n    }\n    if (createdStack) {\n      this.stackSlot--;\n    }\n    this.push(prefix.concat(item, ')'));\n  },\n  incrStack: function incrStack() {\n    this.stackSlot++;\n    if (this.stackSlot > this.stackVars.length) {\n      this.stackVars.push('stack' + this.stackSlot);\n    }\n    return this.topStackName();\n  },\n  topStackName: function topStackName() {\n    return 'stack' + this.stackSlot;\n  },\n  flushInline: function flushInline() {\n    var inlineStack = this.inlineStack;\n    this.inlineStack = [];\n    for (var i = 0, len = inlineStack.length; i < len; i++) {\n      var entry = inlineStack[i];\n      /* istanbul ignore if */\n      if (entry instanceof Literal) {\n        this.compileStack.push(entry);\n      } else {\n        var stack = this.incrStack();\n        this.pushSource([stack, ' = ', entry, ';']);\n        this.compileStack.push(stack);\n      }\n    }\n  },\n  isInline: function isInline() {\n    return this.inlineStack.length;\n  },\n  popStack: function popStack(wrapped) {\n    var inline = this.isInline(),\n      item = (inline ? this.inlineStack : this.compileStack).pop();\n    if (!wrapped && item instanceof Literal) {\n      return item.value;\n    } else {\n      if (!inline) {\n        /* istanbul ignore next */\n        if (!this.stackSlot) {\n          throw new _exception2['default']('Invalid stack pop');\n        }\n        this.stackSlot--;\n      }\n      return item;\n    }\n  },\n  topStack: function topStack() {\n    var stack = this.isInline() ? this.inlineStack : this.compileStack,\n      item = stack[stack.length - 1];\n\n    /* istanbul ignore if */\n    if (item instanceof Literal) {\n      return item.value;\n    } else {\n      return item;\n    }\n  },\n  contextName: function contextName(context) {\n    if (this.useDepths && context) {\n      return 'depths[' + context + ']';\n    } else {\n      return 'depth' + context;\n    }\n  },\n  quotedString: function quotedString(str) {\n    return this.source.quotedString(str);\n  },\n  objectLiteral: function objectLiteral(obj) {\n    return this.source.objectLiteral(obj);\n  },\n  aliasable: function aliasable(name) {\n    var ret = this.aliases[name];\n    if (ret) {\n      ret.referenceCount++;\n      return ret;\n    }\n    ret = this.aliases[name] = this.source.wrap(name);\n    ret.aliasable = true;\n    ret.referenceCount = 1;\n    return ret;\n  },\n  setupHelper: function setupHelper(paramSize, name, blockHelper) {\n    var params = [],\n      paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);\n    var foundHelper = this.nameLookup('helpers', name, 'helper'),\n      callContext = this.aliasable(this.contextName(0) + ' != null ? ' + this.contextName(0) + ' : (container.nullContext || {})');\n    return {\n      params: params,\n      paramsInit: paramsInit,\n      name: foundHelper,\n      callParams: [callContext].concat(params)\n    };\n  },\n  setupParams: function setupParams(helper, paramSize, params) {\n    var options = {},\n      contexts = [],\n      types = [],\n      ids = [],\n      objectArgs = !params,\n      param = undefined;\n    if (objectArgs) {\n      params = [];\n    }\n    options.name = this.quotedString(helper);\n    options.hash = this.popStack();\n    if (this.trackIds) {\n      options.hashIds = this.popStack();\n    }\n    if (this.stringParams) {\n      options.hashTypes = this.popStack();\n      options.hashContexts = this.popStack();\n    }\n    var inverse = this.popStack(),\n      program = this.popStack();\n\n    // Avoid setting fn and inverse if neither are set. This allows\n    // helpers to do a check for `if (options.fn)`\n    if (program || inverse) {\n      options.fn = program || 'container.noop';\n      options.inverse = inverse || 'container.noop';\n    }\n\n    // The parameters go on to the stack in order (making sure that they are evaluated in order)\n    // so we need to pop them off the stack in reverse order\n    var i = paramSize;\n    while (i--) {\n      param = this.popStack();\n      params[i] = param;\n      if (this.trackIds) {\n        ids[i] = this.popStack();\n      }\n      if (this.stringParams) {\n        types[i] = this.popStack();\n        contexts[i] = this.popStack();\n      }\n    }\n    if (objectArgs) {\n      options.args = this.source.generateArray(params);\n    }\n    if (this.trackIds) {\n      options.ids = this.source.generateArray(ids);\n    }\n    if (this.stringParams) {\n      options.types = this.source.generateArray(types);\n      options.contexts = this.source.generateArray(contexts);\n    }\n    if (this.options.data) {\n      options.data = 'data';\n    }\n    if (this.useBlockParams) {\n      options.blockParams = 'blockParams';\n    }\n    return options;\n  },\n  setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {\n    var options = this.setupParams(helper, paramSize, params);\n    options.loc = JSON.stringify(this.source.currentLocation);\n    options = this.objectLiteral(options);\n    if (useRegister) {\n      this.useRegister('options');\n      params.push('options');\n      return ['options=', options];\n    } else if (params) {\n      params.push(options);\n      return '';\n    } else {\n      return options;\n    }\n  }\n};\n(function () {\n  var reservedWords = ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');\n  var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};\n  for (var i = 0, l = reservedWords.length; i < l; i++) {\n    compilerWords[reservedWords[i]] = true;\n  }\n})();\n\n/**\n * @deprecated May be removed in the next major version\n */\nJavaScriptCompiler.isValidJavaScriptVariableName = function (name) {\n  return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);\n};\nfunction strictLookup(requireTerminal, compiler, parts, type) {\n  var stack = compiler.popStack(),\n    i = 0,\n    len = parts.length;\n  if (requireTerminal) {\n    len--;\n  }\n  for (; i < len; i++) {\n    stack = compiler.nameLookup(stack, parts[i], type);\n  }\n  if (requireTerminal) {\n    return [compiler.aliasable('container.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ', ', JSON.stringify(compiler.source.currentLocation), ' )'];\n  } else {\n    return stack;\n  }\n}\nexports['default'] = JavaScriptCompiler;\nmodule.exports = exports['default'];","map":{"version":3,"mappings":"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","names":["Literal","value","JavaScriptCompiler","prototype","nameLookup","parent","name","internalNameLookup","depthedLookup","aliasable","JSON","stringify","compilerInfo","revision","versions","_base","appendToBuffer","source","location","explicit","_utils","wrap","environment","isSimple","initializeBuffer","quotedString","lookupPropertyFunctionIsUsed","compile","options","context","asObject","stringParams","trackIds","precompile","isChild","decorators","programs","environments","preamble","stackSlot","stackVars","aliases","registers","list","hashes","compileStack","inlineStack","blockParams","compileChildren","useDepths","useDecorators","compat","useBlockParams","opcodes","opcode","firstLoc","i","l","length","currentLocation","loc","apply","args","pushSource","isEmpty","prepend","lookupPropertyFunctionVarDeclaration","push","Function","merge","undefined","fn","createFunctionContext","ret","compiler","main","main_d","usePartial","data","useData","start","line","column","objectLiteral","srcName","toStringWithSourceMap","file","destName","map","toString","compilerOptions","lastContext","varDeclarations","locals","concat","join","aliasCount","Object","keys","forEach","node","_this","alias","children","referenceCount","params","mergeSource","appendOnly","forceBuffer","appendFirst","sourceSeen","bufferStart","bufferEnd","each","add","substring","trim","blockValue","blockHelperMissing","contextName","setupHelperArgs","blockName","popStack","splice","functionCall","ambiguousBlockValue","flushInline","current","topStack","lastHelper","appendContent","content","pendingContent","pendingLocation","append","isInline","replaceStack","local","appendEscaped","getContext","depth","pushContext","pushStackLiteral","lookupOnContext","parts","falsy","strict","scoped","resolvePath","lookupBlockParam","blockParamId","lookupData","type","assumeObjects","strictLookup","len","lookup","_this2","resolvePossibleLambda","pushStringParam","string","pushString","emptyHash","omitEmpty","pushHash","hash","values","types","contexts","ids","popHash","pop","pushLiteral","pushProgram","guid","programExpression","registerDecorator","paramSize","foundDecorator","invokeHelper","nonHelper","helper","setupHelper","possibleFunctionCalls","functionLookupCode","itemsSeparatedBy","callParams","items","separator","result","invokeKnownHelper","invokeAmbiguous","helperCall","useRegister","helperName","paramsInit","invokePartial","isDynamic","indent","setupParams","helpers","partials","unshift","depths","assignToHash","key","id","pushId","child","existing","matchExistingProgram","index","equals","programParams","expr","item","callback","prefix","stack","createdStack","usedLiteral","top","_name","incrStack","call","topStackName","entry","wrapped","inline","str","obj","blockHelper","foundHelper","callContext","objectArgs","param","hashIds","hashTypes","hashContexts","inverse","program","generateArray","reservedWords","split","compilerWords","RESERVED_WORDS","isValidJavaScriptVariableName","test","requireTerminal"],"sources":["../../../../lib/handlebars/compiler/javascript-compiler.js"],"sourcesContent":["import { COMPILER_REVISION, REVISION_CHANGES } from '../base';\nimport Exception from '../exception';\nimport { isArray } from '../utils';\nimport CodeGen from './code-gen';\n\nfunction Literal(value) {\n  this.value = value;\n}\n\nfunction JavaScriptCompiler() {}\n\nJavaScriptCompiler.prototype = {\n  // PUBLIC API: You can override these methods in a subclass to provide\n  // alternative compiled forms for name lookup and buffering semantics\n  nameLookup: function(parent, name /*,  type */) {\n    return this.internalNameLookup(parent, name);\n  },\n  depthedLookup: function(name) {\n    return [\n      this.aliasable('container.lookup'),\n      '(depths, ',\n      JSON.stringify(name),\n      ')'\n    ];\n  },\n\n  compilerInfo: function() {\n    const revision = COMPILER_REVISION,\n      versions = REVISION_CHANGES[revision];\n    return [revision, versions];\n  },\n\n  appendToBuffer: function(source, location, explicit) {\n    // Force a source as this simplifies the merge logic.\n    if (!isArray(source)) {\n      source = [source];\n    }\n    source = this.source.wrap(source, location);\n\n    if (this.environment.isSimple) {\n      return ['return ', source, ';'];\n    } else if (explicit) {\n      // This is a case where the buffer operation occurs as a child of another\n      // construct, generally braces. We have to explicitly output these buffer\n      // operations to ensure that the emitted code goes in the correct location.\n      return ['buffer += ', source, ';'];\n    } else {\n      source.appendToBuffer = true;\n      return source;\n    }\n  },\n\n  initializeBuffer: function() {\n    return this.quotedString('');\n  },\n  // END PUBLIC API\n  internalNameLookup: function(parent, name) {\n    this.lookupPropertyFunctionIsUsed = true;\n    return ['lookupProperty(', parent, ',', JSON.stringify(name), ')'];\n  },\n\n  lookupPropertyFunctionIsUsed: false,\n\n  compile: function(environment, options, context, asObject) {\n    this.environment = environment;\n    this.options = options;\n    this.stringParams = this.options.stringParams;\n    this.trackIds = this.options.trackIds;\n    this.precompile = !asObject;\n\n    this.name = this.environment.name;\n    this.isChild = !!context;\n    this.context = context || {\n      decorators: [],\n      programs: [],\n      environments: []\n    };\n\n    this.preamble();\n\n    this.stackSlot = 0;\n    this.stackVars = [];\n    this.aliases = {};\n    this.registers = { list: [] };\n    this.hashes = [];\n    this.compileStack = [];\n    this.inlineStack = [];\n    this.blockParams = [];\n\n    this.compileChildren(environment, options);\n\n    this.useDepths =\n      this.useDepths ||\n      environment.useDepths ||\n      environment.useDecorators ||\n      this.options.compat;\n    this.useBlockParams = this.useBlockParams || environment.useBlockParams;\n\n    let opcodes = environment.opcodes,\n      opcode,\n      firstLoc,\n      i,\n      l;\n\n    for (i = 0, l = opcodes.length; i < l; i++) {\n      opcode = opcodes[i];\n\n      this.source.currentLocation = opcode.loc;\n      firstLoc = firstLoc || opcode.loc;\n      this[opcode.opcode].apply(this, opcode.args);\n    }\n\n    // Flush any trailing content that might be pending.\n    this.source.currentLocation = firstLoc;\n    this.pushSource('');\n\n    /* istanbul ignore next */\n    if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {\n      throw new Exception('Compile completed with content left on stack');\n    }\n\n    if (!this.decorators.isEmpty()) {\n      this.useDecorators = true;\n\n      this.decorators.prepend([\n        'var decorators = container.decorators, ',\n        this.lookupPropertyFunctionVarDeclaration(),\n        ';\\n'\n      ]);\n      this.decorators.push('return fn;');\n\n      if (asObject) {\n        this.decorators = Function.apply(this, [\n          'fn',\n          'props',\n          'container',\n          'depth0',\n          'data',\n          'blockParams',\n          'depths',\n          this.decorators.merge()\n        ]);\n      } else {\n        this.decorators.prepend(\n          'function(fn, props, container, depth0, data, blockParams, depths) {\\n'\n        );\n        this.decorators.push('}\\n');\n        this.decorators = this.decorators.merge();\n      }\n    } else {\n      this.decorators = undefined;\n    }\n\n    let fn = this.createFunctionContext(asObject);\n    if (!this.isChild) {\n      let ret = {\n        compiler: this.compilerInfo(),\n        main: fn\n      };\n\n      if (this.decorators) {\n        ret.main_d = this.decorators; // eslint-disable-line camelcase\n        ret.useDecorators = true;\n      }\n\n      let { programs, decorators } = this.context;\n      for (i = 0, l = programs.length; i < l; i++) {\n        if (programs[i]) {\n          ret[i] = programs[i];\n          if (decorators[i]) {\n            ret[i + '_d'] = decorators[i];\n            ret.useDecorators = true;\n          }\n        }\n      }\n\n      if (this.environment.usePartial) {\n        ret.usePartial = true;\n      }\n      if (this.options.data) {\n        ret.useData = true;\n      }\n      if (this.useDepths) {\n        ret.useDepths = true;\n      }\n      if (this.useBlockParams) {\n        ret.useBlockParams = true;\n      }\n      if (this.options.compat) {\n        ret.compat = true;\n      }\n\n      if (!asObject) {\n        ret.compiler = JSON.stringify(ret.compiler);\n\n        this.source.currentLocation = { start: { line: 1, column: 0 } };\n        ret = this.objectLiteral(ret);\n\n        if (options.srcName) {\n          ret = ret.toStringWithSourceMap({ file: options.destName });\n          ret.map = ret.map && ret.map.toString();\n        } else {\n          ret = ret.toString();\n        }\n      } else {\n        ret.compilerOptions = this.options;\n      }\n\n      return ret;\n    } else {\n      return fn;\n    }\n  },\n\n  preamble: function() {\n    // track the last context pushed into place to allow skipping the\n    // getContext opcode when it would be a noop\n    this.lastContext = 0;\n    this.source = new CodeGen(this.options.srcName);\n    this.decorators = new CodeGen(this.options.srcName);\n  },\n\n  createFunctionContext: function(asObject) {\n    let varDeclarations = '';\n\n    let locals = this.stackVars.concat(this.registers.list);\n    if (locals.length > 0) {\n      varDeclarations += ', ' + locals.join(', ');\n    }\n\n    // Generate minimizer alias mappings\n    //\n    // When using true SourceNodes, this will update all references to the given alias\n    // as the source nodes are reused in situ. For the non-source node compilation mode,\n    // aliases will not be used, but this case is already being run on the client and\n    // we aren't concern about minimizing the template size.\n    let aliasCount = 0;\n    Object.keys(this.aliases).forEach(alias => {\n      let node = this.aliases[alias];\n      if (node.children && node.referenceCount > 1) {\n        varDeclarations += ', alias' + ++aliasCount + '=' + alias;\n        node.children[0] = 'alias' + aliasCount;\n      }\n    });\n\n    if (this.lookupPropertyFunctionIsUsed) {\n      varDeclarations += ', ' + this.lookupPropertyFunctionVarDeclaration();\n    }\n\n    let params = ['container', 'depth0', 'helpers', 'partials', 'data'];\n\n    if (this.useBlockParams || this.useDepths) {\n      params.push('blockParams');\n    }\n    if (this.useDepths) {\n      params.push('depths');\n    }\n\n    // Perform a second pass over the output to merge content when possible\n    let source = this.mergeSource(varDeclarations);\n\n    if (asObject) {\n      params.push(source);\n\n      return Function.apply(this, params);\n    } else {\n      return this.source.wrap([\n        'function(',\n        params.join(','),\n        ') {\\n  ',\n        source,\n        '}'\n      ]);\n    }\n  },\n  mergeSource: function(varDeclarations) {\n    let isSimple = this.environment.isSimple,\n      appendOnly = !this.forceBuffer,\n      appendFirst,\n      sourceSeen,\n      bufferStart,\n      bufferEnd;\n    this.source.each(line => {\n      if (line.appendToBuffer) {\n        if (bufferStart) {\n          line.prepend('  + ');\n        } else {\n          bufferStart = line;\n        }\n        bufferEnd = line;\n      } else {\n        if (bufferStart) {\n          if (!sourceSeen) {\n            appendFirst = true;\n          } else {\n            bufferStart.prepend('buffer += ');\n          }\n          bufferEnd.add(';');\n          bufferStart = bufferEnd = undefined;\n        }\n\n        sourceSeen = true;\n        if (!isSimple) {\n          appendOnly = false;\n        }\n      }\n    });\n\n    if (appendOnly) {\n      if (bufferStart) {\n        bufferStart.prepend('return ');\n        bufferEnd.add(';');\n      } else if (!sourceSeen) {\n        this.source.push('return \"\";');\n      }\n    } else {\n      varDeclarations +=\n        ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());\n\n      if (bufferStart) {\n        bufferStart.prepend('return buffer + ');\n        bufferEnd.add(';');\n      } else {\n        this.source.push('return buffer;');\n      }\n    }\n\n    if (varDeclarations) {\n      this.source.prepend(\n        'var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\\n')\n      );\n    }\n\n    return this.source.merge();\n  },\n\n  lookupPropertyFunctionVarDeclaration: function() {\n    return `\n      lookupProperty = container.lookupProperty || function(parent, propertyName) {\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n          return parent[propertyName];\n        }\n        return undefined\n    }\n    `.trim();\n  },\n\n  // [blockValue]\n  //\n  // On stack, before: hash, inverse, program, value\n  // On stack, after: return value of blockHelperMissing\n  //\n  // The purpose of this opcode is to take a block of the form\n  // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and\n  // replace it on the stack with the result of properly\n  // invoking blockHelperMissing.\n  blockValue: function(name) {\n    let blockHelperMissing = this.aliasable(\n        'container.hooks.blockHelperMissing'\n      ),\n      params = [this.contextName(0)];\n    this.setupHelperArgs(name, 0, params);\n\n    let blockName = this.popStack();\n    params.splice(1, 0, blockName);\n\n    this.push(this.source.functionCall(blockHelperMissing, 'call', params));\n  },\n\n  // [ambiguousBlockValue]\n  //\n  // On stack, before: hash, inverse, program, value\n  // Compiler value, before: lastHelper=value of last found helper, if any\n  // On stack, after, if no lastHelper: same as [blockValue]\n  // On stack, after, if lastHelper: value\n  ambiguousBlockValue: function() {\n    // We're being a bit cheeky and reusing the options value from the prior exec\n    let blockHelperMissing = this.aliasable(\n        'container.hooks.blockHelperMissing'\n      ),\n      params = [this.contextName(0)];\n    this.setupHelperArgs('', 0, params, true);\n\n    this.flushInline();\n\n    let current = this.topStack();\n    params.splice(1, 0, current);\n\n    this.pushSource([\n      'if (!',\n      this.lastHelper,\n      ') { ',\n      current,\n      ' = ',\n      this.source.functionCall(blockHelperMissing, 'call', params),\n      '}'\n    ]);\n  },\n\n  // [appendContent]\n  //\n  // On stack, before: ...\n  // On stack, after: ...\n  //\n  // Appends the string value of `content` to the current buffer\n  appendContent: function(content) {\n    if (this.pendingContent) {\n      content = this.pendingContent + content;\n    } else {\n      this.pendingLocation = this.source.currentLocation;\n    }\n\n    this.pendingContent = content;\n  },\n\n  // [append]\n  //\n  // On stack, before: value, ...\n  // On stack, after: ...\n  //\n  // Coerces `value` to a String and appends it to the current buffer.\n  //\n  // If `value` is truthy, or 0, it is coerced into a string and appended\n  // Otherwise, the empty string is appended\n  append: function() {\n    if (this.isInline()) {\n      this.replaceStack(current => [' != null ? ', current, ' : \"\"']);\n\n      this.pushSource(this.appendToBuffer(this.popStack()));\n    } else {\n      let local = this.popStack();\n      this.pushSource([\n        'if (',\n        local,\n        ' != null) { ',\n        this.appendToBuffer(local, undefined, true),\n        ' }'\n      ]);\n      if (this.environment.isSimple) {\n        this.pushSource([\n          'else { ',\n          this.appendToBuffer(\"''\", undefined, true),\n          ' }'\n        ]);\n      }\n    }\n  },\n\n  // [appendEscaped]\n  //\n  // On stack, before: value, ...\n  // On stack, after: ...\n  //\n  // Escape `value` and append it to the buffer\n  appendEscaped: function() {\n    this.pushSource(\n      this.appendToBuffer([\n        this.aliasable('container.escapeExpression'),\n        '(',\n        this.popStack(),\n        ')'\n      ])\n    );\n  },\n\n  // [getContext]\n  //\n  // On stack, before: ...\n  // On stack, after: ...\n  // Compiler value, after: lastContext=depth\n  //\n  // Set the value of the `lastContext` compiler value to the depth\n  getContext: function(depth) {\n    this.lastContext = depth;\n  },\n\n  // [pushContext]\n  //\n  // On stack, before: ...\n  // On stack, after: currentContext, ...\n  //\n  // Pushes the value of the current context onto the stack.\n  pushContext: function() {\n    this.pushStackLiteral(this.contextName(this.lastContext));\n  },\n\n  // [lookupOnContext]\n  //\n  // On stack, before: ...\n  // On stack, after: currentContext[name], ...\n  //\n  // Looks up the value of `name` on the current context and pushes\n  // it onto the stack.\n  lookupOnContext: function(parts, falsy, strict, scoped) {\n    let i = 0;\n\n    if (!scoped && this.options.compat && !this.lastContext) {\n      // The depthed query is expected to handle the undefined logic for the root level that\n      // is implemented below, so we evaluate that directly in compat mode\n      this.push(this.depthedLookup(parts[i++]));\n    } else {\n      this.pushContext();\n    }\n\n    this.resolvePath('context', parts, i, falsy, strict);\n  },\n\n  // [lookupBlockParam]\n  //\n  // On stack, before: ...\n  // On stack, after: blockParam[name], ...\n  //\n  // Looks up the value of `parts` on the given block param and pushes\n  // it onto the stack.\n  lookupBlockParam: function(blockParamId, parts) {\n    this.useBlockParams = true;\n\n    this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);\n    this.resolvePath('context', parts, 1);\n  },\n\n  // [lookupData]\n  //\n  // On stack, before: ...\n  // On stack, after: data, ...\n  //\n  // Push the data lookup operator\n  lookupData: function(depth, parts, strict) {\n    if (!depth) {\n      this.pushStackLiteral('data');\n    } else {\n      this.pushStackLiteral('container.data(data, ' + depth + ')');\n    }\n\n    this.resolvePath('data', parts, 0, true, strict);\n  },\n\n  resolvePath: function(type, parts, i, falsy, strict) {\n    if (this.options.strict || this.options.assumeObjects) {\n      this.push(strictLookup(this.options.strict && strict, this, parts, type));\n      return;\n    }\n\n    let len = parts.length;\n    for (; i < len; i++) {\n      /* eslint-disable no-loop-func */\n      this.replaceStack(current => {\n        let lookup = this.nameLookup(current, parts[i], type);\n        // We want to ensure that zero and false are handled properly if the context (falsy flag)\n        // needs to have the special handling for these values.\n        if (!falsy) {\n          return [' != null ? ', lookup, ' : ', current];\n        } else {\n          // Otherwise we can use generic falsy handling\n          return [' && ', lookup];\n        }\n      });\n      /* eslint-enable no-loop-func */\n    }\n  },\n\n  // [resolvePossibleLambda]\n  //\n  // On stack, before: value, ...\n  // On stack, after: resolved value, ...\n  //\n  // If the `value` is a lambda, replace it on the stack by\n  // the return value of the lambda\n  resolvePossibleLambda: function() {\n    this.push([\n      this.aliasable('container.lambda'),\n      '(',\n      this.popStack(),\n      ', ',\n      this.contextName(0),\n      ')'\n    ]);\n  },\n\n  // [pushStringParam]\n  //\n  // On stack, before: ...\n  // On stack, after: string, currentContext, ...\n  //\n  // This opcode is designed for use in string mode, which\n  // provides the string value of a parameter along with its\n  // depth rather than resolving it immediately.\n  pushStringParam: function(string, type) {\n    this.pushContext();\n    this.pushString(type);\n\n    // If it's a subexpression, the string result\n    // will be pushed after this opcode.\n    if (type !== 'SubExpression') {\n      if (typeof string === 'string') {\n        this.pushString(string);\n      } else {\n        this.pushStackLiteral(string);\n      }\n    }\n  },\n\n  emptyHash: function(omitEmpty) {\n    if (this.trackIds) {\n      this.push('{}'); // hashIds\n    }\n    if (this.stringParams) {\n      this.push('{}'); // hashContexts\n      this.push('{}'); // hashTypes\n    }\n    this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');\n  },\n  pushHash: function() {\n    if (this.hash) {\n      this.hashes.push(this.hash);\n    }\n    this.hash = { values: {}, types: [], contexts: [], ids: [] };\n  },\n  popHash: function() {\n    let hash = this.hash;\n    this.hash = this.hashes.pop();\n\n    if (this.trackIds) {\n      this.push(this.objectLiteral(hash.ids));\n    }\n    if (this.stringParams) {\n      this.push(this.objectLiteral(hash.contexts));\n      this.push(this.objectLiteral(hash.types));\n    }\n\n    this.push(this.objectLiteral(hash.values));\n  },\n\n  // [pushString]\n  //\n  // On stack, before: ...\n  // On stack, after: quotedString(string), ...\n  //\n  // Push a quoted version of `string` onto the stack\n  pushString: function(string) {\n    this.pushStackLiteral(this.quotedString(string));\n  },\n\n  // [pushLiteral]\n  //\n  // On stack, before: ...\n  // On stack, after: value, ...\n  //\n  // Pushes a value onto the stack. This operation prevents\n  // the compiler from creating a temporary variable to hold\n  // it.\n  pushLiteral: function(value) {\n    this.pushStackLiteral(value);\n  },\n\n  // [pushProgram]\n  //\n  // On stack, before: ...\n  // On stack, after: program(guid), ...\n  //\n  // Push a program expression onto the stack. This takes\n  // a compile-time guid and converts it into a runtime-accessible\n  // expression.\n  pushProgram: function(guid) {\n    if (guid != null) {\n      this.pushStackLiteral(this.programExpression(guid));\n    } else {\n      this.pushStackLiteral(null);\n    }\n  },\n\n  // [registerDecorator]\n  //\n  // On stack, before: hash, program, params..., ...\n  // On stack, after: ...\n  //\n  // Pops off the decorator's parameters, invokes the decorator,\n  // and inserts the decorator into the decorators list.\n  registerDecorator(paramSize, name) {\n    let foundDecorator = this.nameLookup('decorators', name, 'decorator'),\n      options = this.setupHelperArgs(name, paramSize);\n\n    this.decorators.push([\n      'fn = ',\n      this.decorators.functionCall(foundDecorator, '', [\n        'fn',\n        'props',\n        'container',\n        options\n      ]),\n      ' || fn;'\n    ]);\n  },\n\n  // [invokeHelper]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of helper invocation\n  //\n  // Pops off the helper's parameters, invokes the helper,\n  // and pushes the helper's return value onto the stack.\n  //\n  // If the helper is not found, `helperMissing` is called.\n  invokeHelper: function(paramSize, name, isSimple) {\n    let nonHelper = this.popStack(),\n      helper = this.setupHelper(paramSize, name);\n\n    let possibleFunctionCalls = [];\n\n    if (isSimple) {\n      // direct call to helper\n      possibleFunctionCalls.push(helper.name);\n    }\n    // call a function from the input object\n    possibleFunctionCalls.push(nonHelper);\n    if (!this.options.strict) {\n      possibleFunctionCalls.push(\n        this.aliasable('container.hooks.helperMissing')\n      );\n    }\n\n    let functionLookupCode = [\n      '(',\n      this.itemsSeparatedBy(possibleFunctionCalls, '||'),\n      ')'\n    ];\n    let functionCall = this.source.functionCall(\n      functionLookupCode,\n      'call',\n      helper.callParams\n    );\n    this.push(functionCall);\n  },\n\n  itemsSeparatedBy: function(items, separator) {\n    let result = [];\n    result.push(items[0]);\n    for (let i = 1; i < items.length; i++) {\n      result.push(separator, items[i]);\n    }\n    return result;\n  },\n  // [invokeKnownHelper]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of helper invocation\n  //\n  // This operation is used when the helper is known to exist,\n  // so a `helperMissing` fallback is not required.\n  invokeKnownHelper: function(paramSize, name) {\n    let helper = this.setupHelper(paramSize, name);\n    this.push(this.source.functionCall(helper.name, 'call', helper.callParams));\n  },\n\n  // [invokeAmbiguous]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of disambiguation\n  //\n  // This operation is used when an expression like `{{foo}}`\n  // is provided, but we don't know at compile-time whether it\n  // is a helper or a path.\n  //\n  // This operation emits more code than the other options,\n  // and can be avoided by passing the `knownHelpers` and\n  // `knownHelpersOnly` flags at compile-time.\n  invokeAmbiguous: function(name, helperCall) {\n    this.useRegister('helper');\n\n    let nonHelper = this.popStack();\n\n    this.emptyHash();\n    let helper = this.setupHelper(0, name, helperCall);\n\n    let helperName = (this.lastHelper = this.nameLookup(\n      'helpers',\n      name,\n      'helper'\n    ));\n\n    let lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];\n    if (!this.options.strict) {\n      lookup[0] = '(helper = ';\n      lookup.push(\n        ' != null ? helper : ',\n        this.aliasable('container.hooks.helperMissing')\n      );\n    }\n\n    this.push([\n      '(',\n      lookup,\n      helper.paramsInit ? ['),(', helper.paramsInit] : [],\n      '),',\n      '(typeof helper === ',\n      this.aliasable('\"function\"'),\n      ' ? ',\n      this.source.functionCall('helper', 'call', helper.callParams),\n      ' : helper))'\n    ]);\n  },\n\n  // [invokePartial]\n  //\n  // On stack, before: context, ...\n  // On stack after: result of partial invocation\n  //\n  // This operation pops off a context, invokes a partial with that context,\n  // and pushes the result of the invocation back.\n  invokePartial: function(isDynamic, name, indent) {\n    let params = [],\n      options = this.setupParams(name, 1, params);\n\n    if (isDynamic) {\n      name = this.popStack();\n      delete options.name;\n    }\n\n    if (indent) {\n      options.indent = JSON.stringify(indent);\n    }\n    options.helpers = 'helpers';\n    options.partials = 'partials';\n    options.decorators = 'container.decorators';\n\n    if (!isDynamic) {\n      params.unshift(this.nameLookup('partials', name, 'partial'));\n    } else {\n      params.unshift(name);\n    }\n\n    if (this.options.compat) {\n      options.depths = 'depths';\n    }\n    options = this.objectLiteral(options);\n    params.push(options);\n\n    this.push(this.source.functionCall('container.invokePartial', '', params));\n  },\n\n  // [assignToHash]\n  //\n  // On stack, before: value, ..., hash, ...\n  // On stack, after: ..., hash, ...\n  //\n  // Pops a value off the stack and assigns it to the current hash\n  assignToHash: function(key) {\n    let value = this.popStack(),\n      context,\n      type,\n      id;\n\n    if (this.trackIds) {\n      id = this.popStack();\n    }\n    if (this.stringParams) {\n      type = this.popStack();\n      context = this.popStack();\n    }\n\n    let hash = this.hash;\n    if (context) {\n      hash.contexts[key] = context;\n    }\n    if (type) {\n      hash.types[key] = type;\n    }\n    if (id) {\n      hash.ids[key] = id;\n    }\n    hash.values[key] = value;\n  },\n\n  pushId: function(type, name, child) {\n    if (type === 'BlockParam') {\n      this.pushStackLiteral(\n        'blockParams[' +\n          name[0] +\n          '].path[' +\n          name[1] +\n          ']' +\n          (child ? ' + ' + JSON.stringify('.' + child) : '')\n      );\n    } else if (type === 'PathExpression') {\n      this.pushString(name);\n    } else if (type === 'SubExpression') {\n      this.pushStackLiteral('true');\n    } else {\n      this.pushStackLiteral('null');\n    }\n  },\n\n  // HELPERS\n\n  compiler: JavaScriptCompiler,\n\n  compileChildren: function(environment, options) {\n    let children = environment.children,\n      child,\n      compiler;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      child = children[i];\n      compiler = new this.compiler(); // eslint-disable-line new-cap\n\n      let existing = this.matchExistingProgram(child);\n\n      if (existing == null) {\n        this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children\n        let index = this.context.programs.length;\n        child.index = index;\n        child.name = 'program' + index;\n        this.context.programs[index] = compiler.compile(\n          child,\n          options,\n          this.context,\n          !this.precompile\n        );\n        this.context.decorators[index] = compiler.decorators;\n        this.context.environments[index] = child;\n\n        this.useDepths = this.useDepths || compiler.useDepths;\n        this.useBlockParams = this.useBlockParams || compiler.useBlockParams;\n        child.useDepths = this.useDepths;\n        child.useBlockParams = this.useBlockParams;\n      } else {\n        child.index = existing.index;\n        child.name = 'program' + existing.index;\n\n        this.useDepths = this.useDepths || existing.useDepths;\n        this.useBlockParams = this.useBlockParams || existing.useBlockParams;\n      }\n    }\n  },\n  matchExistingProgram: function(child) {\n    for (let i = 0, len = this.context.environments.length; i < len; i++) {\n      let environment = this.context.environments[i];\n      if (environment && environment.equals(child)) {\n        return environment;\n      }\n    }\n  },\n\n  programExpression: function(guid) {\n    let child = this.environment.children[guid],\n      programParams = [child.index, 'data', child.blockParams];\n\n    if (this.useBlockParams || this.useDepths) {\n      programParams.push('blockParams');\n    }\n    if (this.useDepths) {\n      programParams.push('depths');\n    }\n\n    return 'container.program(' + programParams.join(', ') + ')';\n  },\n\n  useRegister: function(name) {\n    if (!this.registers[name]) {\n      this.registers[name] = true;\n      this.registers.list.push(name);\n    }\n  },\n\n  push: function(expr) {\n    if (!(expr instanceof Literal)) {\n      expr = this.source.wrap(expr);\n    }\n\n    this.inlineStack.push(expr);\n    return expr;\n  },\n\n  pushStackLiteral: function(item) {\n    this.push(new Literal(item));\n  },\n\n  pushSource: function(source) {\n    if (this.pendingContent) {\n      this.source.push(\n        this.appendToBuffer(\n          this.source.quotedString(this.pendingContent),\n          this.pendingLocation\n        )\n      );\n      this.pendingContent = undefined;\n    }\n\n    if (source) {\n      this.source.push(source);\n    }\n  },\n\n  replaceStack: function(callback) {\n    let prefix = ['('],\n      stack,\n      createdStack,\n      usedLiteral;\n\n    /* istanbul ignore next */\n    if (!this.isInline()) {\n      throw new Exception('replaceStack on non-inline');\n    }\n\n    // We want to merge the inline statement into the replacement statement via ','\n    let top = this.popStack(true);\n\n    if (top instanceof Literal) {\n      // Literals do not need to be inlined\n      stack = [top.value];\n      prefix = ['(', stack];\n      usedLiteral = true;\n    } else {\n      // Get or create the current stack name for use by the inline\n      createdStack = true;\n      let name = this.incrStack();\n\n      prefix = ['((', this.push(name), ' = ', top, ')'];\n      stack = this.topStack();\n    }\n\n    let item = callback.call(this, stack);\n\n    if (!usedLiteral) {\n      this.popStack();\n    }\n    if (createdStack) {\n      this.stackSlot--;\n    }\n    this.push(prefix.concat(item, ')'));\n  },\n\n  incrStack: function() {\n    this.stackSlot++;\n    if (this.stackSlot > this.stackVars.length) {\n      this.stackVars.push('stack' + this.stackSlot);\n    }\n    return this.topStackName();\n  },\n  topStackName: function() {\n    return 'stack' + this.stackSlot;\n  },\n  flushInline: function() {\n    let inlineStack = this.inlineStack;\n    this.inlineStack = [];\n    for (let i = 0, len = inlineStack.length; i < len; i++) {\n      let entry = inlineStack[i];\n      /* istanbul ignore if */\n      if (entry instanceof Literal) {\n        this.compileStack.push(entry);\n      } else {\n        let stack = this.incrStack();\n        this.pushSource([stack, ' = ', entry, ';']);\n        this.compileStack.push(stack);\n      }\n    }\n  },\n  isInline: function() {\n    return this.inlineStack.length;\n  },\n\n  popStack: function(wrapped) {\n    let inline = this.isInline(),\n      item = (inline ? this.inlineStack : this.compileStack).pop();\n\n    if (!wrapped && item instanceof Literal) {\n      return item.value;\n    } else {\n      if (!inline) {\n        /* istanbul ignore next */\n        if (!this.stackSlot) {\n          throw new Exception('Invalid stack pop');\n        }\n        this.stackSlot--;\n      }\n      return item;\n    }\n  },\n\n  topStack: function() {\n    let stack = this.isInline() ? this.inlineStack : this.compileStack,\n      item = stack[stack.length - 1];\n\n    /* istanbul ignore if */\n    if (item instanceof Literal) {\n      return item.value;\n    } else {\n      return item;\n    }\n  },\n\n  contextName: function(context) {\n    if (this.useDepths && context) {\n      return 'depths[' + context + ']';\n    } else {\n      return 'depth' + context;\n    }\n  },\n\n  quotedString: function(str) {\n    return this.source.quotedString(str);\n  },\n\n  objectLiteral: function(obj) {\n    return this.source.objectLiteral(obj);\n  },\n\n  aliasable: function(name) {\n    let ret = this.aliases[name];\n    if (ret) {\n      ret.referenceCount++;\n      return ret;\n    }\n\n    ret = this.aliases[name] = this.source.wrap(name);\n    ret.aliasable = true;\n    ret.referenceCount = 1;\n\n    return ret;\n  },\n\n  setupHelper: function(paramSize, name, blockHelper) {\n    let params = [],\n      paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);\n    let foundHelper = this.nameLookup('helpers', name, 'helper'),\n      callContext = this.aliasable(\n        `${this.contextName(0)} != null ? ${this.contextName(\n          0\n        )} : (container.nullContext || {})`\n      );\n\n    return {\n      params: params,\n      paramsInit: paramsInit,\n      name: foundHelper,\n      callParams: [callContext].concat(params)\n    };\n  },\n\n  setupParams: function(helper, paramSize, params) {\n    let options = {},\n      contexts = [],\n      types = [],\n      ids = [],\n      objectArgs = !params,\n      param;\n\n    if (objectArgs) {\n      params = [];\n    }\n\n    options.name = this.quotedString(helper);\n    options.hash = this.popStack();\n\n    if (this.trackIds) {\n      options.hashIds = this.popStack();\n    }\n    if (this.stringParams) {\n      options.hashTypes = this.popStack();\n      options.hashContexts = this.popStack();\n    }\n\n    let inverse = this.popStack(),\n      program = this.popStack();\n\n    // Avoid setting fn and inverse if neither are set. This allows\n    // helpers to do a check for `if (options.fn)`\n    if (program || inverse) {\n      options.fn = program || 'container.noop';\n      options.inverse = inverse || 'container.noop';\n    }\n\n    // The parameters go on to the stack in order (making sure that they are evaluated in order)\n    // so we need to pop them off the stack in reverse order\n    let i = paramSize;\n    while (i--) {\n      param = this.popStack();\n      params[i] = param;\n\n      if (this.trackIds) {\n        ids[i] = this.popStack();\n      }\n      if (this.stringParams) {\n        types[i] = this.popStack();\n        contexts[i] = this.popStack();\n      }\n    }\n\n    if (objectArgs) {\n      options.args = this.source.generateArray(params);\n    }\n\n    if (this.trackIds) {\n      options.ids = this.source.generateArray(ids);\n    }\n    if (this.stringParams) {\n      options.types = this.source.generateArray(types);\n      options.contexts = this.source.generateArray(contexts);\n    }\n\n    if (this.options.data) {\n      options.data = 'data';\n    }\n    if (this.useBlockParams) {\n      options.blockParams = 'blockParams';\n    }\n    return options;\n  },\n\n  setupHelperArgs: function(helper, paramSize, params, useRegister) {\n    let options = this.setupParams(helper, paramSize, params);\n    options.loc = JSON.stringify(this.source.currentLocation);\n    options = this.objectLiteral(options);\n    if (useRegister) {\n      this.useRegister('options');\n      params.push('options');\n      return ['options=', options];\n    } else if (params) {\n      params.push(options);\n      return '';\n    } else {\n      return options;\n    }\n  }\n};\n\n(function() {\n  const reservedWords = (\n    'break else new var' +\n    ' case finally return void' +\n    ' catch for switch while' +\n    ' continue function this with' +\n    ' default if throw' +\n    ' delete in try' +\n    ' do instanceof typeof' +\n    ' abstract enum int short' +\n    ' boolean export interface static' +\n    ' byte extends long super' +\n    ' char final native synchronized' +\n    ' class float package throws' +\n    ' const goto private transient' +\n    ' debugger implements protected volatile' +\n    ' double import public let yield await' +\n    ' null true false'\n  ).split(' ');\n\n  const compilerWords = (JavaScriptCompiler.RESERVED_WORDS = {});\n\n  for (let i = 0, l = reservedWords.length; i < l; i++) {\n    compilerWords[reservedWords[i]] = true;\n  }\n})();\n\n/**\n * @deprecated May be removed in the next major version\n */\nJavaScriptCompiler.isValidJavaScriptVariableName = function(name) {\n  return (\n    !JavaScriptCompiler.RESERVED_WORDS[name] &&\n    /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name)\n  );\n};\n\nfunction strictLookup(requireTerminal, compiler, parts, type) {\n  let stack = compiler.popStack(),\n    i = 0,\n    len = parts.length;\n  if (requireTerminal) {\n    len--;\n  }\n\n  for (; i < len; i++) {\n    stack = compiler.nameLookup(stack, parts[i], type);\n  }\n\n  if (requireTerminal) {\n    return [\n      compiler.aliasable('container.strict'),\n      '(',\n      stack,\n      ', ',\n      compiler.quotedString(parts[i]),\n      ', ',\n      JSON.stringify(compiler.source.currentLocation),\n      ' )'\n    ];\n  } else {\n    return stack;\n  }\n}\n\nexport default JavaScriptCompiler;\n"]},"metadata":{},"sourceType":"script"}