{"ast":null,"code":"var _ = require('lodash'),\n  Cursor = require('../cursor'),\n  VariableScope = require('postman-collection').VariableScope,\n  prepareLookupHash,\n  extractSNR,\n  getIterationData;\n\n/**\n * Returns a hash of IDs and Names of items in an array\n *\n * @param {Array} items -\n * @returns {Object}\n */\nprepareLookupHash = function (items) {\n  var hash = {\n    ids: {},\n    names: {},\n    obj: {}\n  };\n  _.forEach(items, function (item, index) {\n    if (item) {\n      item.id && (hash.ids[item.id] = index);\n      item.name && (hash.names[item.name] = index);\n    }\n  });\n  return hash;\n};\nextractSNR = function (executions, previous) {\n  var snr = previous || {};\n  _.isArray(executions) && executions.forEach(function (execution) {\n    _.has(_.get(execution, 'result.return'), 'nextRequest') && (snr.defined = true, snr.value = execution.result.return.nextRequest);\n  });\n  return snr;\n};\n\n/**\n * Returns the data for the given iteration\n *\n * @function getIterationData\n * @param {Array} data - The data array containing all iterations' data\n * @param {Number} iteration - The iteration to get data for\n * @return {Any} - The data for the iteration\n */\ngetIterationData = function (data, iteration) {\n  // if iteration has a corresponding data element use that\n  if (iteration < data.length) {\n    return data[iteration];\n  }\n\n  // otherwise use the last data element\n  return data[data.length - 1];\n};\n\n/**\n * Adds options\n * disableSNR:Boolean\n *\n * @type {Object}\n */\nmodule.exports = {\n  init: function (done) {\n    var state = this.state;\n\n    // ensure that the environment, globals and collectionVariables are in VariableScope instance format\n    state.environment = VariableScope.isVariableScope(state.environment) ? state.environment : new VariableScope(state.environment);\n    state.globals = VariableScope.isVariableScope(state.globals) ? state.globals : new VariableScope(state.globals);\n    state.collectionVariables = VariableScope.isVariableScope(state.collectionVariables) ? state.collectionVariables : new VariableScope(state.collectionVariables);\n    state._variables = new VariableScope();\n\n    // ensure that the items and iteration data set is in place\n    !_.isArray(state.items) && (state.items = []);\n    !_.isArray(state.data) && (state.data = []);\n    !_.isObject(state.data[0]) && (state.data[0] = {});\n\n    // if the location in state is already normalised then go ahead and queue iteration, else normalise the\n    // location\n    state.cursor = Cursor.box(state.cursor, {\n      // we pass bounds to ensure there is no stale state\n      cycles: this.options.iterationCount,\n      length: state.items.length\n    });\n    this.waterfall = state.cursor; // copy the location object to instance for quick access\n\n    // queue the iteration command on start\n    this.queue('waterfall', {\n      coords: this.waterfall.current(),\n      static: true,\n      start: true\n    });\n\n    // clear the variable that is supposed to store item name and id lookup hash for easy setNextRequest\n    this.snrHash = null; // we populate it in the first SNR call\n\n    done();\n  },\n  triggers: ['beforeIteration', 'iteration'],\n  process: {\n    /**\n     * This processor simply queues scripts and requests in a linear chain.\n     *\n     * @param {Object} payload -\n     * @param {Object} payload.coords -\n     * @param {Boolean} [payload.static=false] -\n     * @param {Function} next -\n     */\n    waterfall(payload, next) {\n      // we procure the coordinates that we have to pick item and data from. the data is\n      var coords = payload.static ? payload.coords : this.waterfall.whatnext(payload.coords),\n        item = this.state.items[coords.position],\n        delay;\n\n      // if there is nothing to process, we bail out from here, even before we enter the iteration cycle\n      if (coords.empty) {\n        return next();\n      }\n      if (payload.stopRunNow) {\n        this.triggers.iteration(null, payload.coords);\n        return next();\n      }\n\n      // if it is a beginning of a run, we need to raise events for iteration start\n      if (payload.start) {\n        this.triggers.beforeIteration(null, coords);\n      }\n\n      // if this is a new iteration, we close the previous one and start new\n      if (coords.cr) {\n        // getting the iteration delay here ensures that delay is only called between two iterations\n        delay = _.get(this.options, 'delay.iteration', 0);\n        this.triggers.iteration(null, payload.coords);\n        this.triggers.beforeIteration(null, coords);\n      }\n\n      // if this is end of waterfall, it is an end of iteration and also end of run\n      if (coords.eof) {\n        this.triggers.iteration(null, coords);\n        return next();\n      }\n      this.queueDelay(function () {\n        this.queue('item', {\n          item: item,\n          coords: coords,\n          data: getIterationData(this.state.data, coords.iteration),\n          environment: this.state.environment,\n          globals: this.state.globals,\n          collectionVariables: this.state.collectionVariables,\n          _variables: this.state._variables\n        }, function (executionError, executions) {\n          var snr = {},\n            nextCoords,\n            seekingToStart,\n            stopRunNow,\n            stopOnFailure = this.options.stopOnFailure;\n          if (!executionError) {\n            // extract set next request\n            snr = extractSNR(executions.prerequest);\n            snr = extractSNR(executions.test, snr);\n          }\n          if (!this.options.disableSNR && snr.defined) {\n            // prepare the snr lookup hash if it is not already provided\n            // @todo - figure out a way to reset this post run complete\n            !this.snrHash && (this.snrHash = prepareLookupHash(this.state.items));\n\n            // if it is null, we do not proceed further and move on\n            // see if a request is found in the hash and then reset the coords position to the lookup\n            // value.\n            snr.value !== null && (snr.position =\n            // eslint-disable-next-line no-nested-ternary\n            this.snrHash[_.has(this.snrHash.ids, snr.value) ? 'ids' : _.has(this.snrHash.names, snr.value) ? 'names' : 'obj'][snr.value]);\n            snr.valid = _.isNumber(snr.position);\n          }\n          nextCoords = _.clone(coords);\n          if (snr.valid) {\n            // if the position was detected, we set the position to the one previous to the desired location\n            // this ensures that the next call to .whatnext() will return the desired position.\n            nextCoords.position = snr.position - 1;\n          } else {\n            // if snr was requested, but not valid, we stop this iteration.\n            // stopping an iteration is equivalent to seeking the last position of the current\n            // iteration, so that the next call to .whatnext() will automatically move to the next\n            // iteration.\n            (snr.defined || executionError) && (nextCoords.position = nextCoords.length - 1);\n\n            // If we need to stop on a run, we set the stop flag to true.\n            stopOnFailure && executionError && (stopRunNow = true);\n          }\n\n          // @todo - do this in unhacky way\n          if (nextCoords.position === -1) {\n            nextCoords.position = 0;\n            seekingToStart = true;\n          }\n          this.waterfall.seek(nextCoords.position, nextCoords.iteration, function (err, chngd, coords) {\n            // this condition should never arise, so better throw error when this happens\n            if (err) {\n              throw err;\n            }\n            this.queue('waterfall', {\n              coords: coords,\n              static: seekingToStart,\n              stopRunNow: stopRunNow\n            });\n          }, this);\n        });\n      }.bind(this), {\n        time: delay,\n        source: 'iteration',\n        cursor: coords\n      }, next);\n    }\n  }\n};","map":{"version":3,"names":["_","require","Cursor","VariableScope","prepareLookupHash","extractSNR","getIterationData","items","hash","ids","names","obj","forEach","item","index","id","name","executions","previous","snr","isArray","execution","has","get","defined","value","result","return","nextRequest","data","iteration","length","module","exports","init","done","state","environment","isVariableScope","globals","collectionVariables","_variables","isObject","cursor","box","cycles","options","iterationCount","waterfall","queue","coords","current","static","start","snrHash","triggers","process","payload","next","whatnext","position","delay","empty","stopRunNow","beforeIteration","cr","eof","queueDelay","executionError","nextCoords","seekingToStart","stopOnFailure","prerequest","test","disableSNR","valid","isNumber","clone","seek","err","chngd","bind","time","source"],"sources":["/Users/Qusai.Qishta/node_modules/postman-runtime/lib/runner/extensions/waterfall.command.js"],"sourcesContent":["var _ = require('lodash'),\n    Cursor = require('../cursor'),\n    VariableScope = require('postman-collection').VariableScope,\n\n    prepareLookupHash,\n    extractSNR,\n    getIterationData;\n\n/**\n * Returns a hash of IDs and Names of items in an array\n *\n * @param {Array} items -\n * @returns {Object}\n */\nprepareLookupHash = function (items) {\n    var hash = {\n        ids: {},\n        names: {},\n        obj: {}\n    };\n\n    _.forEach(items, function (item, index) {\n        if (item) {\n            item.id && (hash.ids[item.id] = index);\n            item.name && (hash.names[item.name] = index);\n        }\n    });\n\n    return hash;\n};\n\nextractSNR = function (executions, previous) {\n    var snr = previous || {};\n\n    _.isArray(executions) && executions.forEach(function (execution) {\n        _.has(_.get(execution, 'result.return'), 'nextRequest') && (\n            (snr.defined = true),\n            (snr.value = execution.result.return.nextRequest)\n        );\n    });\n\n    return snr;\n};\n\n/**\n * Returns the data for the given iteration\n *\n * @function getIterationData\n * @param {Array} data - The data array containing all iterations' data\n * @param {Number} iteration - The iteration to get data for\n * @return {Any} - The data for the iteration\n */\ngetIterationData = function (data, iteration) {\n    // if iteration has a corresponding data element use that\n    if (iteration < data.length) {\n        return data[iteration];\n    }\n\n    // otherwise use the last data element\n    return data[data.length - 1];\n};\n\n/**\n * Adds options\n * disableSNR:Boolean\n *\n * @type {Object}\n */\nmodule.exports = {\n    init: function (done) {\n        var state = this.state;\n\n        // ensure that the environment, globals and collectionVariables are in VariableScope instance format\n        state.environment = VariableScope.isVariableScope(state.environment) ? state.environment :\n            new VariableScope(state.environment);\n        state.globals = VariableScope.isVariableScope(state.globals) ? state.globals :\n            new VariableScope(state.globals);\n        state.collectionVariables = VariableScope.isVariableScope(state.collectionVariables) ?\n            state.collectionVariables : new VariableScope(state.collectionVariables);\n        state._variables = new VariableScope();\n\n        // ensure that the items and iteration data set is in place\n        !_.isArray(state.items) && (state.items = []);\n        !_.isArray(state.data) && (state.data = []);\n        !_.isObject(state.data[0]) && (state.data[0] = {});\n\n        // if the location in state is already normalised then go ahead and queue iteration, else normalise the\n        // location\n        state.cursor = Cursor.box(state.cursor, { // we pass bounds to ensure there is no stale state\n            cycles: this.options.iterationCount,\n            length: state.items.length\n        });\n        this.waterfall = state.cursor; // copy the location object to instance for quick access\n\n        // queue the iteration command on start\n        this.queue('waterfall', {\n            coords: this.waterfall.current(),\n            static: true,\n            start: true\n        });\n\n        // clear the variable that is supposed to store item name and id lookup hash for easy setNextRequest\n        this.snrHash = null; // we populate it in the first SNR call\n\n        done();\n    },\n\n    triggers: ['beforeIteration', 'iteration'],\n\n    process: {\n        /**\n         * This processor simply queues scripts and requests in a linear chain.\n         *\n         * @param {Object} payload -\n         * @param {Object} payload.coords -\n         * @param {Boolean} [payload.static=false] -\n         * @param {Function} next -\n         */\n        waterfall (payload, next) {\n            // we procure the coordinates that we have to pick item and data from. the data is\n            var coords = payload.static ? payload.coords : this.waterfall.whatnext(payload.coords),\n                item = this.state.items[coords.position],\n                delay;\n\n            // if there is nothing to process, we bail out from here, even before we enter the iteration cycle\n            if (coords.empty) {\n                return next();\n            }\n\n            if (payload.stopRunNow) {\n                this.triggers.iteration(null, payload.coords);\n\n                return next();\n            }\n\n            // if it is a beginning of a run, we need to raise events for iteration start\n            if (payload.start) {\n                this.triggers.beforeIteration(null, coords);\n            }\n\n            // if this is a new iteration, we close the previous one and start new\n            if (coords.cr) {\n                // getting the iteration delay here ensures that delay is only called between two iterations\n                delay = _.get(this.options, 'delay.iteration', 0);\n\n                this.triggers.iteration(null, payload.coords);\n                this.triggers.beforeIteration(null, coords);\n            }\n\n            // if this is end of waterfall, it is an end of iteration and also end of run\n            if (coords.eof) {\n                this.triggers.iteration(null, coords);\n\n                return next();\n            }\n\n            this.queueDelay(function () {\n                this.queue('item', {\n                    item: item,\n                    coords: coords,\n                    data: getIterationData(this.state.data, coords.iteration),\n                    environment: this.state.environment,\n                    globals: this.state.globals,\n                    collectionVariables: this.state.collectionVariables,\n                    _variables: this.state._variables\n                }, function (executionError, executions) {\n                    var snr = {},\n                        nextCoords,\n                        seekingToStart,\n                        stopRunNow,\n\n                        stopOnFailure = this.options.stopOnFailure;\n\n                    if (!executionError) {\n                        // extract set next request\n                        snr = extractSNR(executions.prerequest);\n                        snr = extractSNR(executions.test, snr);\n                    }\n\n                    if (!this.options.disableSNR && snr.defined) {\n                        // prepare the snr lookup hash if it is not already provided\n                        // @todo - figure out a way to reset this post run complete\n                        !this.snrHash && (this.snrHash = prepareLookupHash(this.state.items));\n\n                        // if it is null, we do not proceed further and move on\n                        // see if a request is found in the hash and then reset the coords position to the lookup\n                        // value.\n                        (snr.value !== null) && (snr.position = // eslint-disable-next-line no-nested-ternary\n                            this.snrHash[_.has(this.snrHash.ids, snr.value) ? 'ids' :\n                                (_.has(this.snrHash.names, snr.value) ? 'names' : 'obj')][snr.value]);\n\n                        snr.valid = _.isNumber(snr.position);\n                    }\n\n                    nextCoords = _.clone(coords);\n\n                    if (snr.valid) {\n                        // if the position was detected, we set the position to the one previous to the desired location\n                        // this ensures that the next call to .whatnext() will return the desired position.\n                        nextCoords.position = snr.position - 1;\n                    }\n                    else {\n                        // if snr was requested, but not valid, we stop this iteration.\n                        // stopping an iteration is equivalent to seeking the last position of the current\n                        // iteration, so that the next call to .whatnext() will automatically move to the next\n                        // iteration.\n                        (snr.defined || executionError) && (nextCoords.position = nextCoords.length - 1);\n\n                        // If we need to stop on a run, we set the stop flag to true.\n                        (stopOnFailure && executionError) && (stopRunNow = true);\n                    }\n\n                    // @todo - do this in unhacky way\n                    if (nextCoords.position === -1) {\n                        nextCoords.position = 0;\n                        seekingToStart = true;\n                    }\n\n                    this.waterfall.seek(nextCoords.position, nextCoords.iteration, function (err, chngd, coords) {\n                        // this condition should never arise, so better throw error when this happens\n                        if (err) {\n                            throw err;\n                        }\n\n                        this.queue('waterfall', {\n                            coords: coords,\n                            static: seekingToStart,\n                            stopRunNow: stopRunNow\n                        });\n                    }, this);\n                });\n            }.bind(this), {\n                time: delay,\n                source: 'iteration',\n                cursor: coords\n            }, next);\n        }\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}