{"ast":null,"code":"/* eslint-disable new-cap */\n\n'use strict';\n\nexports.__esModule = true;\nexports.Compiler = Compiler;\nexports.precompile = precompile;\nexports.compile = compile;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\nvar _exception = require('../exception');\nvar _exception2 = _interopRequireDefault(_exception);\nvar _utils = require('../utils');\nvar _ast = require('./ast');\nvar _ast2 = _interopRequireDefault(_ast);\nvar slice = [].slice;\nfunction Compiler() {}\n\n// the foundHelper register will disambiguate helper lookup from finding a\n// function in a context. This is necessary for mustache compatibility, which\n// requires that context functions in blocks are evaluated by blockHelperMissing,\n// and then proceed as if the resulting value was provided to blockHelperMissing.\n\nCompiler.prototype = {\n  compiler: Compiler,\n  equals: function equals(other) {\n    var len = this.opcodes.length;\n    if (other.opcodes.length !== len) {\n      return false;\n    }\n    for (var i = 0; i < len; i++) {\n      var opcode = this.opcodes[i],\n        otherOpcode = other.opcodes[i];\n      if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {\n        return false;\n      }\n    }\n\n    // We know that length is the same between the two arrays because they are directly tied\n    // to the opcode behavior above.\n    len = this.children.length;\n    for (var i = 0; i < len; i++) {\n      if (!this.children[i].equals(other.children[i])) {\n        return false;\n      }\n    }\n    return true;\n  },\n  guid: 0,\n  compile: function compile(program, options) {\n    this.sourceNode = [];\n    this.opcodes = [];\n    this.children = [];\n    this.options = options;\n    this.stringParams = options.stringParams;\n    this.trackIds = options.trackIds;\n    options.blockParams = options.blockParams || [];\n    options.knownHelpers = _utils.extend(Object.create(null), {\n      helperMissing: true,\n      blockHelperMissing: true,\n      each: true,\n      'if': true,\n      unless: true,\n      'with': true,\n      log: true,\n      lookup: true\n    }, options.knownHelpers);\n    return this.accept(program);\n  },\n  compileProgram: function compileProgram(program) {\n    var childCompiler = new this.compiler(),\n      // eslint-disable-line new-cap\n      result = childCompiler.compile(program, this.options),\n      guid = this.guid++;\n    this.usePartial = this.usePartial || result.usePartial;\n    this.children[guid] = result;\n    this.useDepths = this.useDepths || result.useDepths;\n    return guid;\n  },\n  accept: function accept(node) {\n    /* istanbul ignore next: Sanity code */\n    if (!this[node.type]) {\n      throw new _exception2['default']('Unknown type: ' + node.type, node);\n    }\n    this.sourceNode.unshift(node);\n    var ret = this[node.type](node);\n    this.sourceNode.shift();\n    return ret;\n  },\n  Program: function Program(program) {\n    this.options.blockParams.unshift(program.blockParams);\n    var body = program.body,\n      bodyLength = body.length;\n    for (var i = 0; i < bodyLength; i++) {\n      this.accept(body[i]);\n    }\n    this.options.blockParams.shift();\n    this.isSimple = bodyLength === 1;\n    this.blockParams = program.blockParams ? program.blockParams.length : 0;\n    return this;\n  },\n  BlockStatement: function BlockStatement(block) {\n    transformLiteralToPath(block);\n    var program = block.program,\n      inverse = block.inverse;\n    program = program && this.compileProgram(program);\n    inverse = inverse && this.compileProgram(inverse);\n    var type = this.classifySexpr(block);\n    if (type === 'helper') {\n      this.helperSexpr(block, program, inverse);\n    } else if (type === 'simple') {\n      this.simpleSexpr(block);\n\n      // now that the simple mustache is resolved, we need to\n      // evaluate it by executing `blockHelperMissing`\n      this.opcode('pushProgram', program);\n      this.opcode('pushProgram', inverse);\n      this.opcode('emptyHash');\n      this.opcode('blockValue', block.path.original);\n    } else {\n      this.ambiguousSexpr(block, program, inverse);\n\n      // now that the simple mustache is resolved, we need to\n      // evaluate it by executing `blockHelperMissing`\n      this.opcode('pushProgram', program);\n      this.opcode('pushProgram', inverse);\n      this.opcode('emptyHash');\n      this.opcode('ambiguousBlockValue');\n    }\n    this.opcode('append');\n  },\n  DecoratorBlock: function DecoratorBlock(decorator) {\n    var program = decorator.program && this.compileProgram(decorator.program);\n    var params = this.setupFullMustacheParams(decorator, program, undefined),\n      path = decorator.path;\n    this.useDecorators = true;\n    this.opcode('registerDecorator', params.length, path.original);\n  },\n  PartialStatement: function PartialStatement(partial) {\n    this.usePartial = true;\n    var program = partial.program;\n    if (program) {\n      program = this.compileProgram(partial.program);\n    }\n    var params = partial.params;\n    if (params.length > 1) {\n      throw new _exception2['default']('Unsupported number of partial arguments: ' + params.length, partial);\n    } else if (!params.length) {\n      if (this.options.explicitPartialContext) {\n        this.opcode('pushLiteral', 'undefined');\n      } else {\n        params.push({\n          type: 'PathExpression',\n          parts: [],\n          depth: 0\n        });\n      }\n    }\n    var partialName = partial.name.original,\n      isDynamic = partial.name.type === 'SubExpression';\n    if (isDynamic) {\n      this.accept(partial.name);\n    }\n    this.setupFullMustacheParams(partial, program, undefined, true);\n    var indent = partial.indent || '';\n    if (this.options.preventIndent && indent) {\n      this.opcode('appendContent', indent);\n      indent = '';\n    }\n    this.opcode('invokePartial', isDynamic, partialName, indent);\n    this.opcode('append');\n  },\n  PartialBlockStatement: function PartialBlockStatement(partialBlock) {\n    this.PartialStatement(partialBlock);\n  },\n  MustacheStatement: function MustacheStatement(mustache) {\n    this.SubExpression(mustache);\n    if (mustache.escaped && !this.options.noEscape) {\n      this.opcode('appendEscaped');\n    } else {\n      this.opcode('append');\n    }\n  },\n  Decorator: function Decorator(decorator) {\n    this.DecoratorBlock(decorator);\n  },\n  ContentStatement: function ContentStatement(content) {\n    if (content.value) {\n      this.opcode('appendContent', content.value);\n    }\n  },\n  CommentStatement: function CommentStatement() {},\n  SubExpression: function SubExpression(sexpr) {\n    transformLiteralToPath(sexpr);\n    var type = this.classifySexpr(sexpr);\n    if (type === 'simple') {\n      this.simpleSexpr(sexpr);\n    } else if (type === 'helper') {\n      this.helperSexpr(sexpr);\n    } else {\n      this.ambiguousSexpr(sexpr);\n    }\n  },\n  ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {\n    var path = sexpr.path,\n      name = path.parts[0],\n      isBlock = program != null || inverse != null;\n    this.opcode('getContext', path.depth);\n    this.opcode('pushProgram', program);\n    this.opcode('pushProgram', inverse);\n    path.strict = true;\n    this.accept(path);\n    this.opcode('invokeAmbiguous', name, isBlock);\n  },\n  simpleSexpr: function simpleSexpr(sexpr) {\n    var path = sexpr.path;\n    path.strict = true;\n    this.accept(path);\n    this.opcode('resolvePossibleLambda');\n  },\n  helperSexpr: function helperSexpr(sexpr, program, inverse) {\n    var params = this.setupFullMustacheParams(sexpr, program, inverse),\n      path = sexpr.path,\n      name = path.parts[0];\n    if (this.options.knownHelpers[name]) {\n      this.opcode('invokeKnownHelper', params.length, name);\n    } else if (this.options.knownHelpersOnly) {\n      throw new _exception2['default']('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);\n    } else {\n      path.strict = true;\n      path.falsy = true;\n      this.accept(path);\n      this.opcode('invokeHelper', params.length, path.original, _ast2['default'].helpers.simpleId(path));\n    }\n  },\n  PathExpression: function PathExpression(path) {\n    this.addDepth(path.depth);\n    this.opcode('getContext', path.depth);\n    var name = path.parts[0],\n      scoped = _ast2['default'].helpers.scopedId(path),\n      blockParamId = !path.depth && !scoped && this.blockParamIndex(name);\n    if (blockParamId) {\n      this.opcode('lookupBlockParam', blockParamId, path.parts);\n    } else if (!name) {\n      // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`\n      this.opcode('pushContext');\n    } else if (path.data) {\n      this.options.data = true;\n      this.opcode('lookupData', path.depth, path.parts, path.strict);\n    } else {\n      this.opcode('lookupOnContext', path.parts, path.falsy, path.strict, scoped);\n    }\n  },\n  StringLiteral: function StringLiteral(string) {\n    this.opcode('pushString', string.value);\n  },\n  NumberLiteral: function NumberLiteral(number) {\n    this.opcode('pushLiteral', number.value);\n  },\n  BooleanLiteral: function BooleanLiteral(bool) {\n    this.opcode('pushLiteral', bool.value);\n  },\n  UndefinedLiteral: function UndefinedLiteral() {\n    this.opcode('pushLiteral', 'undefined');\n  },\n  NullLiteral: function NullLiteral() {\n    this.opcode('pushLiteral', 'null');\n  },\n  Hash: function Hash(hash) {\n    var pairs = hash.pairs,\n      i = 0,\n      l = pairs.length;\n    this.opcode('pushHash');\n    for (; i < l; i++) {\n      this.pushParam(pairs[i].value);\n    }\n    while (i--) {\n      this.opcode('assignToHash', pairs[i].key);\n    }\n    this.opcode('popHash');\n  },\n  // HELPERS\n  opcode: function opcode(name) {\n    this.opcodes.push({\n      opcode: name,\n      args: slice.call(arguments, 1),\n      loc: this.sourceNode[0].loc\n    });\n  },\n  addDepth: function addDepth(depth) {\n    if (!depth) {\n      return;\n    }\n    this.useDepths = true;\n  },\n  classifySexpr: function classifySexpr(sexpr) {\n    var isSimple = _ast2['default'].helpers.simpleId(sexpr.path);\n    var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);\n\n    // a mustache is an eligible helper if:\n    // * its id is simple (a single part, not `this` or `..`)\n    var isHelper = !isBlockParam && _ast2['default'].helpers.helperExpression(sexpr);\n\n    // if a mustache is an eligible helper but not a definite\n    // helper, it is ambiguous, and will be resolved in a later\n    // pass or at runtime.\n    var isEligible = !isBlockParam && (isHelper || isSimple);\n\n    // if ambiguous, we can possibly resolve the ambiguity now\n    // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.\n    if (isEligible && !isHelper) {\n      var _name = sexpr.path.parts[0],\n        options = this.options;\n      if (options.knownHelpers[_name]) {\n        isHelper = true;\n      } else if (options.knownHelpersOnly) {\n        isEligible = false;\n      }\n    }\n    if (isHelper) {\n      return 'helper';\n    } else if (isEligible) {\n      return 'ambiguous';\n    } else {\n      return 'simple';\n    }\n  },\n  pushParams: function pushParams(params) {\n    for (var i = 0, l = params.length; i < l; i++) {\n      this.pushParam(params[i]);\n    }\n  },\n  pushParam: function pushParam(val) {\n    var value = val.value != null ? val.value : val.original || '';\n    if (this.stringParams) {\n      if (value.replace) {\n        value = value.replace(/^(\\.?\\.\\/)*/g, '').replace(/\\//g, '.');\n      }\n      if (val.depth) {\n        this.addDepth(val.depth);\n      }\n      this.opcode('getContext', val.depth || 0);\n      this.opcode('pushStringParam', value, val.type);\n      if (val.type === 'SubExpression') {\n        // SubExpressions get evaluated and passed in\n        // in string params mode.\n        this.accept(val);\n      }\n    } else {\n      if (this.trackIds) {\n        var blockParamIndex = undefined;\n        if (val.parts && !_ast2['default'].helpers.scopedId(val) && !val.depth) {\n          blockParamIndex = this.blockParamIndex(val.parts[0]);\n        }\n        if (blockParamIndex) {\n          var blockParamChild = val.parts.slice(1).join('.');\n          this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);\n        } else {\n          value = val.original || value;\n          if (value.replace) {\n            value = value.replace(/^this(?:\\.|$)/, '').replace(/^\\.\\//, '').replace(/^\\.$/, '');\n          }\n          this.opcode('pushId', val.type, value);\n        }\n      }\n      this.accept(val);\n    }\n  },\n  setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {\n    var params = sexpr.params;\n    this.pushParams(params);\n    this.opcode('pushProgram', program);\n    this.opcode('pushProgram', inverse);\n    if (sexpr.hash) {\n      this.accept(sexpr.hash);\n    } else {\n      this.opcode('emptyHash', omitEmpty);\n    }\n    return params;\n  },\n  blockParamIndex: function blockParamIndex(name) {\n    for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {\n      var blockParams = this.options.blockParams[depth],\n        param = blockParams && _utils.indexOf(blockParams, name);\n      if (blockParams && param >= 0) {\n        return [depth, param];\n      }\n    }\n  }\n};\nfunction precompile(input, options, env) {\n  if (input == null || typeof input !== 'string' && input.type !== 'Program') {\n    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);\n  }\n  options = options || {};\n  if (!('data' in options)) {\n    options.data = true;\n  }\n  if (options.compat) {\n    options.useDepths = true;\n  }\n  var ast = env.parse(input, options),\n    environment = new env.Compiler().compile(ast, options);\n  return new env.JavaScriptCompiler().compile(environment, options);\n}\nfunction compile(input, options, env) {\n  if (options === undefined) options = {};\n  if (input == null || typeof input !== 'string' && input.type !== 'Program') {\n    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);\n  }\n  options = _utils.extend({}, options);\n  if (!('data' in options)) {\n    options.data = true;\n  }\n  if (options.compat) {\n    options.useDepths = true;\n  }\n  var compiled = undefined;\n  function compileInput() {\n    var ast = env.parse(input, options),\n      environment = new env.Compiler().compile(ast, options),\n      templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);\n    return env.template(templateSpec);\n  }\n\n  // Template is only compiled on first use and cached after that point.\n  function ret(context, execOptions) {\n    if (!compiled) {\n      compiled = compileInput();\n    }\n    return compiled.call(this, context, execOptions);\n  }\n  ret._setup = function (setupOptions) {\n    if (!compiled) {\n      compiled = compileInput();\n    }\n    return compiled._setup(setupOptions);\n  };\n  ret._child = function (i, data, blockParams, depths) {\n    if (!compiled) {\n      compiled = compileInput();\n    }\n    return compiled._child(i, data, blockParams, depths);\n  };\n  return ret;\n}\nfunction argEquals(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {\n    for (var i = 0; i < a.length; i++) {\n      if (!argEquals(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\nfunction transformLiteralToPath(sexpr) {\n  if (!sexpr.path.parts) {\n    var literal = sexpr.path;\n    // Casting to string here to make false and 0 literal values play nicely with the rest\n    // of the system.\n    sexpr.path = {\n      type: 'PathExpression',\n      data: false,\n      depth: 0,\n      parts: [literal.original + ''],\n      original: literal.original + '',\n      loc: literal.loc\n    };\n  }\n}","map":{"version":3,"mappings":"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","names":["slice","Compiler","prototype","compiler","equals","other","len","opcodes","length","i","opcode","otherOpcode","argEquals","args","children","guid","compile","program","options","sourceNode","stringParams","trackIds","blockParams","knownHelpers","_utils","Object","create","helperMissing","blockHelperMissing","each","unless","log","lookup","accept","compileProgram","childCompiler","result","usePartial","useDepths","node","type","unshift","ret","shift","Program","body","bodyLength","isSimple","BlockStatement","block","transformLiteralToPath","inverse","classifySexpr","helperSexpr","simpleSexpr","path","original","ambiguousSexpr","DecoratorBlock","decorator","params","setupFullMustacheParams","undefined","useDecorators","PartialStatement","partial","explicitPartialContext","push","parts","depth","partialName","name","isDynamic","indent","preventIndent","PartialBlockStatement","partialBlock","MustacheStatement","mustache","SubExpression","escaped","noEscape","Decorator","ContentStatement","content","value","CommentStatement","sexpr","isBlock","strict","knownHelpersOnly","falsy","_ast2","helpers","simpleId","PathExpression","addDepth","scoped","scopedId","blockParamId","blockParamIndex","data","StringLiteral","string","NumberLiteral","number","BooleanLiteral","bool","UndefinedLiteral","NullLiteral","Hash","hash","pairs","l","pushParam","key","call","arguments","loc","isBlockParam","isHelper","helperExpression","isEligible","_name","pushParams","val","replace","blockParamChild","join","omitEmpty","param","precompile","input","env","compat","ast","parse","environment","JavaScriptCompiler","compiled","compileInput","templateSpec","template","context","execOptions","_setup","setupOptions","_child","depths","a","b","literal"],"sources":["../../../../lib/handlebars/compiler/compiler.js"],"sourcesContent":["/* eslint-disable new-cap */\n\nimport Exception from '../exception';\nimport { isArray, indexOf, extend } from '../utils';\nimport AST from './ast';\n\nconst slice = [].slice;\n\nexport function Compiler() {}\n\n// the foundHelper register will disambiguate helper lookup from finding a\n// function in a context. This is necessary for mustache compatibility, which\n// requires that context functions in blocks are evaluated by blockHelperMissing,\n// and then proceed as if the resulting value was provided to blockHelperMissing.\n\nCompiler.prototype = {\n  compiler: Compiler,\n\n  equals: function(other) {\n    let len = this.opcodes.length;\n    if (other.opcodes.length !== len) {\n      return false;\n    }\n\n    for (let i = 0; i < len; i++) {\n      let opcode = this.opcodes[i],\n        otherOpcode = other.opcodes[i];\n      if (\n        opcode.opcode !== otherOpcode.opcode ||\n        !argEquals(opcode.args, otherOpcode.args)\n      ) {\n        return false;\n      }\n    }\n\n    // We know that length is the same between the two arrays because they are directly tied\n    // to the opcode behavior above.\n    len = this.children.length;\n    for (let i = 0; i < len; i++) {\n      if (!this.children[i].equals(other.children[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  guid: 0,\n\n  compile: function(program, options) {\n    this.sourceNode = [];\n    this.opcodes = [];\n    this.children = [];\n    this.options = options;\n    this.stringParams = options.stringParams;\n    this.trackIds = options.trackIds;\n\n    options.blockParams = options.blockParams || [];\n\n    options.knownHelpers = extend(\n      Object.create(null),\n      {\n        helperMissing: true,\n        blockHelperMissing: true,\n        each: true,\n        if: true,\n        unless: true,\n        with: true,\n        log: true,\n        lookup: true\n      },\n      options.knownHelpers\n    );\n\n    return this.accept(program);\n  },\n\n  compileProgram: function(program) {\n    let childCompiler = new this.compiler(), // eslint-disable-line new-cap\n      result = childCompiler.compile(program, this.options),\n      guid = this.guid++;\n\n    this.usePartial = this.usePartial || result.usePartial;\n\n    this.children[guid] = result;\n    this.useDepths = this.useDepths || result.useDepths;\n\n    return guid;\n  },\n\n  accept: function(node) {\n    /* istanbul ignore next: Sanity code */\n    if (!this[node.type]) {\n      throw new Exception('Unknown type: ' + node.type, node);\n    }\n\n    this.sourceNode.unshift(node);\n    let ret = this[node.type](node);\n    this.sourceNode.shift();\n    return ret;\n  },\n\n  Program: function(program) {\n    this.options.blockParams.unshift(program.blockParams);\n\n    let body = program.body,\n      bodyLength = body.length;\n    for (let i = 0; i < bodyLength; i++) {\n      this.accept(body[i]);\n    }\n\n    this.options.blockParams.shift();\n\n    this.isSimple = bodyLength === 1;\n    this.blockParams = program.blockParams ? program.blockParams.length : 0;\n\n    return this;\n  },\n\n  BlockStatement: function(block) {\n    transformLiteralToPath(block);\n\n    let program = block.program,\n      inverse = block.inverse;\n\n    program = program && this.compileProgram(program);\n    inverse = inverse && this.compileProgram(inverse);\n\n    let type = this.classifySexpr(block);\n\n    if (type === 'helper') {\n      this.helperSexpr(block, program, inverse);\n    } else if (type === 'simple') {\n      this.simpleSexpr(block);\n\n      // now that the simple mustache is resolved, we need to\n      // evaluate it by executing `blockHelperMissing`\n      this.opcode('pushProgram', program);\n      this.opcode('pushProgram', inverse);\n      this.opcode('emptyHash');\n      this.opcode('blockValue', block.path.original);\n    } else {\n      this.ambiguousSexpr(block, program, inverse);\n\n      // now that the simple mustache is resolved, we need to\n      // evaluate it by executing `blockHelperMissing`\n      this.opcode('pushProgram', program);\n      this.opcode('pushProgram', inverse);\n      this.opcode('emptyHash');\n      this.opcode('ambiguousBlockValue');\n    }\n\n    this.opcode('append');\n  },\n\n  DecoratorBlock(decorator) {\n    let program = decorator.program && this.compileProgram(decorator.program);\n    let params = this.setupFullMustacheParams(decorator, program, undefined),\n      path = decorator.path;\n\n    this.useDecorators = true;\n    this.opcode('registerDecorator', params.length, path.original);\n  },\n\n  PartialStatement: function(partial) {\n    this.usePartial = true;\n\n    let program = partial.program;\n    if (program) {\n      program = this.compileProgram(partial.program);\n    }\n\n    let params = partial.params;\n    if (params.length > 1) {\n      throw new Exception(\n        'Unsupported number of partial arguments: ' + params.length,\n        partial\n      );\n    } else if (!params.length) {\n      if (this.options.explicitPartialContext) {\n        this.opcode('pushLiteral', 'undefined');\n      } else {\n        params.push({ type: 'PathExpression', parts: [], depth: 0 });\n      }\n    }\n\n    let partialName = partial.name.original,\n      isDynamic = partial.name.type === 'SubExpression';\n    if (isDynamic) {\n      this.accept(partial.name);\n    }\n\n    this.setupFullMustacheParams(partial, program, undefined, true);\n\n    let indent = partial.indent || '';\n    if (this.options.preventIndent && indent) {\n      this.opcode('appendContent', indent);\n      indent = '';\n    }\n\n    this.opcode('invokePartial', isDynamic, partialName, indent);\n    this.opcode('append');\n  },\n  PartialBlockStatement: function(partialBlock) {\n    this.PartialStatement(partialBlock);\n  },\n\n  MustacheStatement: function(mustache) {\n    this.SubExpression(mustache);\n\n    if (mustache.escaped && !this.options.noEscape) {\n      this.opcode('appendEscaped');\n    } else {\n      this.opcode('append');\n    }\n  },\n  Decorator(decorator) {\n    this.DecoratorBlock(decorator);\n  },\n\n  ContentStatement: function(content) {\n    if (content.value) {\n      this.opcode('appendContent', content.value);\n    }\n  },\n\n  CommentStatement: function() {},\n\n  SubExpression: function(sexpr) {\n    transformLiteralToPath(sexpr);\n    let type = this.classifySexpr(sexpr);\n\n    if (type === 'simple') {\n      this.simpleSexpr(sexpr);\n    } else if (type === 'helper') {\n      this.helperSexpr(sexpr);\n    } else {\n      this.ambiguousSexpr(sexpr);\n    }\n  },\n  ambiguousSexpr: function(sexpr, program, inverse) {\n    let path = sexpr.path,\n      name = path.parts[0],\n      isBlock = program != null || inverse != null;\n\n    this.opcode('getContext', path.depth);\n\n    this.opcode('pushProgram', program);\n    this.opcode('pushProgram', inverse);\n\n    path.strict = true;\n    this.accept(path);\n\n    this.opcode('invokeAmbiguous', name, isBlock);\n  },\n\n  simpleSexpr: function(sexpr) {\n    let path = sexpr.path;\n    path.strict = true;\n    this.accept(path);\n    this.opcode('resolvePossibleLambda');\n  },\n\n  helperSexpr: function(sexpr, program, inverse) {\n    let params = this.setupFullMustacheParams(sexpr, program, inverse),\n      path = sexpr.path,\n      name = path.parts[0];\n\n    if (this.options.knownHelpers[name]) {\n      this.opcode('invokeKnownHelper', params.length, name);\n    } else if (this.options.knownHelpersOnly) {\n      throw new Exception(\n        'You specified knownHelpersOnly, but used the unknown helper ' + name,\n        sexpr\n      );\n    } else {\n      path.strict = true;\n      path.falsy = true;\n\n      this.accept(path);\n      this.opcode(\n        'invokeHelper',\n        params.length,\n        path.original,\n        AST.helpers.simpleId(path)\n      );\n    }\n  },\n\n  PathExpression: function(path) {\n    this.addDepth(path.depth);\n    this.opcode('getContext', path.depth);\n\n    let name = path.parts[0],\n      scoped = AST.helpers.scopedId(path),\n      blockParamId = !path.depth && !scoped && this.blockParamIndex(name);\n\n    if (blockParamId) {\n      this.opcode('lookupBlockParam', blockParamId, path.parts);\n    } else if (!name) {\n      // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`\n      this.opcode('pushContext');\n    } else if (path.data) {\n      this.options.data = true;\n      this.opcode('lookupData', path.depth, path.parts, path.strict);\n    } else {\n      this.opcode(\n        'lookupOnContext',\n        path.parts,\n        path.falsy,\n        path.strict,\n        scoped\n      );\n    }\n  },\n\n  StringLiteral: function(string) {\n    this.opcode('pushString', string.value);\n  },\n\n  NumberLiteral: function(number) {\n    this.opcode('pushLiteral', number.value);\n  },\n\n  BooleanLiteral: function(bool) {\n    this.opcode('pushLiteral', bool.value);\n  },\n\n  UndefinedLiteral: function() {\n    this.opcode('pushLiteral', 'undefined');\n  },\n\n  NullLiteral: function() {\n    this.opcode('pushLiteral', 'null');\n  },\n\n  Hash: function(hash) {\n    let pairs = hash.pairs,\n      i = 0,\n      l = pairs.length;\n\n    this.opcode('pushHash');\n\n    for (; i < l; i++) {\n      this.pushParam(pairs[i].value);\n    }\n    while (i--) {\n      this.opcode('assignToHash', pairs[i].key);\n    }\n    this.opcode('popHash');\n  },\n\n  // HELPERS\n  opcode: function(name) {\n    this.opcodes.push({\n      opcode: name,\n      args: slice.call(arguments, 1),\n      loc: this.sourceNode[0].loc\n    });\n  },\n\n  addDepth: function(depth) {\n    if (!depth) {\n      return;\n    }\n\n    this.useDepths = true;\n  },\n\n  classifySexpr: function(sexpr) {\n    let isSimple = AST.helpers.simpleId(sexpr.path);\n\n    let isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);\n\n    // a mustache is an eligible helper if:\n    // * its id is simple (a single part, not `this` or `..`)\n    let isHelper = !isBlockParam && AST.helpers.helperExpression(sexpr);\n\n    // if a mustache is an eligible helper but not a definite\n    // helper, it is ambiguous, and will be resolved in a later\n    // pass or at runtime.\n    let isEligible = !isBlockParam && (isHelper || isSimple);\n\n    // if ambiguous, we can possibly resolve the ambiguity now\n    // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.\n    if (isEligible && !isHelper) {\n      let name = sexpr.path.parts[0],\n        options = this.options;\n      if (options.knownHelpers[name]) {\n        isHelper = true;\n      } else if (options.knownHelpersOnly) {\n        isEligible = false;\n      }\n    }\n\n    if (isHelper) {\n      return 'helper';\n    } else if (isEligible) {\n      return 'ambiguous';\n    } else {\n      return 'simple';\n    }\n  },\n\n  pushParams: function(params) {\n    for (let i = 0, l = params.length; i < l; i++) {\n      this.pushParam(params[i]);\n    }\n  },\n\n  pushParam: function(val) {\n    let value = val.value != null ? val.value : val.original || '';\n\n    if (this.stringParams) {\n      if (value.replace) {\n        value = value.replace(/^(\\.?\\.\\/)*/g, '').replace(/\\//g, '.');\n      }\n\n      if (val.depth) {\n        this.addDepth(val.depth);\n      }\n      this.opcode('getContext', val.depth || 0);\n      this.opcode('pushStringParam', value, val.type);\n\n      if (val.type === 'SubExpression') {\n        // SubExpressions get evaluated and passed in\n        // in string params mode.\n        this.accept(val);\n      }\n    } else {\n      if (this.trackIds) {\n        let blockParamIndex;\n        if (val.parts && !AST.helpers.scopedId(val) && !val.depth) {\n          blockParamIndex = this.blockParamIndex(val.parts[0]);\n        }\n        if (blockParamIndex) {\n          let blockParamChild = val.parts.slice(1).join('.');\n          this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);\n        } else {\n          value = val.original || value;\n          if (value.replace) {\n            value = value\n              .replace(/^this(?:\\.|$)/, '')\n              .replace(/^\\.\\//, '')\n              .replace(/^\\.$/, '');\n          }\n\n          this.opcode('pushId', val.type, value);\n        }\n      }\n      this.accept(val);\n    }\n  },\n\n  setupFullMustacheParams: function(sexpr, program, inverse, omitEmpty) {\n    let params = sexpr.params;\n    this.pushParams(params);\n\n    this.opcode('pushProgram', program);\n    this.opcode('pushProgram', inverse);\n\n    if (sexpr.hash) {\n      this.accept(sexpr.hash);\n    } else {\n      this.opcode('emptyHash', omitEmpty);\n    }\n\n    return params;\n  },\n\n  blockParamIndex: function(name) {\n    for (\n      let depth = 0, len = this.options.blockParams.length;\n      depth < len;\n      depth++\n    ) {\n      let blockParams = this.options.blockParams[depth],\n        param = blockParams && indexOf(blockParams, name);\n      if (blockParams && param >= 0) {\n        return [depth, param];\n      }\n    }\n  }\n};\n\nexport function precompile(input, options, env) {\n  if (\n    input == null ||\n    (typeof input !== 'string' && input.type !== 'Program')\n  ) {\n    throw new Exception(\n      'You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' +\n        input\n    );\n  }\n\n  options = options || {};\n  if (!('data' in options)) {\n    options.data = true;\n  }\n  if (options.compat) {\n    options.useDepths = true;\n  }\n\n  let ast = env.parse(input, options),\n    environment = new env.Compiler().compile(ast, options);\n  return new env.JavaScriptCompiler().compile(environment, options);\n}\n\nexport function compile(input, options = {}, env) {\n  if (\n    input == null ||\n    (typeof input !== 'string' && input.type !== 'Program')\n  ) {\n    throw new Exception(\n      'You must pass a string or Handlebars AST to Handlebars.compile. You passed ' +\n        input\n    );\n  }\n\n  options = extend({}, options);\n  if (!('data' in options)) {\n    options.data = true;\n  }\n  if (options.compat) {\n    options.useDepths = true;\n  }\n\n  let compiled;\n\n  function compileInput() {\n    let ast = env.parse(input, options),\n      environment = new env.Compiler().compile(ast, options),\n      templateSpec = new env.JavaScriptCompiler().compile(\n        environment,\n        options,\n        undefined,\n        true\n      );\n    return env.template(templateSpec);\n  }\n\n  // Template is only compiled on first use and cached after that point.\n  function ret(context, execOptions) {\n    if (!compiled) {\n      compiled = compileInput();\n    }\n    return compiled.call(this, context, execOptions);\n  }\n  ret._setup = function(setupOptions) {\n    if (!compiled) {\n      compiled = compileInput();\n    }\n    return compiled._setup(setupOptions);\n  };\n  ret._child = function(i, data, blockParams, depths) {\n    if (!compiled) {\n      compiled = compileInput();\n    }\n    return compiled._child(i, data, blockParams, depths);\n  };\n  return ret;\n}\n\nfunction argEquals(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (isArray(a) && isArray(b) && a.length === b.length) {\n    for (let i = 0; i < a.length; i++) {\n      if (!argEquals(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\nfunction transformLiteralToPath(sexpr) {\n  if (!sexpr.path.parts) {\n    let literal = sexpr.path;\n    // Casting to string here to make false and 0 literal values play nicely with the rest\n    // of the system.\n    sexpr.path = {\n      type: 'PathExpression',\n      data: false,\n      depth: 0,\n      parts: [literal.original + ''],\n      original: literal.original + '',\n      loc: literal.loc\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"script"}