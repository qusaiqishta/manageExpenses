{"ast":null,"code":"/**\n * Tracks replacements done on a string and expose utility to patch replacements.\n *\n * @note due to performance reasons, it doesn't store the original string or\n * perform ops on the string.\n *\n * @private\n * @constructor\n */\nclass ReplacementTracker {\n  constructor() {\n    this.replacements = [];\n    this._offset = 0;\n    this._length = 0;\n  }\n\n  /**\n   * Add new replacement to track.\n   *\n   * @param {String} value -\n   * @param {Number} index -\n   */\n  add(value, index) {\n    this.replacements.push({\n      value: value,\n      index: index - this._offset\n    });\n    this._offset += value.length - 1; // - 1 replaced character\n    this._length++;\n  }\n\n  /**\n   * Returns the total number of replacements.\n   *\n   * @returns {Number}\n   */\n  count() {\n    return this._length;\n  }\n\n  /**\n   * Finds the lower index of replacement position for a given value using inexact\n   * binary search.\n   *\n   * @private\n   * @param {Number} index -\n   * @returns {Number}\n   */\n  _findLowerIndex(index) {\n    let length = this.count(),\n      start = 0,\n      end = length - 1,\n      mid;\n    while (start <= end) {\n      mid = start + end >> 1; // divide by 2\n\n      if (this.replacements[mid].index >= index) {\n        end = mid - 1;\n      } else {\n        start = mid + 1;\n      }\n    }\n    return start >= length ? -1 : start;\n  }\n\n  /**\n   * Patches a given string by apply all the applicable replacements done in the\n   * given range.\n   *\n   * @private\n   * @param {String} input -\n   * @param {Number} beginIndex -\n   * @param {Number} endIndex -\n   * @returns {String}\n   */\n  _applyInString(input, beginIndex, endIndex) {\n    let index,\n      replacement,\n      replacementIndex,\n      replacementValue,\n      offset = 0,\n      length = this.count();\n\n    // bail out if no replacements are done in the given range OR empty string\n    if (!input || (index = this._findLowerIndex(beginIndex)) === -1) {\n      return input;\n    }\n    do {\n      replacement = this.replacements[index];\n      replacementIndex = replacement.index;\n      replacementValue = replacement.value;\n\n      // bail out if all the replacements are done in the given range\n      if (replacementIndex >= endIndex) {\n        break;\n      }\n      replacementIndex = offset + replacementIndex - beginIndex;\n      input = input.slice(0, replacementIndex) + replacementValue + input.slice(replacementIndex + 1);\n      offset += replacementValue.length - 1;\n    } while (++index < length);\n    return input;\n  }\n\n  /**\n   * Patches a given string or array of strings by apply all the applicable\n   * replacements done in the given range.\n   *\n   * @param {String|String[]} input -\n   * @param {Number} beginIndex -\n   * @param {Number} endIndex -\n   * @returns {String|String[]}\n   */\n  apply(input, beginIndex, endIndex) {\n    let i,\n      ii,\n      length,\n      _endIndex,\n      _beginIndex,\n      value = input;\n\n    // apply replacements in string\n    if (typeof input === 'string') {\n      return this._applyInString(input, beginIndex, endIndex);\n    }\n\n    // apply replacements in the splitted string (Array)\n    _beginIndex = beginIndex;\n\n    // traverse all the segments until all the replacements are patched\n    for (i = 0, ii = input.length; i < ii; ++i) {\n      value = input[i];\n      _endIndex = _beginIndex + (length = value.length);\n\n      // apply replacements applicable for individual segment\n      input[i] = this._applyInString(value, _beginIndex, _endIndex);\n      _beginIndex += length + 1; // + 1 separator\n    }\n\n    return input;\n  }\n}\nmodule.exports = ReplacementTracker;","map":{"version":3,"names":["ReplacementTracker","constructor","replacements","_offset","_length","add","value","index","push","length","count","_findLowerIndex","start","end","mid","_applyInString","input","beginIndex","endIndex","replacement","replacementIndex","replacementValue","offset","slice","apply","i","ii","_endIndex","_beginIndex","module","exports"],"sources":["/Users/Qusai.Qishta/node_modules/postman-url-encoder/parser/replacement-tracker.js"],"sourcesContent":["\n/**\n * Tracks replacements done on a string and expose utility to patch replacements.\n *\n * @note due to performance reasons, it doesn't store the original string or\n * perform ops on the string.\n *\n * @private\n * @constructor\n */\nclass ReplacementTracker {\n    constructor () {\n        this.replacements = [];\n        this._offset = 0;\n        this._length = 0;\n    }\n\n    /**\n     * Add new replacement to track.\n     *\n     * @param {String} value -\n     * @param {Number} index -\n     */\n    add (value, index) {\n        this.replacements.push({\n            value: value,\n            index: index - this._offset\n        });\n\n        this._offset += value.length - 1; // - 1 replaced character\n        this._length++;\n    }\n\n    /**\n     * Returns the total number of replacements.\n     *\n     * @returns {Number}\n     */\n    count () {\n        return this._length;\n    }\n\n    /**\n     * Finds the lower index of replacement position for a given value using inexact\n     * binary search.\n     *\n     * @private\n     * @param {Number} index -\n     * @returns {Number}\n     */\n    _findLowerIndex (index) {\n        let length = this.count(),\n            start = 0,\n            end = length - 1,\n            mid;\n\n        while (start <= end) {\n            mid = (start + end) >> 1; // divide by 2\n\n            if (this.replacements[mid].index >= index) {\n                end = mid - 1;\n            }\n            else {\n                start = mid + 1;\n            }\n        }\n\n        return start >= length ? -1 : start;\n    }\n\n    /**\n     * Patches a given string by apply all the applicable replacements done in the\n     * given range.\n     *\n     * @private\n     * @param {String} input -\n     * @param {Number} beginIndex -\n     * @param {Number} endIndex -\n     * @returns {String}\n     */\n    _applyInString (input, beginIndex, endIndex) {\n        let index,\n            replacement,\n            replacementIndex,\n            replacementValue,\n            offset = 0,\n            length = this.count();\n\n        // bail out if no replacements are done in the given range OR empty string\n        if (!input || (index = this._findLowerIndex(beginIndex)) === -1) {\n            return input;\n        }\n\n        do {\n            replacement = this.replacements[index];\n            replacementIndex = replacement.index;\n            replacementValue = replacement.value;\n\n            // bail out if all the replacements are done in the given range\n            if (replacementIndex >= endIndex) {\n                break;\n            }\n\n            replacementIndex = offset + replacementIndex - beginIndex;\n            input = input.slice(0, replacementIndex) + replacementValue + input.slice(replacementIndex + 1);\n            offset += replacementValue.length - 1;\n        } while (++index < length);\n\n        return input;\n    }\n\n    /**\n     * Patches a given string or array of strings by apply all the applicable\n     * replacements done in the given range.\n     *\n     * @param {String|String[]} input -\n     * @param {Number} beginIndex -\n     * @param {Number} endIndex -\n     * @returns {String|String[]}\n     */\n    apply (input, beginIndex, endIndex) {\n        let i,\n            ii,\n            length,\n            _endIndex,\n            _beginIndex,\n            value = input;\n\n        // apply replacements in string\n        if (typeof input === 'string') {\n            return this._applyInString(input, beginIndex, endIndex);\n        }\n\n        // apply replacements in the splitted string (Array)\n        _beginIndex = beginIndex;\n\n        // traverse all the segments until all the replacements are patched\n        for (i = 0, ii = input.length; i < ii; ++i) {\n            value = input[i];\n            _endIndex = _beginIndex + (length = value.length);\n\n            // apply replacements applicable for individual segment\n            input[i] = this._applyInString(value, _beginIndex, _endIndex);\n            _beginIndex += length + 1; // + 1 separator\n        }\n\n        return input;\n    }\n}\n\nmodule.exports = ReplacementTracker;\n"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,kBAAkB,CAAC;EACrBC,WAAW,GAAI;IACX,IAAI,CAACC,YAAY,GAAG,EAAE;IACtB,IAAI,CAACC,OAAO,GAAG,CAAC;IAChB,IAAI,CAACC,OAAO,GAAG,CAAC;EACpB;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACIC,GAAG,CAAEC,KAAK,EAAEC,KAAK,EAAE;IACf,IAAI,CAACL,YAAY,CAACM,IAAI,CAAC;MACnBF,KAAK,EAAEA,KAAK;MACZC,KAAK,EAAEA,KAAK,GAAG,IAAI,CAACJ;IACxB,CAAC,CAAC;IAEF,IAAI,CAACA,OAAO,IAAIG,KAAK,CAACG,MAAM,GAAG,CAAC,CAAC,CAAC;IAClC,IAAI,CAACL,OAAO,EAAE;EAClB;;EAEA;AACJ;AACA;AACA;AACA;EACIM,KAAK,GAAI;IACL,OAAO,IAAI,CAACN,OAAO;EACvB;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIO,eAAe,CAAEJ,KAAK,EAAE;IACpB,IAAIE,MAAM,GAAG,IAAI,CAACC,KAAK,EAAE;MACrBE,KAAK,GAAG,CAAC;MACTC,GAAG,GAAGJ,MAAM,GAAG,CAAC;MAChBK,GAAG;IAEP,OAAOF,KAAK,IAAIC,GAAG,EAAE;MACjBC,GAAG,GAAIF,KAAK,GAAGC,GAAG,IAAK,CAAC,CAAC,CAAC;;MAE1B,IAAI,IAAI,CAACX,YAAY,CAACY,GAAG,CAAC,CAACP,KAAK,IAAIA,KAAK,EAAE;QACvCM,GAAG,GAAGC,GAAG,GAAG,CAAC;MACjB,CAAC,MACI;QACDF,KAAK,GAAGE,GAAG,GAAG,CAAC;MACnB;IACJ;IAEA,OAAOF,KAAK,IAAIH,MAAM,GAAG,CAAC,CAAC,GAAGG,KAAK;EACvC;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIG,cAAc,CAAEC,KAAK,EAAEC,UAAU,EAAEC,QAAQ,EAAE;IACzC,IAAIX,KAAK;MACLY,WAAW;MACXC,gBAAgB;MAChBC,gBAAgB;MAChBC,MAAM,GAAG,CAAC;MACVb,MAAM,GAAG,IAAI,CAACC,KAAK,EAAE;;IAEzB;IACA,IAAI,CAACM,KAAK,IAAI,CAACT,KAAK,GAAG,IAAI,CAACI,eAAe,CAACM,UAAU,CAAC,MAAM,CAAC,CAAC,EAAE;MAC7D,OAAOD,KAAK;IAChB;IAEA,GAAG;MACCG,WAAW,GAAG,IAAI,CAACjB,YAAY,CAACK,KAAK,CAAC;MACtCa,gBAAgB,GAAGD,WAAW,CAACZ,KAAK;MACpCc,gBAAgB,GAAGF,WAAW,CAACb,KAAK;;MAEpC;MACA,IAAIc,gBAAgB,IAAIF,QAAQ,EAAE;QAC9B;MACJ;MAEAE,gBAAgB,GAAGE,MAAM,GAAGF,gBAAgB,GAAGH,UAAU;MACzDD,KAAK,GAAGA,KAAK,CAACO,KAAK,CAAC,CAAC,EAAEH,gBAAgB,CAAC,GAAGC,gBAAgB,GAAGL,KAAK,CAACO,KAAK,CAACH,gBAAgB,GAAG,CAAC,CAAC;MAC/FE,MAAM,IAAID,gBAAgB,CAACZ,MAAM,GAAG,CAAC;IACzC,CAAC,QAAQ,EAAEF,KAAK,GAAGE,MAAM;IAEzB,OAAOO,KAAK;EAChB;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIQ,KAAK,CAAER,KAAK,EAAEC,UAAU,EAAEC,QAAQ,EAAE;IAChC,IAAIO,CAAC;MACDC,EAAE;MACFjB,MAAM;MACNkB,SAAS;MACTC,WAAW;MACXtB,KAAK,GAAGU,KAAK;;IAEjB;IACA,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;MAC3B,OAAO,IAAI,CAACD,cAAc,CAACC,KAAK,EAAEC,UAAU,EAAEC,QAAQ,CAAC;IAC3D;;IAEA;IACAU,WAAW,GAAGX,UAAU;;IAExB;IACA,KAAKQ,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGV,KAAK,CAACP,MAAM,EAAEgB,CAAC,GAAGC,EAAE,EAAE,EAAED,CAAC,EAAE;MACxCnB,KAAK,GAAGU,KAAK,CAACS,CAAC,CAAC;MAChBE,SAAS,GAAGC,WAAW,IAAInB,MAAM,GAAGH,KAAK,CAACG,MAAM,CAAC;;MAEjD;MACAO,KAAK,CAACS,CAAC,CAAC,GAAG,IAAI,CAACV,cAAc,CAACT,KAAK,EAAEsB,WAAW,EAAED,SAAS,CAAC;MAC7DC,WAAW,IAAInB,MAAM,GAAG,CAAC,CAAC,CAAC;IAC/B;;IAEA,OAAOO,KAAK;EAChB;AACJ;AAEAa,MAAM,CAACC,OAAO,GAAG9B,kBAAkB"},"metadata":{},"sourceType":"script"}