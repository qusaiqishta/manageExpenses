{"ast":null,"code":"var _ = require('lodash'),\n  async = require('async'),\n  util = require('./util'),\n  sdk = require('postman-collection'),\n  createAuthInterface = require('../authorizer/auth-interface'),\n  AuthLoader = require('../authorizer/index').AuthLoader,\n  ReplayController = require('./replay-controller'),\n  DOT_AUTH = '.auth';\nmodule.exports = [\n// File loading\nfunction (context, run, done) {\n  if (!context.item) {\n    return done(new Error('Nothing to resolve files for.'));\n  }\n  var triggers = run.triggers,\n    cursor = context.coords,\n    resolver = run.options.fileResolver,\n    request = context.item && context.item.request,\n    mode,\n    data;\n  if (!request) {\n    return done(new Error('No request to send.'));\n  }\n\n  // if body is disabled than skip loading files.\n  // @todo this may cause problem if body is enabled/disabled programmatically from pre-request script.\n  if (request.body && request.body.disabled) {\n    return done();\n  }\n\n  // todo: add helper functions in the sdk to do this cleanly for us\n  mode = _.get(request, 'body.mode');\n  data = _.get(request, ['body', mode]);\n\n  // if there is no mode specified, or no data for the specified mode we cannot resolve anything!\n  // @note that if source is not readable, there is no point reading anything, yet we need to warn that file\n  // upload was not done. hence we will have to proceed even without an unreadable source\n  if (!data) {\n    // we do not need to check `mode` here since false mode returns no `data`\n    return done();\n  }\n\n  // in this block, we simply use async.waterfall to ensure that all form of file reading is async. essentially,\n  // we first determine the data mode and based on it pass the waterfall functions.\n  async.waterfall([async.constant(data), {\n    // form data parsing simply \"enriches\" all form parameters having file data type by replacing / setting the\n    // value as a read stream\n    formdata(formdata, next) {\n      // ensure that we only process the file type\n      async.eachSeries(_.filter(formdata.all(), {\n        type: 'file'\n      }), function (formparam, callback) {\n        if (!formparam || formparam.disabled) {\n          return callback(); // disabled params will be filtered in body-builder.\n        }\n\n        var paramIsComposite = Array.isArray(formparam.src),\n          onLoadError = function (err, disableParam) {\n            // triggering a warning message for the user\n            triggers.console(cursor, 'warn', `Form param \\`${formparam.key}\\`, file load error: ${err.message || err}`);\n\n            // set disabled, it will be filtered in body-builder\n            disableParam && (formparam.disabled = true);\n          };\n\n        // handle missing file src\n        if (!formparam.src || paramIsComposite && !formparam.src.length) {\n          onLoadError(new Error('missing file source'), false);\n          return callback();\n        }\n\n        // handle form param with a single file\n        // @note we are handling single file first so that we do not need to hit additional complexity of\n        // handling multiple files while the majority use-case would be to handle single file.\n        if (!paramIsComposite) {\n          // eslint-disable-next-line security/detect-non-literal-fs-filename\n          util.createReadStream(resolver, formparam.src, function (err, stream) {\n            if (err) {\n              onLoadError(err, true);\n            } else {\n              formparam.value = stream;\n            }\n            callback();\n          });\n          return;\n        }\n\n        // handle form param with multiple files\n        // @note we use map-limit here instead of free-form map in order to avoid choking the file system\n        // with many parallel descriptor access.\n        async.mapLimit(formparam.src, 10, function (src, next) {\n          // eslint-disable-next-line security/detect-non-literal-fs-filename\n          util.createReadStream(resolver, src, function (err, stream) {\n            if (err) {\n              // @note don't throw error or disable param if one of the src fails to load\n              onLoadError(err);\n              return next(); // swallow the error\n            }\n\n            next(null, {\n              src: src,\n              value: stream\n            });\n          });\n        }, function (err, results) {\n          if (err) {\n            onLoadError(err, true);\n            return done();\n          }\n          _.forEach(results, function (result) {\n            // Insert individual param above the current formparam\n            result && formdata.insert(new sdk.FormParam(_.assign(formparam.toJSON(), result)), formparam);\n          });\n\n          // remove the current formparam after exploding src\n          formdata.remove(formparam);\n          done();\n        });\n      }, next);\n    },\n    // file data\n    file(filedata, next) {\n      // eslint-disable-next-line security/detect-non-literal-fs-filename\n      util.createReadStream(resolver, filedata.src, function (err, stream) {\n        if (err) {\n          triggers.console(cursor, 'warn', 'Binary file load error: ' + err.message || err);\n          filedata.value = null; // ensure this does not mess with requester\n          delete filedata.content; // @todo - why content?\n        } else {\n          filedata.content = stream;\n        }\n        next();\n      });\n    }\n  }[mode] || async.constant()], function (err) {\n    // just as a precaution, show the error in console. each resolver anyway should handle their own console\n    // warnings.\n    // @todo - get cursor here.\n    err && triggers.console(cursor, 'warn', 'file data resolution error: ' + (err.message || err));\n    done(null); // absorb the error since a console has been trigerred\n  });\n},\n// Authorization\nfunction (context, run, done) {\n  // validate all stuff. dont ask.\n  if (!context.item) {\n    return done(new Error('runtime: nothing to authorize.'));\n  }\n\n  // bail out if there is no auth\n  if (!(context.auth && context.auth.type)) {\n    return done(null);\n  }\n\n  // get auth handler\n  var auth = context.auth,\n    authType = auth.type,\n    originalAuth = context.originalItem.getAuth(),\n    originalAuthParams = originalAuth && originalAuth.parameters(),\n    authHandler = AuthLoader.getHandler(authType),\n    authPreHook,\n    authInterface,\n    authSignHook = function () {\n      try {\n        authHandler.sign(authInterface, context.item.request, function (err) {\n          // handle all types of errors in one place, see catch block\n          if (err) {\n            throw err;\n          }\n          done();\n        });\n      } catch (err) {\n        // handles synchronous and asynchronous errors in auth.sign\n        run.triggers.console(context.coords, 'warn', 'runtime~' + authType + '.auth: could not sign the request: ' + (err.message || err), err);\n\n        // swallow the error, we've warned the user\n        done();\n      }\n    };\n\n  // bail out if there is no matching auth handler for the type\n  if (!authHandler) {\n    run.triggers.console(context.coords, 'warn', 'runtime: could not find a handler for auth: ' + auth.type);\n    return done();\n  }\n  authInterface = createAuthInterface(auth, context.protocolProfileBehavior);\n\n  /**\n   * We go through the `pre` request send validation for the auth. In this step one of the three things can happen\n   *\n   * If the Auth `pre` hook\n   * 1. gives a go, we sign the request and proceed to send the request.\n   * 2. gives a no go, we don't sign the request, but proceed to send the request.\n   * 3. gives a no go, with a intermediate request,\n   *      a. we suspend current request, send the intermediate request\n   *      b. invoke Auth `init` hook with the response of the intermediate request\n   *      c. invoke Auth `pre` hook, and repeat from 1\n   */\n  authPreHook = function () {\n    authHandler.pre(authInterface, function (err, success, request) {\n      // there was an error in pre hook of auth\n      if (err) {\n        // warn the user\n        run.triggers.console(context.coords, 'warn', 'runtime~' + authType + '.auth: could not validate the request: ' + (err.message || err), err);\n\n        // swallow the error, we've warned the user\n        return done();\n      }\n\n      // sync all auth system parameters to the original auth\n      originalAuthParams && auth.parameters().each(function (param) {\n        param && param.system && originalAuthParams.upsert({\n          key: param.key,\n          value: param.value,\n          system: true\n        });\n      });\n\n      // authHandler gave a go, sign the request\n      if (success) {\n        return authSignHook();\n      }\n\n      // auth gave a no go, but no intermediate request\n      if (!request) {\n        return done();\n      }\n\n      // prepare for sending intermediate request\n      var replayController = new ReplayController(context.replayState, run),\n        item = new sdk.Item({\n          request\n        });\n\n      // auth handler gave a no go, and an intermediate request.\n      // make the intermediate request the response is passed to `init` hook\n      replayController.requestReplay(context, item,\n      // marks the auth as source for intermediate request\n      {\n        source: auth.type + DOT_AUTH\n      }, function (err, response) {\n        // errors for intermediate requests are passed to request callback\n        // passing it here will add it to original request as well, so don't do it\n        if (err) {\n          return done();\n        }\n\n        // pass the response to Auth `init` hook\n        authHandler.init(authInterface, response, function (error) {\n          if (error) {\n            // warn about the err\n            run.triggers.console(context.coords, 'warn', 'runtime~' + authType + '.auth: ' + 'could not initialize auth: ' + (error.message || error), error);\n\n            // swallow the error, we've warned the user\n            return done();\n          }\n\n          // schedule back to pre hook\n          authPreHook();\n        });\n      }, function (err) {\n        // warn users that maximum retries have exceeded\n        if (err) {\n          run.triggers.console(context.coords, 'warn', 'runtime~' + authType + '.auth: ' + (err.message || err));\n        }\n        // but don't bubble up the error with the request\n        done();\n      });\n    });\n  };\n\n  // start the by calling the pre hook of the auth\n  authPreHook();\n},\n// Proxy lookup\nfunction (context, run, done) {\n  var proxies = run.options.proxies,\n    request = context.item.request,\n    url;\n  if (!request) {\n    return done(new Error('No request to resolve proxy for.'));\n  }\n  url = request.url && request.url.toString();\n  async.waterfall([\n  // try resolving custom proxies before falling-back to system proxy\n  function (cb) {\n    if (_.isFunction(_.get(proxies, 'resolve'))) {\n      return cb(null, proxies.resolve(url));\n    }\n    return cb(null, undefined);\n  },\n  // fallback to system proxy\n  function (config, cb) {\n    if (config) {\n      return cb(null, config);\n    }\n    return _.isFunction(run.options.systemProxy) ? run.options.systemProxy(url, cb) : cb(null, undefined);\n  }], function (err, config) {\n    if (err) {\n      run.triggers.console(context.coords, 'warn', 'proxy lookup error: ' + (err.message || err));\n    }\n    config && (request.proxy = sdk.ProxyConfig.isProxyConfig(config) ? config : new sdk.ProxyConfig(config));\n    return done();\n  });\n},\n// Certificate lookup + reading from whichever file resolver is provided\nfunction (context, run, done) {\n  var request, pfxPath, keyPath, certPath, fileResolver, certificate;\n\n  // A. Check if we have the file resolver\n  fileResolver = run.options.fileResolver;\n  if (!fileResolver) {\n    return done();\n  } // No point going ahead\n\n  // B. Ensure we have the request\n  request = _.get(context.item, 'request');\n  if (!request) {\n    return done(new Error('No request to resolve certificates for.'));\n  }\n\n  // C. See if any cert should be sent, by performing a URL matching\n  certificate = run.options.certificates && run.options.certificates.resolveOne(request.url);\n  if (!certificate) {\n    return done();\n  }\n\n  // D. Fetch the paths\n  // @todo: check why aren't we reading ca file (why are we not supporting ca file)\n  pfxPath = _.get(certificate, 'pfx.src');\n  keyPath = _.get(certificate, 'key.src');\n  certPath = _.get(certificate, 'cert.src');\n\n  // E. Read from the path, and add the values to the certificate, also associate\n  // the certificate with the current request.\n  async.mapValues({\n    pfx: pfxPath,\n    key: keyPath,\n    cert: certPath\n  }, function (value, key, next) {\n    // bail out if value is not defined\n    // @todo add test with server which only accepts cert file\n    if (!value) {\n      return next();\n    }\n\n    // eslint-disable-next-line security/detect-non-literal-fs-filename\n    fileResolver.readFile(value, function (err, data) {\n      // Swallow the error after triggering a warning message for the user.\n      err && run.triggers.console(context.coords, 'warn', `certificate \"${key}\" load error:  ${err.message || err}`);\n      next(null, data);\n    });\n  }, function (err, fileContents) {\n    if (err) {\n      // Swallow the error after triggering a warning message for the user.\n      run.triggers.console(context.coords, 'warn', 'certificate load error: ' + (err.message || err));\n      return done();\n    }\n    if (fileContents) {\n      !_.isNil(fileContents.pfx) && _.set(certificate, 'pfx.value', fileContents.pfx);\n      !_.isNil(fileContents.key) && _.set(certificate, 'key.value', fileContents.key);\n      !_.isNil(fileContents.cert) && _.set(certificate, 'cert.value', fileContents.cert);\n      (fileContents.cert || fileContents.key || fileContents.pfx) && (request.certificate = certificate);\n    }\n    done();\n  });\n}];","map":{"version":3,"names":["_","require","async","util","sdk","createAuthInterface","AuthLoader","ReplayController","DOT_AUTH","module","exports","context","run","done","item","Error","triggers","cursor","coords","resolver","options","fileResolver","request","mode","data","body","disabled","get","waterfall","constant","formdata","next","eachSeries","filter","all","type","formparam","callback","paramIsComposite","Array","isArray","src","onLoadError","err","disableParam","console","key","message","length","createReadStream","stream","value","mapLimit","results","forEach","result","insert","FormParam","assign","toJSON","remove","file","filedata","content","auth","authType","originalAuth","originalItem","getAuth","originalAuthParams","parameters","authHandler","getHandler","authPreHook","authInterface","authSignHook","sign","protocolProfileBehavior","pre","success","each","param","system","upsert","replayController","replayState","Item","requestReplay","source","response","init","error","proxies","url","toString","cb","isFunction","resolve","undefined","config","systemProxy","proxy","ProxyConfig","isProxyConfig","pfxPath","keyPath","certPath","certificate","certificates","resolveOne","mapValues","pfx","cert","readFile","fileContents","isNil","set"],"sources":["/Users/Qusai.Qishta/node_modules/postman-runtime/lib/runner/request-helpers-presend.js"],"sourcesContent":["var _ = require('lodash'),\n    async = require('async'),\n    util = require('./util'),\n    sdk = require('postman-collection'),\n\n    createAuthInterface = require('../authorizer/auth-interface'),\n    AuthLoader = require('../authorizer/index').AuthLoader,\n    ReplayController = require('./replay-controller'),\n\n    DOT_AUTH = '.auth';\n\nmodule.exports = [\n    // File loading\n    function (context, run, done) {\n        if (!context.item) { return done(new Error('Nothing to resolve files for.')); }\n\n        var triggers = run.triggers,\n            cursor = context.coords,\n            resolver = run.options.fileResolver,\n            request = context.item && context.item.request,\n            mode,\n            data;\n\n        if (!request) { return done(new Error('No request to send.')); }\n\n        // if body is disabled than skip loading files.\n        // @todo this may cause problem if body is enabled/disabled programmatically from pre-request script.\n        if (request.body && request.body.disabled) { return done(); }\n\n        // todo: add helper functions in the sdk to do this cleanly for us\n        mode = _.get(request, 'body.mode');\n        data = _.get(request, ['body', mode]);\n\n        // if there is no mode specified, or no data for the specified mode we cannot resolve anything!\n        // @note that if source is not readable, there is no point reading anything, yet we need to warn that file\n        // upload was not done. hence we will have to proceed even without an unreadable source\n        if (!data) { // we do not need to check `mode` here since false mode returns no `data`\n            return done();\n        }\n\n        // in this block, we simply use async.waterfall to ensure that all form of file reading is async. essentially,\n        // we first determine the data mode and based on it pass the waterfall functions.\n        async.waterfall([async.constant(data), {\n            // form data parsing simply \"enriches\" all form parameters having file data type by replacing / setting the\n            // value as a read stream\n            formdata (formdata, next) {\n                // ensure that we only process the file type\n                async.eachSeries(_.filter(formdata.all(), { type: 'file' }), function (formparam, callback) {\n                    if (!formparam || formparam.disabled) {\n                        return callback(); // disabled params will be filtered in body-builder.\n                    }\n\n                    var paramIsComposite = Array.isArray(formparam.src),\n                        onLoadError = function (err, disableParam) {\n                            // triggering a warning message for the user\n                            triggers.console(cursor, 'warn',\n                                `Form param \\`${formparam.key}\\`, file load error: ${err.message || err}`);\n\n                            // set disabled, it will be filtered in body-builder\n                            disableParam && (formparam.disabled = true);\n                        };\n\n                    // handle missing file src\n                    if (!formparam.src || (paramIsComposite && !formparam.src.length)) {\n                        onLoadError(new Error('missing file source'), false);\n\n                        return callback();\n                    }\n\n                    // handle form param with a single file\n                    // @note we are handling single file first so that we do not need to hit additional complexity of\n                    // handling multiple files while the majority use-case would be to handle single file.\n                    if (!paramIsComposite) {\n                        // eslint-disable-next-line security/detect-non-literal-fs-filename\n                        util.createReadStream(resolver, formparam.src, function (err, stream) {\n                            if (err) {\n                                onLoadError(err, true);\n                            }\n                            else {\n                                formparam.value = stream;\n                            }\n\n                            callback();\n                        });\n\n                        return;\n                    }\n\n\n                    // handle form param with multiple files\n                    // @note we use map-limit here instead of free-form map in order to avoid choking the file system\n                    // with many parallel descriptor access.\n                    async.mapLimit(formparam.src, 10, function (src, next) {\n                        // eslint-disable-next-line security/detect-non-literal-fs-filename\n                        util.createReadStream(resolver, src, function (err, stream) {\n                            if (err) {\n                                // @note don't throw error or disable param if one of the src fails to load\n                                onLoadError(err);\n\n                                return next(); // swallow the error\n                            }\n\n                            next(null, { src: src, value: stream });\n                        });\n                    }, function (err, results) {\n                        if (err) {\n                            onLoadError(err, true);\n\n                            return done();\n                        }\n\n                        _.forEach(results, function (result) {\n                            // Insert individual param above the current formparam\n                            result && formdata.insert(new sdk.FormParam(_.assign(formparam.toJSON(), result)),\n                                formparam);\n                        });\n\n                        // remove the current formparam after exploding src\n                        formdata.remove(formparam);\n\n                        done();\n                    });\n                }, next);\n            },\n            // file data\n            file (filedata, next) {\n                // eslint-disable-next-line security/detect-non-literal-fs-filename\n                util.createReadStream(resolver, filedata.src, function (err, stream) {\n                    if (err) {\n                        triggers.console(cursor, 'warn', 'Binary file load error: ' + err.message || err);\n                        filedata.value = null; // ensure this does not mess with requester\n                        delete filedata.content; // @todo - why content?\n                    }\n                    else {\n                        filedata.content = stream;\n                    }\n                    next();\n                });\n            }\n        }[mode] || async.constant()], function (err) {\n            // just as a precaution, show the error in console. each resolver anyway should handle their own console\n            // warnings.\n            // @todo - get cursor here.\n            err && triggers.console(cursor, 'warn', 'file data resolution error: ' + (err.message || err));\n            done(null); // absorb the error since a console has been trigerred\n        });\n    },\n    // Authorization\n    function (context, run, done) {\n        // validate all stuff. dont ask.\n        if (!context.item) { return done(new Error('runtime: nothing to authorize.')); }\n\n        // bail out if there is no auth\n        if (!(context.auth && context.auth.type)) { return done(null); }\n\n        // get auth handler\n        var auth = context.auth,\n            authType = auth.type,\n            originalAuth = context.originalItem.getAuth(),\n            originalAuthParams = originalAuth && originalAuth.parameters(),\n            authHandler = AuthLoader.getHandler(authType),\n            authPreHook,\n            authInterface,\n            authSignHook = function () {\n                try {\n                    authHandler.sign(authInterface, context.item.request, function (err) {\n                        // handle all types of errors in one place, see catch block\n                        if (err) { throw err; }\n\n                        done();\n                    });\n                }\n                catch (err) {\n                    // handles synchronous and asynchronous errors in auth.sign\n                    run.triggers.console(context.coords,\n                        'warn',\n                        'runtime~' + authType + '.auth: could not sign the request: ' + (err.message || err),\n                        err);\n\n                    // swallow the error, we've warned the user\n                    done();\n                }\n            };\n\n        // bail out if there is no matching auth handler for the type\n        if (!authHandler) {\n            run.triggers.console(context.coords, 'warn', 'runtime: could not find a handler for auth: ' + auth.type);\n\n            return done();\n        }\n\n        authInterface = createAuthInterface(auth, context.protocolProfileBehavior);\n\n        /**\n         * We go through the `pre` request send validation for the auth. In this step one of the three things can happen\n         *\n         * If the Auth `pre` hook\n         * 1. gives a go, we sign the request and proceed to send the request.\n         * 2. gives a no go, we don't sign the request, but proceed to send the request.\n         * 3. gives a no go, with a intermediate request,\n         *      a. we suspend current request, send the intermediate request\n         *      b. invoke Auth `init` hook with the response of the intermediate request\n         *      c. invoke Auth `pre` hook, and repeat from 1\n         */\n        authPreHook = function () {\n            authHandler.pre(authInterface, function (err, success, request) {\n                // there was an error in pre hook of auth\n                if (err) {\n                    // warn the user\n                    run.triggers.console(context.coords,\n                        'warn',\n                        'runtime~' + authType + '.auth: could not validate the request: ' + (err.message || err),\n                        err);\n\n                    // swallow the error, we've warned the user\n                    return done();\n                }\n\n                // sync all auth system parameters to the original auth\n                originalAuthParams && auth.parameters().each(function (param) {\n                    param && param.system &&\n                        originalAuthParams.upsert({ key: param.key, value: param.value, system: true });\n                });\n\n                // authHandler gave a go, sign the request\n                if (success) { return authSignHook(); }\n\n                // auth gave a no go, but no intermediate request\n                if (!request) { return done(); }\n\n                // prepare for sending intermediate request\n                var replayController = new ReplayController(context.replayState, run),\n                    item = new sdk.Item({ request });\n\n                // auth handler gave a no go, and an intermediate request.\n                // make the intermediate request the response is passed to `init` hook\n                replayController.requestReplay(context,\n                    item,\n                    // marks the auth as source for intermediate request\n                    { source: auth.type + DOT_AUTH },\n                    function (err, response) {\n                        // errors for intermediate requests are passed to request callback\n                        // passing it here will add it to original request as well, so don't do it\n                        if (err) { return done(); }\n\n                        // pass the response to Auth `init` hook\n                        authHandler.init(authInterface, response, function (error) {\n                            if (error) {\n                                // warn about the err\n                                run.triggers.console(context.coords, 'warn', 'runtime~' + authType + '.auth: ' +\n                                    'could not initialize auth: ' + (error.message || error), error);\n\n                                // swallow the error, we've warned the user\n                                return done();\n                            }\n\n                            // schedule back to pre hook\n                            authPreHook();\n                        });\n                    },\n                    function (err) {\n                        // warn users that maximum retries have exceeded\n                        if (err) {\n                            run.triggers.console(context.coords,\n                                'warn', 'runtime~' + authType + '.auth: ' + (err.message || err));\n                        }\n                        // but don't bubble up the error with the request\n                        done();\n                    });\n            });\n        };\n\n        // start the by calling the pre hook of the auth\n        authPreHook();\n    },\n    // Proxy lookup\n    function (context, run, done) {\n        var proxies = run.options.proxies,\n            request = context.item.request,\n\n            url;\n\n        if (!request) { return done(new Error('No request to resolve proxy for.')); }\n\n        url = request.url && request.url.toString();\n\n        async.waterfall([\n            // try resolving custom proxies before falling-back to system proxy\n            function (cb) {\n                if (_.isFunction(_.get(proxies, 'resolve'))) {\n                    return cb(null, proxies.resolve(url));\n                }\n\n                return cb(null, undefined);\n            },\n            // fallback to system proxy\n            function (config, cb) {\n                if (config) {\n                    return cb(null, config);\n                }\n\n                return _.isFunction(run.options.systemProxy) ? run.options.systemProxy(url, cb) : cb(null, undefined);\n            }\n        ], function (err, config) {\n            if (err) {\n                run.triggers.console(context.coords, 'warn', 'proxy lookup error: ' + (err.message || err));\n            }\n\n            config && (request.proxy = sdk.ProxyConfig.isProxyConfig(config) ? config : new sdk.ProxyConfig(config));\n\n            return done();\n        });\n    },\n    // Certificate lookup + reading from whichever file resolver is provided\n    function (context, run, done) {\n        var request,\n            pfxPath,\n            keyPath,\n            certPath,\n            fileResolver,\n\n            certificate;\n\n        // A. Check if we have the file resolver\n        fileResolver = run.options.fileResolver;\n\n        if (!fileResolver) { return done(); } // No point going ahead\n\n        // B. Ensure we have the request\n        request = _.get(context.item, 'request');\n        if (!request) { return done(new Error('No request to resolve certificates for.')); }\n\n        // C. See if any cert should be sent, by performing a URL matching\n        certificate = run.options.certificates && run.options.certificates.resolveOne(request.url);\n        if (!certificate) { return done(); }\n\n        // D. Fetch the paths\n        // @todo: check why aren't we reading ca file (why are we not supporting ca file)\n        pfxPath = _.get(certificate, 'pfx.src');\n        keyPath = _.get(certificate, 'key.src');\n        certPath = _.get(certificate, 'cert.src');\n\n        // E. Read from the path, and add the values to the certificate, also associate\n        // the certificate with the current request.\n        async.mapValues({\n            pfx: pfxPath,\n            key: keyPath,\n            cert: certPath\n        }, function (value, key, next) {\n            // bail out if value is not defined\n            // @todo add test with server which only accepts cert file\n            if (!value) { return next(); }\n\n            // eslint-disable-next-line security/detect-non-literal-fs-filename\n            fileResolver.readFile(value, function (err, data) {\n                // Swallow the error after triggering a warning message for the user.\n                err && run.triggers.console(context.coords, 'warn',\n                    `certificate \"${key}\" load error:  ${(err.message || err)}`);\n                next(null, data);\n            });\n        }, function (err, fileContents) {\n            if (err) {\n                // Swallow the error after triggering a warning message for the user.\n                run.triggers.console(context.coords, 'warn', 'certificate load error: ' + (err.message || err));\n\n                return done();\n            }\n\n            if (fileContents) {\n                !_.isNil(fileContents.pfx) && _.set(certificate, 'pfx.value', fileContents.pfx);\n                !_.isNil(fileContents.key) && _.set(certificate, 'key.value', fileContents.key);\n                !_.isNil(fileContents.cert) && _.set(certificate, 'cert.value', fileContents.cert);\n\n                (fileContents.cert || fileContents.key || fileContents.pfx) && (request.certificate = certificate);\n            }\n            done();\n        });\n    }\n];\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}