{"ast":null,"code":"var _ = require('lodash'),\n  crypto = require('crypto'),\n  urlEncoder = require('postman-url-encoder'),\n  RequestBody = require('postman-collection').RequestBody,\n  bodyBuilder = require('../requester/core-body-builder'),\n  EMPTY = '',\n  ONE = '00000001',\n  DISABLE_RETRY_REQUEST = 'disableRetryRequest',\n  WWW_AUTHENTICATE = 'www-authenticate',\n  DIGEST_PREFIX = 'Digest ',\n  QOP = 'qop',\n  AUTH = 'auth',\n  COLON = ':',\n  QUOTE = '\"',\n  SESS = '-sess',\n  AUTH_INT = 'auth-int',\n  AUTHORIZATION = 'Authorization',\n  MD5_SESS = 'MD5-sess',\n  ASCII_SOURCE = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789',\n  ASCII_SOURCE_LENGTH = ASCII_SOURCE.length,\n  USERNAME_EQUALS_QUOTE = 'username=\"',\n  REALM_EQUALS_QUOTE = 'realm=\"',\n  NONCE_EQUALS_QUOTE = 'nonce=\"',\n  URI_EQUALS_QUOTE = 'uri=\"',\n  ALGORITHM_EQUALS_QUOTE = 'algorithm=\"',\n  CNONCE_EQUALS_QUOTE = 'cnonce=\"',\n  RESPONSE_EQUALS_QUOTE = 'response=\"',\n  OPAQUE_EQUALS_QUOTE = 'opaque=\"',\n  QOP_EQUALS = 'qop=',\n  NC_EQUALS = 'nc=',\n  ALGO = {\n    MD5: 'MD5',\n    MD5_SESS: 'MD5-sess',\n    SHA_256: 'SHA-256',\n    SHA_256_SESS: 'SHA-256-sess',\n    SHA_512_256: 'SHA-512-256',\n    SHA_512_256_SESS: 'SHA-512-256-sess'\n  },\n  AUTH_PARAMETERS = ['algorithm', 'username', 'realm', 'password', 'method', 'nonce', 'nonceCount', 'clientNonce', 'opaque', 'qop', 'uri'],\n  nonceRegex = /nonce=\"([^\"]*)\"/,\n  realmRegex = /realm=\"([^\"]*)\"/,\n  qopRegex = /qop=\"([^\"]*)\"/,\n  opaqueRegex = /opaque=\"([^\"]*)\"/,\n  _extractField,\n  SHA512_256,\n  nodeCrypto;\n\n// Current Electron version(7.2.3) in Postman app uses OpenSSL 1.1.0\n// which don't support `SHA-512-256`. Use external `js-sha512` module\n// to handle this case.\nif (!_.includes(crypto.getHashes(), 'sha512-256')) {\n  SHA512_256 = require('js-sha512').sha512_256;\n  nodeCrypto = crypto;\n\n  // create a wrapper class with similar interface to Node's crypto and use jsSHA\n  // to support SHA512-256 algorithm\n  crypto = function () {\n    this._hash = SHA512_256.create();\n  };\n  _.assign(crypto.prototype, {\n    update(data) {\n      this._hash.update(data);\n      return this;\n    },\n    digest() {\n      // we only need 'hex' digest for this auth\n      return this._hash.hex();\n    }\n  });\n  _.assign(crypto, {\n    createHash(hashAlgo) {\n      // return hash from js-sha for SHA512-256\n      if (hashAlgo === 'sha512-256') {\n        return new crypto();\n      }\n\n      // return Node's hash otherwise\n      return nodeCrypto.createHash(hashAlgo);\n    }\n  });\n}\n\n/**\n * Generates a random string of given length\n *\n * @todo Move this to util.js. After moving use that for hawk auth too\n * @param {Number} length -\n */\nfunction randomString(length) {\n  length = length || 6;\n  var result = [],\n    i;\n  for (i = 0; i < length; i++) {\n    result[i] = ASCII_SOURCE[Math.random() * ASCII_SOURCE_LENGTH | 0];\n  }\n  return result.join(EMPTY);\n}\n\n/**\n * Extracts a Digest Auth field from a WWW-Authenticate header value using a given regexp.\n *\n * @param {String} string -\n * @param {RegExp} regexp -\n * @private\n */\n_extractField = function (string, regexp) {\n  var match = string.match(regexp);\n  return match ? match[1] : EMPTY;\n};\n\n/**\n * Returns the 'www-authenticate' header for Digest auth. Since a server can suport more than more auth-scheme,\n * there can be more than one header with the same key. So need to loop over and check each one.\n *\n * @param {VariableList} headers -\n * @private\n */\nfunction _getDigestAuthHeader(headers) {\n  return headers.find(function (property) {\n    return property.key.toLowerCase() === WWW_AUTHENTICATE && _.startsWith(property.value, DIGEST_PREFIX);\n  });\n}\n\n/**\n * Returns hex encoded hash of given data using given algorithm.\n *\n * @param {String} data string to calculate hash\n * @param {String} algorithm hash algorithm\n * @returns {String} hex encoded hash of given data\n */\nfunction getHash(data, algorithm) {\n  return crypto.createHash(algorithm).update(data || EMPTY).digest('hex');\n}\n\n/**\n * Calculates body hash with given algorithm and digestEncoding.\n *\n * @param {RequestBody} body Request body\n * @param {String} algorithm Hash algorithm to use\n * @param {String} digestEncoding Encoding of the hash\n * @param {Function} callback Callback function that will be called with body hash\n */\nfunction computeBodyHash(body, algorithm, digestEncoding, callback) {\n  if (!(algorithm && digestEncoding)) {\n    return callback();\n  }\n  var hash = crypto.createHash(algorithm),\n    originalReadStream,\n    rawBody,\n    graphqlBody,\n    urlencodedBody;\n\n  // if body is not available, return hash of empty string\n  if (!body || body.isEmpty()) {\n    return callback(hash.digest(digestEncoding));\n  }\n  if (body.mode === RequestBody.MODES.raw) {\n    rawBody = bodyBuilder.raw(body.raw).body;\n    hash.update(rawBody);\n    return callback(hash.digest(digestEncoding));\n  }\n  if (body.mode === RequestBody.MODES.urlencoded) {\n    urlencodedBody = bodyBuilder.urlencoded(body.urlencoded).form;\n    urlencodedBody = urlEncoder.encodeQueryString(urlencodedBody);\n    hash.update(urlencodedBody);\n    return callback(hash.digest(digestEncoding));\n  }\n  if (body.mode === RequestBody.MODES.file) {\n    originalReadStream = _.get(body, 'file.content');\n    if (!originalReadStream) {\n      return callback();\n    }\n    return originalReadStream.cloneReadStream(function (err, clonedStream) {\n      if (err) {\n        return callback();\n      }\n      clonedStream.on('data', function (chunk) {\n        hash.update(chunk);\n      });\n      clonedStream.on('end', function () {\n        callback(hash.digest(digestEncoding));\n      });\n    });\n  }\n  if (body.mode === RequestBody.MODES.graphql) {\n    graphqlBody = bodyBuilder.graphql(body.graphql).body;\n    hash.update(graphqlBody);\n    return callback(hash.digest(digestEncoding));\n  }\n\n  // @todo: Figure out a way to calculate hash for formdata body type.\n\n  // ensure that callback is called if body.mode doesn't match with any of the above modes\n  return callback();\n}\n\n/**\n * All the auth definition parameters excluding username and password should be stored and resued.\n *\n * @todo The current implementation would fail for the case when two requests to two different hosts inherits the same\n * auth. In that case a retry would not be attempted for the second request (since all the parameters would be present\n * in the auth definition though invalid).\n *\n * @implements {AuthHandlerInterface}\n */\nmodule.exports = {\n  /**\n   * @property {AuthHandlerInterface~AuthManifest}\n   */\n  manifest: {\n    info: {\n      name: 'digest',\n      version: '1.0.0'\n    },\n    updates: [{\n      property: 'Authorization',\n      type: 'header'\n    }, {\n      property: 'nonce',\n      type: 'auth'\n    }, {\n      property: 'realm',\n      type: 'auth'\n    }]\n  },\n  /**\n   * Initializes an item (extracts parameters from intermediate requests if any, etc)\n   * before the actual authorization step.\n   *\n   * @param {AuthInterface} auth -\n   * @param {Response} response -\n   * @param {AuthHandlerInterface~authInitHookCallback} done -\n   */\n  init: function (auth, response, done) {\n    done(null);\n  },\n  /**\n   * Checks whether the given item has all the required parameters in its request.\n   * Sanitizes the auth parameters if needed.\n   *\n   * @param {AuthInterface} auth -\n   * @param {AuthHandlerInterface~authPreHookCallback} done -\n   */\n  pre: function (auth, done) {\n    // ensure that all dynamic parameter values are present in the parameters\n    // if even one is absent, we return false.\n    done(null, Boolean(auth.get('nonce') && auth.get('realm')));\n  },\n  /**\n   * Verifies whether the request was successfully authorized after being sent.\n   *\n   * @param {AuthInterface} auth -\n   * @param {Response} response -\n   * @param {AuthHandlerInterface~authPostHookCallback} done -\n   */\n  post: function (auth, response, done) {\n    if (auth.get(DISABLE_RETRY_REQUEST) || !response) {\n      return done(null, true);\n    }\n    var code,\n      realm,\n      nonce,\n      qop,\n      opaque,\n      authHeader,\n      authParams = {};\n    code = response.code;\n    authHeader = _getDigestAuthHeader(response.headers);\n\n    // If code is forbidden or unauthorized, and an auth header exists,\n    // we can extract the realm & the nonce, and replay the request.\n    // todo: add response.is4XX, response.is5XX, etc in the SDK.\n    if ((code === 401 || code === 403) && authHeader) {\n      nonce = _extractField(authHeader.value, nonceRegex);\n      realm = _extractField(authHeader.value, realmRegex);\n      qop = _extractField(authHeader.value, qopRegex);\n      opaque = _extractField(authHeader.value, opaqueRegex);\n      authParams.nonce = nonce;\n      authParams.realm = realm;\n      opaque && (authParams.opaque = opaque);\n      qop && (authParams.qop = qop);\n      if (authParams.qop || auth.get(QOP)) {\n        authParams.clientNonce = randomString(8);\n        authParams.nonceCount = ONE;\n      }\n\n      // if all the auth parameters sent by server were already present in auth definition then we do not retry\n      if (_.every(authParams, function (value, key) {\n        return auth.get(key);\n      })) {\n        return done(null, true);\n      }\n      auth.set(authParams);\n      return done(null, false);\n    }\n    done(null, true);\n  },\n  /**\n   * Computes the Digest Authentication header from the given parameters.\n   *\n   * @param {Object} params -\n   * @param {String} params.algorithm -\n   * @param {String} params.username -\n   * @param {String} params.realm -\n   * @param {String} params.password -\n   * @param {String} params.method -\n   * @param {String} params.nonce -\n   * @param {String} params.nonceCount -\n   * @param {String} params.clientNonce -\n   * @param {String} params.opaque -\n   * @param {String} params.qop -\n   * @param {String} params.uri -\n   * @returns {String}\n   */\n  computeHeader: function (params) {\n    var algorithm = params.algorithm,\n      hashAlgo = params.hashAlgo,\n      username = params.username,\n      realm = params.realm,\n      password = params.password,\n      method = params.method,\n      nonce = params.nonce,\n      nonceCount = params.nonceCount,\n      clientNonce = params.clientNonce,\n      opaque = params.opaque,\n      qop = params.qop,\n      uri = params.uri,\n      // RFC defined terms, http://tools.ietf.org/html/rfc2617#section-3\n      A0,\n      A1,\n      A2,\n      hashA1,\n      hashA2,\n      reqDigest,\n      headerParams;\n    if (_.endsWith(algorithm, SESS)) {\n      A0 = getHash(username + COLON + realm + COLON + password, hashAlgo);\n      A1 = A0 + COLON + nonce + COLON + clientNonce;\n    } else {\n      A1 = username + COLON + realm + COLON + password;\n    }\n    if (qop === AUTH_INT) {\n      A2 = method + COLON + uri + COLON + params.bodyhash;\n    } else {\n      A2 = method + COLON + uri;\n    }\n    hashA1 = getHash(A1, hashAlgo);\n    hashA2 = getHash(A2, hashAlgo);\n    if (qop === AUTH || qop === AUTH_INT) {\n      reqDigest = getHash([hashA1, nonce, nonceCount, clientNonce, qop, hashA2].join(COLON), hashAlgo);\n    } else {\n      reqDigest = getHash([hashA1, nonce, hashA2].join(COLON), hashAlgo);\n    }\n    headerParams = [USERNAME_EQUALS_QUOTE + username + QUOTE, REALM_EQUALS_QUOTE + realm + QUOTE, NONCE_EQUALS_QUOTE + nonce + QUOTE, URI_EQUALS_QUOTE + uri + QUOTE];\n    algorithm && headerParams.push(ALGORITHM_EQUALS_QUOTE + algorithm + QUOTE);\n    if (qop === AUTH || qop === AUTH_INT) {\n      headerParams.push(QOP_EQUALS + qop);\n    }\n    if (qop === AUTH || qop === AUTH_INT || algorithm === MD5_SESS) {\n      nonceCount && headerParams.push(NC_EQUALS + nonceCount);\n      headerParams.push(CNONCE_EQUALS_QUOTE + clientNonce + QUOTE);\n    }\n    headerParams.push(RESPONSE_EQUALS_QUOTE + reqDigest + QUOTE);\n    opaque && headerParams.push(OPAQUE_EQUALS_QUOTE + opaque + QUOTE);\n    return DIGEST_PREFIX + headerParams.join(', ');\n  },\n  /**\n   * Signs a request.\n   *\n   * @param {AuthInterface} auth -\n   * @param {Request} request -\n   * @param {AuthHandlerInterface~authSignHookCallback} done -\n   */\n  sign: function (auth, request, done) {\n    var self = this,\n      params = auth.get(AUTH_PARAMETERS),\n      url = urlEncoder.toNodeUrl(request.url),\n      header;\n    if (!params.username || !params.realm) {\n      return done(); // Nothing to do if required parameters are not present.\n    }\n\n    request.removeHeader(AUTHORIZATION, {\n      ignoreCase: true\n    });\n    params.method = request.method;\n    params.uri = url.path;\n    switch (params.algorithm) {\n      case ALGO.SHA_256:\n      case ALGO.SHA_256_SESS:\n        params.hashAlgo = 'sha256';\n        break;\n      case ALGO.MD5:\n      case ALGO.MD5_SESS:\n      case EMPTY:\n      case undefined:\n      case null:\n        params.algorithm = params.algorithm || ALGO.MD5;\n        params.hashAlgo = 'md5';\n        break;\n      case ALGO.SHA_512_256:\n      case ALGO.SHA_512_256_SESS:\n        params.hashAlgo = 'sha512-256';\n        break;\n      default:\n        return done(new Error(`Unsupported digest algorithm: ${params.algorithm}`));\n    }\n\n    // calculate body hash for qop='auth-int'\n    if (params.qop === AUTH_INT) {\n      return computeBodyHash(request.body, params.hashAlgo, 'hex', function (bodyhash) {\n        params.bodyhash = bodyhash;\n        header = self.computeHeader(params);\n        request.addHeader({\n          key: AUTHORIZATION,\n          value: header,\n          system: true\n        });\n        return done();\n      });\n    }\n    header = self.computeHeader(params);\n    request.addHeader({\n      key: AUTHORIZATION,\n      value: header,\n      system: true\n    });\n    return done();\n  }\n};","map":{"version":3,"names":["_","require","crypto","urlEncoder","RequestBody","bodyBuilder","EMPTY","ONE","DISABLE_RETRY_REQUEST","WWW_AUTHENTICATE","DIGEST_PREFIX","QOP","AUTH","COLON","QUOTE","SESS","AUTH_INT","AUTHORIZATION","MD5_SESS","ASCII_SOURCE","ASCII_SOURCE_LENGTH","length","USERNAME_EQUALS_QUOTE","REALM_EQUALS_QUOTE","NONCE_EQUALS_QUOTE","URI_EQUALS_QUOTE","ALGORITHM_EQUALS_QUOTE","CNONCE_EQUALS_QUOTE","RESPONSE_EQUALS_QUOTE","OPAQUE_EQUALS_QUOTE","QOP_EQUALS","NC_EQUALS","ALGO","MD5","SHA_256","SHA_256_SESS","SHA_512_256","SHA_512_256_SESS","AUTH_PARAMETERS","nonceRegex","realmRegex","qopRegex","opaqueRegex","_extractField","SHA512_256","nodeCrypto","includes","getHashes","sha512_256","_hash","create","assign","prototype","update","data","digest","hex","createHash","hashAlgo","randomString","result","i","Math","random","join","string","regexp","match","_getDigestAuthHeader","headers","find","property","key","toLowerCase","startsWith","value","getHash","algorithm","computeBodyHash","body","digestEncoding","callback","hash","originalReadStream","rawBody","graphqlBody","urlencodedBody","isEmpty","mode","MODES","raw","urlencoded","form","encodeQueryString","file","get","cloneReadStream","err","clonedStream","on","chunk","graphql","module","exports","manifest","info","name","version","updates","type","init","auth","response","done","pre","Boolean","post","code","realm","nonce","qop","opaque","authHeader","authParams","clientNonce","nonceCount","every","set","computeHeader","params","username","password","method","uri","A0","A1","A2","hashA1","hashA2","reqDigest","headerParams","endsWith","bodyhash","push","sign","request","self","url","toNodeUrl","header","removeHeader","ignoreCase","path","undefined","Error","addHeader","system"],"sources":["/Users/Qusai.Qishta/node_modules/postman-runtime/lib/authorizer/digest.js"],"sourcesContent":["var _ = require('lodash'),\n    crypto = require('crypto'),\n    urlEncoder = require('postman-url-encoder'),\n    RequestBody = require('postman-collection').RequestBody,\n    bodyBuilder = require('../requester/core-body-builder'),\n\n    EMPTY = '',\n    ONE = '00000001',\n    DISABLE_RETRY_REQUEST = 'disableRetryRequest',\n    WWW_AUTHENTICATE = 'www-authenticate',\n    DIGEST_PREFIX = 'Digest ',\n    QOP = 'qop',\n    AUTH = 'auth',\n    COLON = ':',\n    QUOTE = '\"',\n    SESS = '-sess',\n    AUTH_INT = 'auth-int',\n    AUTHORIZATION = 'Authorization',\n    MD5_SESS = 'MD5-sess',\n    ASCII_SOURCE = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789',\n    ASCII_SOURCE_LENGTH = ASCII_SOURCE.length,\n    USERNAME_EQUALS_QUOTE = 'username=\"',\n    REALM_EQUALS_QUOTE = 'realm=\"',\n    NONCE_EQUALS_QUOTE = 'nonce=\"',\n    URI_EQUALS_QUOTE = 'uri=\"',\n    ALGORITHM_EQUALS_QUOTE = 'algorithm=\"',\n    CNONCE_EQUALS_QUOTE = 'cnonce=\"',\n    RESPONSE_EQUALS_QUOTE = 'response=\"',\n    OPAQUE_EQUALS_QUOTE = 'opaque=\"',\n    QOP_EQUALS = 'qop=',\n    NC_EQUALS = 'nc=',\n    ALGO = {\n        MD5: 'MD5',\n        MD5_SESS: 'MD5-sess',\n        SHA_256: 'SHA-256',\n        SHA_256_SESS: 'SHA-256-sess',\n        SHA_512_256: 'SHA-512-256',\n        SHA_512_256_SESS: 'SHA-512-256-sess'\n    },\n    AUTH_PARAMETERS = [\n        'algorithm',\n        'username',\n        'realm',\n        'password',\n        'method',\n        'nonce',\n        'nonceCount',\n        'clientNonce',\n        'opaque',\n        'qop',\n        'uri'\n    ],\n\n    nonceRegex = /nonce=\"([^\"]*)\"/,\n    realmRegex = /realm=\"([^\"]*)\"/,\n    qopRegex = /qop=\"([^\"]*)\"/,\n    opaqueRegex = /opaque=\"([^\"]*)\"/,\n    _extractField,\n    SHA512_256,\n    nodeCrypto;\n\n// Current Electron version(7.2.3) in Postman app uses OpenSSL 1.1.0\n// which don't support `SHA-512-256`. Use external `js-sha512` module\n// to handle this case.\nif (!_.includes(crypto.getHashes(), 'sha512-256')) {\n    SHA512_256 = require('js-sha512').sha512_256;\n    nodeCrypto = crypto;\n\n    // create a wrapper class with similar interface to Node's crypto and use jsSHA\n    // to support SHA512-256 algorithm\n    crypto = function () {\n        this._hash = SHA512_256.create();\n    };\n\n    _.assign(crypto.prototype, {\n        update (data) {\n            this._hash.update(data);\n\n            return this;\n        },\n\n        digest () {\n            // we only need 'hex' digest for this auth\n            return this._hash.hex();\n        }\n    });\n\n    _.assign(crypto, {\n        createHash (hashAlgo) {\n            // return hash from js-sha for SHA512-256\n            if (hashAlgo === 'sha512-256') {\n                return new crypto();\n            }\n\n            // return Node's hash otherwise\n            return nodeCrypto.createHash(hashAlgo);\n        }\n    });\n}\n\n/**\n * Generates a random string of given length\n *\n * @todo Move this to util.js. After moving use that for hawk auth too\n * @param {Number} length -\n */\nfunction randomString (length) {\n    length = length || 6;\n\n    var result = [],\n        i;\n\n    for (i = 0; i < length; i++) {\n        result[i] = ASCII_SOURCE[(Math.random() * ASCII_SOURCE_LENGTH) | 0];\n    }\n\n    return result.join(EMPTY);\n}\n\n\n/**\n * Extracts a Digest Auth field from a WWW-Authenticate header value using a given regexp.\n *\n * @param {String} string -\n * @param {RegExp} regexp -\n * @private\n */\n_extractField = function (string, regexp) {\n    var match = string.match(regexp);\n\n    return match ? match[1] : EMPTY;\n};\n\n/**\n * Returns the 'www-authenticate' header for Digest auth. Since a server can suport more than more auth-scheme,\n * there can be more than one header with the same key. So need to loop over and check each one.\n *\n * @param {VariableList} headers -\n * @private\n */\nfunction _getDigestAuthHeader (headers) {\n    return headers.find(function (property) {\n        return (property.key.toLowerCase() === WWW_AUTHENTICATE) && (_.startsWith(property.value, DIGEST_PREFIX));\n    });\n}\n\n/**\n * Returns hex encoded hash of given data using given algorithm.\n *\n * @param {String} data string to calculate hash\n * @param {String} algorithm hash algorithm\n * @returns {String} hex encoded hash of given data\n */\nfunction getHash (data, algorithm) {\n    return crypto.createHash(algorithm).update(data || EMPTY).digest('hex');\n}\n\n/**\n * Calculates body hash with given algorithm and digestEncoding.\n *\n * @param {RequestBody} body Request body\n * @param {String} algorithm Hash algorithm to use\n * @param {String} digestEncoding Encoding of the hash\n * @param {Function} callback Callback function that will be called with body hash\n */\nfunction computeBodyHash (body, algorithm, digestEncoding, callback) {\n    if (!(algorithm && digestEncoding)) { return callback(); }\n\n    var hash = crypto.createHash(algorithm),\n        originalReadStream,\n        rawBody,\n        graphqlBody,\n        urlencodedBody;\n\n    // if body is not available, return hash of empty string\n    if (!body || body.isEmpty()) {\n        return callback(hash.digest(digestEncoding));\n    }\n\n    if (body.mode === RequestBody.MODES.raw) {\n        rawBody = bodyBuilder.raw(body.raw).body;\n        hash.update(rawBody);\n\n        return callback(hash.digest(digestEncoding));\n    }\n\n    if (body.mode === RequestBody.MODES.urlencoded) {\n        urlencodedBody = bodyBuilder.urlencoded(body.urlencoded).form;\n        urlencodedBody = urlEncoder.encodeQueryString(urlencodedBody);\n        hash.update(urlencodedBody);\n\n        return callback(hash.digest(digestEncoding));\n    }\n\n    if (body.mode === RequestBody.MODES.file) {\n        originalReadStream = _.get(body, 'file.content');\n\n        if (!originalReadStream) {\n            return callback();\n        }\n\n        return originalReadStream.cloneReadStream(function (err, clonedStream) {\n            if (err) { return callback(); }\n\n            clonedStream.on('data', function (chunk) {\n                hash.update(chunk);\n            });\n\n            clonedStream.on('end', function () {\n                callback(hash.digest(digestEncoding));\n            });\n        });\n    }\n\n    if (body.mode === RequestBody.MODES.graphql) {\n        graphqlBody = bodyBuilder.graphql(body.graphql).body;\n        hash.update(graphqlBody);\n\n        return callback(hash.digest(digestEncoding));\n    }\n\n    // @todo: Figure out a way to calculate hash for formdata body type.\n\n    // ensure that callback is called if body.mode doesn't match with any of the above modes\n    return callback();\n}\n\n/**\n * All the auth definition parameters excluding username and password should be stored and resued.\n *\n * @todo The current implementation would fail for the case when two requests to two different hosts inherits the same\n * auth. In that case a retry would not be attempted for the second request (since all the parameters would be present\n * in the auth definition though invalid).\n *\n * @implements {AuthHandlerInterface}\n */\nmodule.exports = {\n    /**\n     * @property {AuthHandlerInterface~AuthManifest}\n     */\n    manifest: {\n        info: {\n            name: 'digest',\n            version: '1.0.0'\n        },\n        updates: [\n            {\n                property: 'Authorization',\n                type: 'header'\n            },\n            {\n                property: 'nonce',\n                type: 'auth'\n            },\n            {\n                property: 'realm',\n                type: 'auth'\n            }\n        ]\n    },\n\n    /**\n     * Initializes an item (extracts parameters from intermediate requests if any, etc)\n     * before the actual authorization step.\n     *\n     * @param {AuthInterface} auth -\n     * @param {Response} response -\n     * @param {AuthHandlerInterface~authInitHookCallback} done -\n     */\n    init: function (auth, response, done) {\n        done(null);\n    },\n\n    /**\n     * Checks whether the given item has all the required parameters in its request.\n     * Sanitizes the auth parameters if needed.\n     *\n     * @param {AuthInterface} auth -\n     * @param {AuthHandlerInterface~authPreHookCallback} done -\n     */\n    pre: function (auth, done) {\n        // ensure that all dynamic parameter values are present in the parameters\n        // if even one is absent, we return false.\n        done(null, Boolean(auth.get('nonce') && auth.get('realm')));\n    },\n\n    /**\n     * Verifies whether the request was successfully authorized after being sent.\n     *\n     * @param {AuthInterface} auth -\n     * @param {Response} response -\n     * @param {AuthHandlerInterface~authPostHookCallback} done -\n     */\n    post: function (auth, response, done) {\n        if (auth.get(DISABLE_RETRY_REQUEST) || !response) {\n            return done(null, true);\n        }\n\n        var code,\n            realm,\n            nonce,\n            qop,\n            opaque,\n            authHeader,\n            authParams = {};\n\n        code = response.code;\n        authHeader = _getDigestAuthHeader(response.headers);\n\n        // If code is forbidden or unauthorized, and an auth header exists,\n        // we can extract the realm & the nonce, and replay the request.\n        // todo: add response.is4XX, response.is5XX, etc in the SDK.\n        if ((code === 401 || code === 403) && authHeader) {\n            nonce = _extractField(authHeader.value, nonceRegex);\n            realm = _extractField(authHeader.value, realmRegex);\n            qop = _extractField(authHeader.value, qopRegex);\n            opaque = _extractField(authHeader.value, opaqueRegex);\n\n            authParams.nonce = nonce;\n            authParams.realm = realm;\n            opaque && (authParams.opaque = opaque);\n            qop && (authParams.qop = qop);\n\n            if (authParams.qop || auth.get(QOP)) {\n                authParams.clientNonce = randomString(8);\n                authParams.nonceCount = ONE;\n            }\n\n            // if all the auth parameters sent by server were already present in auth definition then we do not retry\n            if (_.every(authParams, function (value, key) { return auth.get(key); })) {\n                return done(null, true);\n            }\n\n            auth.set(authParams);\n\n            return done(null, false);\n        }\n\n        done(null, true);\n    },\n\n    /**\n     * Computes the Digest Authentication header from the given parameters.\n     *\n     * @param {Object} params -\n     * @param {String} params.algorithm -\n     * @param {String} params.username -\n     * @param {String} params.realm -\n     * @param {String} params.password -\n     * @param {String} params.method -\n     * @param {String} params.nonce -\n     * @param {String} params.nonceCount -\n     * @param {String} params.clientNonce -\n     * @param {String} params.opaque -\n     * @param {String} params.qop -\n     * @param {String} params.uri -\n     * @returns {String}\n     */\n    computeHeader: function (params) {\n        var algorithm = params.algorithm,\n            hashAlgo = params.hashAlgo,\n            username = params.username,\n            realm = params.realm,\n            password = params.password,\n            method = params.method,\n            nonce = params.nonce,\n            nonceCount = params.nonceCount,\n            clientNonce = params.clientNonce,\n            opaque = params.opaque,\n            qop = params.qop,\n            uri = params.uri,\n\n            // RFC defined terms, http://tools.ietf.org/html/rfc2617#section-3\n            A0,\n            A1,\n            A2,\n            hashA1,\n            hashA2,\n\n            reqDigest,\n            headerParams;\n\n        if (_.endsWith(algorithm, SESS)) {\n            A0 = getHash(username + COLON + realm + COLON + password, hashAlgo);\n            A1 = A0 + COLON + nonce + COLON + clientNonce;\n        }\n        else {\n            A1 = username + COLON + realm + COLON + password;\n        }\n\n        if (qop === AUTH_INT) {\n            A2 = method + COLON + uri + COLON + params.bodyhash;\n        }\n        else {\n            A2 = method + COLON + uri;\n        }\n        hashA1 = getHash(A1, hashAlgo);\n        hashA2 = getHash(A2, hashAlgo);\n\n        if (qop === AUTH || qop === AUTH_INT) {\n            reqDigest = getHash([hashA1, nonce, nonceCount, clientNonce, qop, hashA2].join(COLON), hashAlgo);\n        }\n        else {\n            reqDigest = getHash([hashA1, nonce, hashA2].join(COLON), hashAlgo);\n        }\n\n        headerParams = [USERNAME_EQUALS_QUOTE + username + QUOTE,\n            REALM_EQUALS_QUOTE + realm + QUOTE,\n            NONCE_EQUALS_QUOTE + nonce + QUOTE,\n            URI_EQUALS_QUOTE + uri + QUOTE\n        ];\n\n        algorithm && headerParams.push(ALGORITHM_EQUALS_QUOTE + algorithm + QUOTE);\n\n        if (qop === AUTH || qop === AUTH_INT) {\n            headerParams.push(QOP_EQUALS + qop);\n        }\n\n        if (qop === AUTH || qop === AUTH_INT || algorithm === MD5_SESS) {\n            nonceCount && headerParams.push(NC_EQUALS + nonceCount);\n            headerParams.push(CNONCE_EQUALS_QUOTE + clientNonce + QUOTE);\n        }\n\n        headerParams.push(RESPONSE_EQUALS_QUOTE + reqDigest + QUOTE);\n        opaque && headerParams.push(OPAQUE_EQUALS_QUOTE + opaque + QUOTE);\n\n        return DIGEST_PREFIX + headerParams.join(', ');\n    },\n\n    /**\n     * Signs a request.\n     *\n     * @param {AuthInterface} auth -\n     * @param {Request} request -\n     * @param {AuthHandlerInterface~authSignHookCallback} done -\n     */\n    sign: function (auth, request, done) {\n        var self = this,\n            params = auth.get(AUTH_PARAMETERS),\n            url = urlEncoder.toNodeUrl(request.url),\n            header;\n\n        if (!params.username || !params.realm) {\n            return done(); // Nothing to do if required parameters are not present.\n        }\n\n        request.removeHeader(AUTHORIZATION, { ignoreCase: true });\n\n        params.method = request.method;\n        params.uri = url.path;\n\n        switch (params.algorithm) {\n            case ALGO.SHA_256:\n            case ALGO.SHA_256_SESS:\n                params.hashAlgo = 'sha256';\n                break;\n            case ALGO.MD5:\n            case ALGO.MD5_SESS:\n            case EMPTY:\n            case undefined:\n            case null:\n                params.algorithm = params.algorithm || ALGO.MD5;\n                params.hashAlgo = 'md5';\n                break;\n            case ALGO.SHA_512_256:\n            case ALGO.SHA_512_256_SESS:\n                params.hashAlgo = 'sha512-256';\n                break;\n            default:\n                return done(new Error(`Unsupported digest algorithm: ${params.algorithm}`));\n        }\n\n        // calculate body hash for qop='auth-int'\n        if (params.qop === AUTH_INT) {\n            return computeBodyHash(request.body, params.hashAlgo, 'hex', function (bodyhash) {\n                params.bodyhash = bodyhash;\n                header = self.computeHeader(params);\n\n                request.addHeader({\n                    key: AUTHORIZATION,\n                    value: header,\n                    system: true\n                });\n\n                return done();\n            });\n        }\n\n        header = self.computeHeader(params);\n\n        request.addHeader({\n            key: AUTHORIZATION,\n            value: header,\n            system: true\n        });\n\n        return done();\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}