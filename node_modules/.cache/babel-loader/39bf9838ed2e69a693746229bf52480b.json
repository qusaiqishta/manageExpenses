{"ast":null,"code":"const _ETA = require('./eta');\nconst _Terminal = require('./terminal');\nconst _formatter = require('./formatter');\nconst _EventEmitter = require('events');\n\n// Progress-Bar constructor\nmodule.exports = class GenericBar extends _EventEmitter {\n  constructor(options) {\n    super();\n\n    // store options\n    this.options = options;\n\n    // store terminal instance\n    this.terminal = this.options.terminal ? this.options.terminal : new _Terminal(this.options.stream);\n\n    // the current bar value\n    this.value = 0;\n\n    // the end value of the bar\n    this.total = 100;\n\n    // last drawn string - only render on change!\n    this.lastDrawnString = null;\n\n    // start time (used for eta calculation)\n    this.startTime = null;\n\n    // stop time (used for duration calculation)\n    this.stopTime = null;\n\n    // last update time\n    this.lastRedraw = Date.now();\n\n    // default eta calculator (will be re-create on start)\n    this.eta = new _ETA(this.options.etaBufferLength, 0, 0);\n\n    // payload data\n    this.payload = {};\n\n    // progress bar active ?\n    this.isActive = false;\n\n    // use default formatter or custom one ?\n    this.formatter = typeof this.options.format === 'function' ? this.options.format : _formatter;\n  }\n\n  // internal render function\n  render() {\n    // calculate the normalized current progress\n    let progress = this.value / this.total;\n\n    // handle NaN Errors caused by total=0. Set to complete in this case\n    if (isNaN(progress)) {\n      progress = this.options && this.options.emptyOnZero ? 0.0 : 1.0;\n    }\n\n    // limiter\n    progress = Math.min(Math.max(progress, 0.0), 1.0);\n\n    // formatter params\n    const params = {\n      progress: progress,\n      eta: this.eta.getTime(),\n      startTime: this.startTime,\n      stopTime: this.stopTime,\n      total: this.total,\n      value: this.value,\n      maxWidth: this.terminal.getWidth()\n    };\n\n    // automatic eta update ? (long running processes)\n    if (this.options.etaAsynchronousUpdate) {\n      this.updateETA();\n    }\n\n    // format string\n    const s = this.formatter(this.options, params, this.payload);\n    const forceRedraw = this.options.forceRedraw\n    // force redraw in notty-mode!\n    || this.options.noTTYOutput && !this.terminal.isTTY();\n\n    // string changed ? only trigger redraw on change!\n    if (forceRedraw || this.lastDrawnString != s) {\n      // trigger event\n      this.emit('redraw-pre');\n\n      // set cursor to start of line\n      this.terminal.cursorTo(0, null);\n\n      // write output\n      this.terminal.write(s);\n\n      // clear to the right from cursor\n      this.terminal.clearRight();\n\n      // store string\n      this.lastDrawnString = s;\n\n      // set last redraw time\n      this.lastRedraw = Date.now();\n\n      // trigger event\n      this.emit('redraw-post');\n    }\n  }\n\n  // start the progress bar\n  start(total, startValue, payload) {\n    // set initial values\n    this.value = startValue || 0;\n    this.total = typeof total !== 'undefined' && total >= 0 ? total : 100;\n\n    // store payload (optional)\n    this.payload = payload || {};\n\n    // store start time for duration+eta calculation\n    this.startTime = Date.now();\n\n    // reset stop time for 're-start' scenario (used for duration calculation)\n    this.stopTime = null;\n\n    // reset string line buffer (redraw detection)\n    this.lastDrawnString = '';\n\n    // initialize eta buffer\n    this.eta = new _ETA(this.options.etaBufferLength, this.startTime, this.value);\n\n    // set flag\n    this.isActive = true;\n\n    // start event\n    this.emit('start', total, startValue);\n  }\n\n  // stop the bar\n  stop() {\n    // set flag\n    this.isActive = false;\n\n    // store stop timestamp to get total duration\n    this.stopTime = Date.now();\n\n    // stop event\n    this.emit('stop', this.total, this.value);\n  }\n\n  // update the bar value\n  // update(value, payload)\n  // update(payload)\n  update(arg0) {\n    let arg1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // value set ?\n    // update(value, [payload]);\n    if (typeof arg0 === 'number') {\n      // update value\n      this.value = arg0;\n\n      // add new value; recalculate eta\n      this.eta.update(Date.now(), arg0, this.total);\n    }\n\n    // extract payload\n    // update(value, payload)\n    // update(payload)\n    const payloadData = (typeof arg0 === 'object' ? arg0 : arg1) || {};\n\n    // update event (before stop() is called)\n    this.emit('update', this.total, this.value);\n\n    // merge payload\n    for (const key in payloadData) {\n      this.payload[key] = payloadData[key];\n    }\n\n    // limit reached ? autostop set ?\n    if (this.value >= this.getTotal() && this.options.stopOnComplete) {\n      this.stop();\n    }\n  }\n\n  // update the bar value\n  // increment(delta, payload)\n  // increment(payload)\n  increment() {\n    let arg0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let arg1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // increment([payload]) => step=1\n    // handle the use case when `step` is omitted but payload is passed\n    if (typeof arg0 === 'object') {\n      this.update(this.value + 1, arg0);\n\n      // increment([step=1], [payload={}])\n    } else {\n      this.update(this.value + arg0, arg1);\n    }\n  }\n\n  // get the total (limit) value\n  getTotal() {\n    return this.total;\n  }\n\n  // set the total (limit) value\n  setTotal(total) {\n    if (typeof total !== 'undefined' && total >= 0) {\n      this.total = total;\n    }\n  }\n\n  // force eta calculation update (long running processes)\n  updateETA() {\n    // add new value; recalculate eta\n    this.eta.update(Date.now(), this.value, this.total);\n  }\n};","map":{"version":3,"names":["_ETA","require","_Terminal","_formatter","_EventEmitter","module","exports","GenericBar","constructor","options","terminal","stream","value","total","lastDrawnString","startTime","stopTime","lastRedraw","Date","now","eta","etaBufferLength","payload","isActive","formatter","format","render","progress","isNaN","emptyOnZero","Math","min","max","params","getTime","maxWidth","getWidth","etaAsynchronousUpdate","updateETA","s","forceRedraw","noTTYOutput","isTTY","emit","cursorTo","write","clearRight","start","startValue","stop","update","arg0","arg1","payloadData","key","getTotal","stopOnComplete","increment","setTotal"],"sources":["/Users/Qusai.Qishta/node_modules/cli-progress/lib/generic-bar.js"],"sourcesContent":["const _ETA = require('./eta');\nconst _Terminal = require('./terminal');\nconst _formatter = require('./formatter');\nconst _EventEmitter = require('events');\n\n// Progress-Bar constructor\nmodule.exports = class GenericBar extends _EventEmitter{\n\n    constructor(options){\n        super();\n\n        // store options\n        this.options = options;\n\n        // store terminal instance\n        this.terminal = (this.options.terminal) ? this.options.terminal : new _Terminal(this.options.stream);\n\n        // the current bar value\n        this.value = 0;\n\n        // the end value of the bar\n        this.total = 100;\n\n        // last drawn string - only render on change!\n        this.lastDrawnString = null;\n\n        // start time (used for eta calculation)\n        this.startTime = null;\n\n        // stop time (used for duration calculation)\n        this.stopTime = null;\n\n        // last update time\n        this.lastRedraw = Date.now();\n\n        // default eta calculator (will be re-create on start)\n        this.eta = new _ETA(this.options.etaBufferLength, 0, 0);\n\n        // payload data\n        this.payload = {};\n\n        // progress bar active ?\n        this.isActive = false;\n\n        // use default formatter or custom one ?\n        this.formatter = (typeof this.options.format === 'function') ? this.options.format : _formatter;\n    }\n\n    // internal render function\n    render(){\n        // calculate the normalized current progress\n        let progress = (this.value/this.total);\n\n        // handle NaN Errors caused by total=0. Set to complete in this case\n        if (isNaN(progress)){\n            progress = (this.options && this.options.emptyOnZero) ? 0.0 : 1.0;\n        }\n\n        // limiter\n        progress = Math.min(Math.max(progress, 0.0), 1.0);\n\n        // formatter params\n        const params = {\n            progress: progress,\n            eta: this.eta.getTime(),\n            startTime: this.startTime,\n            stopTime: this.stopTime,\n            total: this.total,\n            value: this.value,\n            maxWidth: this.terminal.getWidth()\n        };\n\n        // automatic eta update ? (long running processes)\n        if (this.options.etaAsynchronousUpdate){\n            this.updateETA();\n        }\n\n        // format string\n        const s = this.formatter(this.options, params, this.payload);\n\n        const forceRedraw = this.options.forceRedraw\n            // force redraw in notty-mode!\n            || (this.options.noTTYOutput && !this.terminal.isTTY());\n\n        // string changed ? only trigger redraw on change!\n        if (forceRedraw || this.lastDrawnString != s){\n            // trigger event\n            this.emit('redraw-pre');\n\n            // set cursor to start of line\n            this.terminal.cursorTo(0, null);\n\n            // write output\n            this.terminal.write(s);\n\n            // clear to the right from cursor\n            this.terminal.clearRight();\n\n            // store string\n            this.lastDrawnString = s;\n\n            // set last redraw time\n            this.lastRedraw = Date.now();\n\n            // trigger event\n            this.emit('redraw-post');\n        }\n    }\n\n    // start the progress bar\n    start(total, startValue, payload){\n        // set initial values\n        this.value = startValue || 0;\n        this.total = (typeof total !== 'undefined' && total >= 0) ? total : 100;\n\n        // store payload (optional)\n        this.payload = payload || {};\n\n        // store start time for duration+eta calculation\n        this.startTime = Date.now();\n\n        // reset stop time for 're-start' scenario (used for duration calculation)\n        this.stopTime = null;\n\n        // reset string line buffer (redraw detection)\n        this.lastDrawnString = '';\n\n        // initialize eta buffer\n        this.eta = new _ETA(this.options.etaBufferLength, this.startTime, this.value);\n\n        // set flag\n        this.isActive = true;\n\n        // start event\n        this.emit('start', total, startValue);\n    }\n\n    // stop the bar\n    stop(){\n        // set flag\n        this.isActive = false;\n        \n        // store stop timestamp to get total duration\n        this.stopTime = Date.now();\n\n        // stop event\n        this.emit('stop', this.total, this.value);\n    }\n\n    // update the bar value\n    // update(value, payload)\n    // update(payload)\n    update(arg0, arg1 = {}){\n        // value set ?\n        // update(value, [payload]);\n        if (typeof arg0 === 'number') {\n            // update value\n            this.value = arg0;\n\n            // add new value; recalculate eta\n            this.eta.update(Date.now(), arg0, this.total);\n        }\n\n        // extract payload\n        // update(value, payload)\n        // update(payload)\n        const payloadData = ((typeof arg0 === 'object') ? arg0 : arg1) || {};\n\n        // update event (before stop() is called)\n        this.emit('update', this.total, this.value);\n\n        // merge payload\n        for (const key in payloadData){\n            this.payload[key] = payloadData[key];\n        }\n\n        // limit reached ? autostop set ?\n        if (this.value >= this.getTotal() && this.options.stopOnComplete) {\n            this.stop();\n        }\n    }\n\n    // update the bar value\n    // increment(delta, payload)\n    // increment(payload)\n    increment(arg0 = 1, arg1 = {}){\n        // increment([payload]) => step=1\n        // handle the use case when `step` is omitted but payload is passed\n        if (typeof arg0 === 'object') {\n            this.update(this.value + 1, arg0);\n        \n        // increment([step=1], [payload={}])\n        }else{\n            this.update(this.value + arg0, arg1);\n        }\n    }\n\n    // get the total (limit) value\n    getTotal(){\n        return this.total;\n    }\n\n    // set the total (limit) value\n    setTotal(total){\n        if (typeof total !== 'undefined' && total >= 0){\n            this.total = total;\n        }\n    }\n\n    // force eta calculation update (long running processes)\n    updateETA(){\n        // add new value; recalculate eta\n        this.eta.update(Date.now(), this.value, this.total);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}