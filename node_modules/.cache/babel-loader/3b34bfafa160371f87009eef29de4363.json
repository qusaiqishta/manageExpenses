{"ast":null,"code":"var _ = require('lodash'),\n  util = require('../util'),\n  backpack = require('../../backpack');\nmodule.exports = {\n  /**\n   * All the events that this extension triggers\n   *\n   * @type {Array}\n   */\n  triggers: ['pause', 'resume', 'abort'],\n  prototype: /** @lends Run.prototype */{\n    /**\n     * Pause a run\n     *\n     * @param {Function} callback -\n     */\n    pause(callback) {\n      callback = backpack.ensure(callback, this);\n      if (this.paused) {\n        return callback && callback(new Error('run: already paused'));\n      }\n\n      // schedule the pause command as an interrupt and flag that the run is pausing\n      this.paused = true;\n      this.interrupt('pause', null, callback);\n    },\n    /**\n     * Resume a paused a run\n     *\n     * @param {Function} callback -\n     */\n    resume(callback) {\n      callback = backpack.ensure(callback, this);\n      if (!this.paused) {\n        return callback && callback(new Error('run: not paused'));\n      }\n\n      // set flag that it is no longer paused and fire the stored callback for the command when it was paused\n      this.paused = false;\n      setTimeout(function () {\n        this.__resume();\n        delete this.__resume;\n        this.triggers.resume(null, this.state.cursor.current());\n      }.bind(this), 0);\n      callback && callback();\n    },\n    /**\n     * Aborts a run\n     *\n     * @param {boolean} [summarise=true] -\n     * @param {function} callback -\n     */\n    abort(summarise, callback) {\n      if (_.isFunction(summarise) && !callback) {\n        callback = summarise;\n        summarise = true;\n      }\n      this.interrupt('abort', {\n        summarise\n      }, callback);\n      _.isFunction(this.__resume) && this.resume();\n    }\n  },\n  process: /** @lends Run.commands */{\n    pause(userback, payload, next) {\n      // trigger the secondary callbacks\n      this.triggers.pause(null, this.state.cursor.current());\n\n      // tuck away the command completion callback in the run object so that it can be used during resume\n      this.__resume = next;\n\n      // execute the userback sent as part of the command and do so in a try block to ensure it does not hamper\n      // the process tick\n      var error = util.safeCall(userback, this);\n\n      // if there is an error executing the userback, then and only then raise the error (which stops the run)\n      if (error) {\n        return next(error);\n      }\n    },\n    /**\n     * @param {Function} userback -\n     * @param {Object} payload -\n     * @param {Boolean} payload.summarise -\n     * @param {Function} next -\n     */\n    abort(userback, payload, next) {\n      // clear instruction pool and as such there will be nothing next to execute\n      this.pool.clear();\n      this.triggers.abort(null, this.state.cursor.current());\n\n      // execute the userback sent as part of the command and do so in a try block to ensure it does not hamper\n      // the process tick\n      backpack.ensure(userback, this) && userback();\n      next(null);\n    }\n  }\n};","map":{"version":3,"names":["_","require","util","backpack","module","exports","triggers","prototype","pause","callback","ensure","paused","Error","interrupt","resume","setTimeout","__resume","state","cursor","current","bind","abort","summarise","isFunction","process","userback","payload","next","error","safeCall","pool","clear"],"sources":["/Users/Qusai.Qishta/node_modules/postman-runtime/lib/runner/extensions/control.command.js"],"sourcesContent":["var _ = require('lodash'),\n    util = require('../util'),\n    backpack = require('../../backpack');\n\nmodule.exports = {\n    /**\n     * All the events that this extension triggers\n     *\n     * @type {Array}\n     */\n    triggers: ['pause', 'resume', 'abort'],\n\n    prototype: /** @lends Run.prototype */ {\n        /**\n         * Pause a run\n         *\n         * @param {Function} callback -\n         */\n        pause (callback) {\n            callback = backpack.ensure(callback, this);\n\n            if (this.paused) { return callback && callback(new Error('run: already paused')); }\n\n            // schedule the pause command as an interrupt and flag that the run is pausing\n            this.paused = true;\n            this.interrupt('pause', null, callback);\n        },\n\n        /**\n         * Resume a paused a run\n         *\n         * @param {Function} callback -\n         */\n        resume (callback) {\n            callback = backpack.ensure(callback, this);\n\n            if (!this.paused) { return callback && callback(new Error('run: not paused')); }\n\n            // set flag that it is no longer paused and fire the stored callback for the command when it was paused\n            this.paused = false;\n            setTimeout(function () {\n                this.__resume();\n                delete this.__resume;\n                this.triggers.resume(null, this.state.cursor.current());\n            }.bind(this), 0);\n\n            callback && callback();\n        },\n\n        /**\n         * Aborts a run\n         *\n         * @param {boolean} [summarise=true] -\n         * @param {function} callback -\n         */\n        abort (summarise, callback) {\n            if (_.isFunction(summarise) && !callback) {\n                callback = summarise;\n                summarise = true;\n            }\n\n            this.interrupt('abort', {\n                summarise\n            }, callback);\n\n            _.isFunction(this.__resume) && this.resume();\n        }\n    },\n\n    process: /** @lends Run.commands */ {\n        pause (userback, payload, next) {\n            // trigger the secondary callbacks\n            this.triggers.pause(null, this.state.cursor.current());\n\n            // tuck away the command completion callback in the run object so that it can be used during resume\n            this.__resume = next;\n\n            // execute the userback sent as part of the command and do so in a try block to ensure it does not hamper\n            // the process tick\n            var error = util.safeCall(userback, this);\n\n            // if there is an error executing the userback, then and only then raise the error (which stops the run)\n            if (error) {\n                return next(error);\n            }\n        },\n\n        /**\n         * @param {Function} userback -\n         * @param {Object} payload -\n         * @param {Boolean} payload.summarise -\n         * @param {Function} next -\n         */\n        abort (userback, payload, next) {\n            // clear instruction pool and as such there will be nothing next to execute\n            this.pool.clear();\n            this.triggers.abort(null, this.state.cursor.current());\n\n            // execute the userback sent as part of the command and do so in a try block to ensure it does not hamper\n            // the process tick\n            backpack.ensure(userback, this) && userback();\n\n            next(null);\n        }\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}