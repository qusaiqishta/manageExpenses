{"ast":null,"code":"/**\n * This module helps to break URL strings up into components\n * (protocol, auth, host, port, path, query, and hash) keeping the variables\n * intact.\n *\n * @example\n * const parser = require('postman-url-encoder/parser')\n *\n * // returns\n * // {\n * //   raw: 'protocol://{{user}}:{{p@ssw?rd}}@{{host.name}}.com:{{#port}}/p/a/t/h?q=query#hash',\n * //   protocol: 'protocol',\n * //   auth: [ '{{user}}', '{{p@ssw?rd}}' ],\n * //   host: [ '{{host.name}}', 'com' ],\n * //   port: '{{#port}}',\n * //   path: [ 'p', 'a', 't', 'h' ],\n * //   query: [ 'q=query' ],\n * //   hash: 'hash'\n * // }\n * parser.parse('protocol://{{user}}:{{p@ssw?rd}}@{{host.name}}.com:{{#port}}/p/a/t/h?q=query#hash')\n *\n * @module postman-url-encoder/parser\n */\n\nconst ReplacementTracker = require('./replacement-tracker'),\n  REGEX_ALL_BACKSLASHES = /\\\\/g,\n  REGEX_LEADING_SLASHES = /^\\/+/,\n  REGEX_ALL_VARIABLES = /{{[^{}]*[.:/?#@&\\]][^{}]*}}/g,\n  HASH_SEPARATOR = '#',\n  PATH_SEPARATOR = '/',\n  PORT_SEPARATOR = ':',\n  AUTH_SEPARATOR = '@',\n  QUERY_SEPARATOR = '?',\n  DOMAIN_SEPARATOR = '.',\n  PROTOCOL_SEPARATOR = '://',\n  AUTH_SEGMENTS_SEPARATOR = ':',\n  QUERY_SEGMENTS_SEPARATOR = '&',\n  E = '',\n  STRING = 'string',\n  FILE_PROTOCOL = 'file',\n  SAFE_REPLACE_CHAR = '_',\n  CLOSING_SQUARE_BRACKET = ']',\n  URL_PROPERTIES_ORDER = ['protocol', 'auth', 'host', 'port', 'path', 'query', 'hash'];\n\n/**\n * Normalize the given string by replacing the variables which includes\n * reserved characters in its name.\n * The replaced characters are added to the given replacement tracker instance.\n *\n * @private\n * @param {String} str String to normalize\n * @param {ReplacementTracker} replacements ReplacementTracker instance\n * @returns {String} Normalized string\n */\nfunction normalizeVariables(str, replacements) {\n  let normalizedString = E,\n    pointer = 0,\n    // pointer till witch the string is normalized\n    variable,\n    match,\n    index;\n\n  // find all the instances of {{<variable>}} which includes reserved chars\n  // \"Hello {{user#name}}!!!\"\n  //  ↑ (pointer = 0)\n  while ((match = REGEX_ALL_VARIABLES.exec(str)) !== null) {\n    // {{user#name}}\n    variable = match[0];\n\n    // starting index of the {{variable}} in the string\n    // \"Hello {{user#name}}!!!\"\n    //        ↑ (index = 6)\n    index = match.index;\n\n    // [pointer, index) string is normalized + the safe replacement character\n    // \"Hello \" + \"_\"\n    normalizedString += str.slice(pointer, index) + SAFE_REPLACE_CHAR;\n\n    // track the replacement done for the {{variable}}\n    replacements.add(variable, index);\n\n    // update the pointer\n    // \"Hello {{user#name}}!!!\"\n    //                     ↑ (pointer = 19)\n    pointer = index + variable.length;\n  }\n\n  // avoid slicing the string in case of no matches\n  if (pointer === 0) {\n    return str;\n  }\n\n  // whatever left in the string is normalized as well\n  /* istanbul ignore else */\n  if (pointer < str.length) {\n    // \"Hello _\" + \"!!!\"\n    normalizedString += str.slice(pointer);\n  }\n  return normalizedString;\n}\n\n/**\n * Update replaced characters in the URL object with its original value.\n *\n * @private\n * @param {Object} url URL tracker object\n * @param {ReplacementTracker} replacements ReplacementTracker instance\n */\nfunction applyReplacements(url, replacements) {\n  let i, ii, prop;\n\n  // traverse each URL property in the given order\n  for (i = 0, ii = URL_PROPERTIES_ORDER.length; i < ii; ++i) {\n    prop = url[URL_PROPERTIES_ORDER[i]];\n\n    // bail out if the given property is not set (undefined or '')\n    if (!(prop && prop.value)) {\n      continue;\n    }\n    prop.value = replacements.apply(prop.value, prop.beginIndex, prop.endIndex);\n  }\n  return url;\n}\n\n/**\n * Parses the input string by decomposing the URL into constituent parts,\n * such as path, host, port, etc.\n *\n * @param {String} urlString The URL string to parse\n * @returns {Object} Parsed URL object\n */\nfunction parse(urlString) {\n  let url = {\n      protocol: {\n        value: undefined,\n        beginIndex: 0,\n        endIndex: 0\n      },\n      auth: {\n        value: undefined,\n        beginIndex: 0,\n        endIndex: 0\n      },\n      host: {\n        value: undefined,\n        beginIndex: 0,\n        endIndex: 0\n      },\n      port: {\n        value: undefined,\n        beginIndex: 0,\n        endIndex: 0\n      },\n      path: {\n        value: undefined,\n        beginIndex: 0,\n        endIndex: 0\n      },\n      query: {\n        value: undefined,\n        beginIndex: 0,\n        endIndex: 0\n      },\n      hash: {\n        value: undefined,\n        beginIndex: 0,\n        endIndex: 0\n      }\n    },\n    parsedUrl = {\n      raw: urlString,\n      protocol: undefined,\n      auth: undefined,\n      host: undefined,\n      port: undefined,\n      path: undefined,\n      query: undefined,\n      hash: undefined\n    },\n    replacements = new ReplacementTracker(),\n    pointer = 0,\n    _length,\n    length,\n    index,\n    port;\n\n  // bail out if input string is empty\n  if (!(urlString && typeof urlString === STRING)) {\n    return parsedUrl;\n  }\n\n  // trim leading whitespace characters\n  parsedUrl.raw = urlString = urlString.trimLeft();\n\n  // normalize the given string\n  urlString = normalizeVariables(urlString, replacements);\n  length = urlString.length;\n\n  // 1. url.hash\n  if ((index = urlString.indexOf(HASH_SEPARATOR)) !== -1) {\n    // extract from the back\n    url.hash.value = urlString.slice(index + 1);\n    url.hash.beginIndex = pointer + index + 1;\n    url.hash.endIndex = pointer + length;\n    urlString = urlString.slice(0, length = index);\n  }\n\n  // 2. url.query\n  if ((index = urlString.indexOf(QUERY_SEPARATOR)) !== -1) {\n    // extract from the back\n    url.query.value = urlString.slice(index + 1).split(QUERY_SEGMENTS_SEPARATOR);\n    url.query.beginIndex = pointer + index + 1;\n    url.query.endIndex = pointer + length;\n    urlString = urlString.slice(0, length = index);\n  }\n\n  // 3. url.protocol\n  urlString = urlString.replace(REGEX_ALL_BACKSLASHES, PATH_SEPARATOR); // sanitize slashes\n\n  // @todo support `protocol:host/path` and `protocol:/host/path`\n  if ((index = urlString.indexOf(PROTOCOL_SEPARATOR)) !== -1) {\n    // extract from the front\n    url.protocol.value = urlString.slice(0, index);\n    url.protocol.beginIndex = pointer;\n    url.protocol.endIndex = pointer + index;\n    urlString = urlString.slice(index + 3);\n    length -= index + 3;\n    pointer += index + 3;\n\n    // special handling for extra slashes in protocol e.g, http:///example.com\n    _length = length; // length with leading slashes\n\n    urlString = urlString.replace(REGEX_LEADING_SLASHES, url.protocol.value.toLowerCase() === FILE_PROTOCOL ?\n    // file:////path -> file:///path\n    PATH_SEPARATOR :\n    // protocol:////host/path -> protocol://host/path\n    E);\n    length = urlString.length; // length without slashes\n    pointer += _length - length; // update pointer\n  }\n\n  // 4. url.path\n  if ((index = urlString.indexOf(PATH_SEPARATOR)) !== -1) {\n    // extract from the back\n    url.path.value = urlString.slice(index + 1).split(PATH_SEPARATOR);\n    url.path.beginIndex = pointer + index + 1;\n    url.path.endIndex = pointer + length;\n    urlString = urlString.slice(0, length = index);\n  }\n\n  // 5. url.auth\n  if ((index = urlString.lastIndexOf(AUTH_SEPARATOR)) !== -1) {\n    // extract from the front\n    url.auth.value = urlString.slice(0, index);\n    url.auth.beginIndex = pointer;\n    url.auth.endIndex = pointer + index;\n    urlString = urlString.slice(index + 1);\n    length -= index + 1;\n    pointer += index + 1;\n\n    // separate username:password\n    if ((index = url.auth.value.indexOf(AUTH_SEGMENTS_SEPARATOR)) !== -1) {\n      url.auth.value = [url.auth.value.slice(0, index), url.auth.value.slice(index + 1)];\n    } else {\n      url.auth.value = [url.auth.value];\n    }\n  }\n\n  // 6. url.port\n  if ((index = urlString.lastIndexOf(PORT_SEPARATOR)) !== -1 &&\n  // eslint-disable-next-line lodash/prefer-includes\n  (port = urlString.slice(index + 1)).indexOf(CLOSING_SQUARE_BRACKET) === -1) {\n    // extract from the back\n    url.port.value = port;\n    url.port.beginIndex = pointer + index + 1;\n    url.port.endIndex = pointer + length;\n    urlString = urlString.slice(0, length = index);\n  }\n\n  // 7. url.host\n  if (urlString) {\n    url.host.value = urlString.split(DOMAIN_SEPARATOR);\n    url.host.beginIndex = pointer;\n    url.host.endIndex = pointer + length;\n  }\n\n  // apply replacements back, if any\n  replacements.count() && applyReplacements(url, replacements);\n\n  // finally, prepare parsed url\n  parsedUrl.protocol = url.protocol.value;\n  parsedUrl.auth = url.auth.value;\n  parsedUrl.host = url.host.value;\n  parsedUrl.port = url.port.value;\n  parsedUrl.path = url.path.value;\n  parsedUrl.query = url.query.value;\n  parsedUrl.hash = url.hash.value;\n  return parsedUrl;\n}\nmodule.exports = {\n  parse\n};","map":{"version":3,"names":["ReplacementTracker","require","REGEX_ALL_BACKSLASHES","REGEX_LEADING_SLASHES","REGEX_ALL_VARIABLES","HASH_SEPARATOR","PATH_SEPARATOR","PORT_SEPARATOR","AUTH_SEPARATOR","QUERY_SEPARATOR","DOMAIN_SEPARATOR","PROTOCOL_SEPARATOR","AUTH_SEGMENTS_SEPARATOR","QUERY_SEGMENTS_SEPARATOR","E","STRING","FILE_PROTOCOL","SAFE_REPLACE_CHAR","CLOSING_SQUARE_BRACKET","URL_PROPERTIES_ORDER","normalizeVariables","str","replacements","normalizedString","pointer","variable","match","index","exec","slice","add","length","applyReplacements","url","i","ii","prop","value","apply","beginIndex","endIndex","parse","urlString","protocol","undefined","auth","host","port","path","query","hash","parsedUrl","raw","_length","trimLeft","indexOf","split","replace","toLowerCase","lastIndexOf","count","module","exports"],"sources":["/Users/Qusai.Qishta/node_modules/postman-url-encoder/parser/index.js"],"sourcesContent":["/**\n * This module helps to break URL strings up into components\n * (protocol, auth, host, port, path, query, and hash) keeping the variables\n * intact.\n *\n * @example\n * const parser = require('postman-url-encoder/parser')\n *\n * // returns\n * // {\n * //   raw: 'protocol://{{user}}:{{p@ssw?rd}}@{{host.name}}.com:{{#port}}/p/a/t/h?q=query#hash',\n * //   protocol: 'protocol',\n * //   auth: [ '{{user}}', '{{p@ssw?rd}}' ],\n * //   host: [ '{{host.name}}', 'com' ],\n * //   port: '{{#port}}',\n * //   path: [ 'p', 'a', 't', 'h' ],\n * //   query: [ 'q=query' ],\n * //   hash: 'hash'\n * // }\n * parser.parse('protocol://{{user}}:{{p@ssw?rd}}@{{host.name}}.com:{{#port}}/p/a/t/h?q=query#hash')\n *\n * @module postman-url-encoder/parser\n */\n\nconst ReplacementTracker = require('./replacement-tracker'),\n\n    REGEX_ALL_BACKSLASHES = /\\\\/g,\n    REGEX_LEADING_SLASHES = /^\\/+/,\n    REGEX_ALL_VARIABLES = /{{[^{}]*[.:/?#@&\\]][^{}]*}}/g,\n\n    HASH_SEPARATOR = '#',\n    PATH_SEPARATOR = '/',\n    PORT_SEPARATOR = ':',\n    AUTH_SEPARATOR = '@',\n    QUERY_SEPARATOR = '?',\n    DOMAIN_SEPARATOR = '.',\n    PROTOCOL_SEPARATOR = '://',\n    AUTH_SEGMENTS_SEPARATOR = ':',\n    QUERY_SEGMENTS_SEPARATOR = '&',\n\n    E = '',\n    STRING = 'string',\n    FILE_PROTOCOL = 'file',\n    SAFE_REPLACE_CHAR = '_',\n    CLOSING_SQUARE_BRACKET = ']',\n    URL_PROPERTIES_ORDER = ['protocol', 'auth', 'host', 'port', 'path', 'query', 'hash'];\n\n/**\n * Normalize the given string by replacing the variables which includes\n * reserved characters in its name.\n * The replaced characters are added to the given replacement tracker instance.\n *\n * @private\n * @param {String} str String to normalize\n * @param {ReplacementTracker} replacements ReplacementTracker instance\n * @returns {String} Normalized string\n */\nfunction normalizeVariables (str, replacements) {\n    let normalizedString = E,\n        pointer = 0, // pointer till witch the string is normalized\n        variable,\n        match,\n        index;\n\n    // find all the instances of {{<variable>}} which includes reserved chars\n    // \"Hello {{user#name}}!!!\"\n    //  ↑ (pointer = 0)\n    while ((match = REGEX_ALL_VARIABLES.exec(str)) !== null) {\n        // {{user#name}}\n        variable = match[0];\n\n        // starting index of the {{variable}} in the string\n        // \"Hello {{user#name}}!!!\"\n        //        ↑ (index = 6)\n        index = match.index;\n\n        // [pointer, index) string is normalized + the safe replacement character\n        // \"Hello \" + \"_\"\n        normalizedString += str.slice(pointer, index) + SAFE_REPLACE_CHAR;\n\n        // track the replacement done for the {{variable}}\n        replacements.add(variable, index);\n\n        // update the pointer\n        // \"Hello {{user#name}}!!!\"\n        //                     ↑ (pointer = 19)\n        pointer = index + variable.length;\n    }\n\n    // avoid slicing the string in case of no matches\n    if (pointer === 0) {\n        return str;\n    }\n\n    // whatever left in the string is normalized as well\n    /* istanbul ignore else */\n    if (pointer < str.length) {\n        // \"Hello _\" + \"!!!\"\n        normalizedString += str.slice(pointer);\n    }\n\n    return normalizedString;\n}\n\n/**\n * Update replaced characters in the URL object with its original value.\n *\n * @private\n * @param {Object} url URL tracker object\n * @param {ReplacementTracker} replacements ReplacementTracker instance\n */\nfunction applyReplacements (url, replacements) {\n    let i,\n        ii,\n        prop;\n\n    // traverse each URL property in the given order\n    for (i = 0, ii = URL_PROPERTIES_ORDER.length; i < ii; ++i) {\n        prop = url[URL_PROPERTIES_ORDER[i]];\n\n        // bail out if the given property is not set (undefined or '')\n        if (!(prop && prop.value)) {\n            continue;\n        }\n\n        prop.value = replacements.apply(prop.value, prop.beginIndex, prop.endIndex);\n    }\n\n    return url;\n}\n\n/**\n * Parses the input string by decomposing the URL into constituent parts,\n * such as path, host, port, etc.\n *\n * @param {String} urlString The URL string to parse\n * @returns {Object} Parsed URL object\n */\nfunction parse (urlString) {\n    let url = {\n            protocol: { value: undefined, beginIndex: 0, endIndex: 0 },\n            auth: { value: undefined, beginIndex: 0, endIndex: 0 },\n            host: { value: undefined, beginIndex: 0, endIndex: 0 },\n            port: { value: undefined, beginIndex: 0, endIndex: 0 },\n            path: { value: undefined, beginIndex: 0, endIndex: 0 },\n            query: { value: undefined, beginIndex: 0, endIndex: 0 },\n            hash: { value: undefined, beginIndex: 0, endIndex: 0 }\n        },\n        parsedUrl = {\n            raw: urlString,\n            protocol: undefined,\n            auth: undefined,\n            host: undefined,\n            port: undefined,\n            path: undefined,\n            query: undefined,\n            hash: undefined\n        },\n        replacements = new ReplacementTracker(),\n        pointer = 0,\n        _length,\n        length,\n        index,\n        port;\n\n    // bail out if input string is empty\n    if (!(urlString && typeof urlString === STRING)) {\n        return parsedUrl;\n    }\n\n    // trim leading whitespace characters\n    parsedUrl.raw = urlString = urlString.trimLeft();\n\n    // normalize the given string\n    urlString = normalizeVariables(urlString, replacements);\n    length = urlString.length;\n\n    // 1. url.hash\n    if ((index = urlString.indexOf(HASH_SEPARATOR)) !== -1) {\n        // extract from the back\n        url.hash.value = urlString.slice(index + 1);\n        url.hash.beginIndex = pointer + index + 1;\n        url.hash.endIndex = pointer + length;\n\n        urlString = urlString.slice(0, (length = index));\n    }\n\n    // 2. url.query\n    if ((index = urlString.indexOf(QUERY_SEPARATOR)) !== -1) {\n        // extract from the back\n        url.query.value = urlString.slice(index + 1).split(QUERY_SEGMENTS_SEPARATOR);\n        url.query.beginIndex = pointer + index + 1;\n        url.query.endIndex = pointer + length;\n\n        urlString = urlString.slice(0, (length = index));\n    }\n\n    // 3. url.protocol\n    urlString = urlString.replace(REGEX_ALL_BACKSLASHES, PATH_SEPARATOR); // sanitize slashes\n\n    // @todo support `protocol:host/path` and `protocol:/host/path`\n    if ((index = urlString.indexOf(PROTOCOL_SEPARATOR)) !== -1) {\n        // extract from the front\n        url.protocol.value = urlString.slice(0, index);\n        url.protocol.beginIndex = pointer;\n        url.protocol.endIndex = pointer + index;\n\n        urlString = urlString.slice(index + 3);\n        length -= index + 3;\n        pointer += index + 3;\n\n        // special handling for extra slashes in protocol e.g, http:///example.com\n        _length = length; // length with leading slashes\n\n        urlString = urlString.replace(REGEX_LEADING_SLASHES,\n            (url.protocol.value.toLowerCase() === FILE_PROTOCOL) ?\n                // file:////path -> file:///path\n                PATH_SEPARATOR :\n                // protocol:////host/path -> protocol://host/path\n                E);\n\n        length = urlString.length; // length without slashes\n        pointer += _length - length; // update pointer\n    }\n\n    // 4. url.path\n    if ((index = urlString.indexOf(PATH_SEPARATOR)) !== -1) {\n        // extract from the back\n        url.path.value = urlString.slice(index + 1).split(PATH_SEPARATOR);\n        url.path.beginIndex = pointer + index + 1;\n        url.path.endIndex = pointer + length;\n\n        urlString = urlString.slice(0, (length = index));\n    }\n\n    // 5. url.auth\n    if ((index = urlString.lastIndexOf(AUTH_SEPARATOR)) !== -1) {\n        // extract from the front\n        url.auth.value = urlString.slice(0, index);\n        url.auth.beginIndex = pointer;\n        url.auth.endIndex = pointer + index;\n\n        urlString = urlString.slice(index + 1);\n        length -= index + 1;\n        pointer += index + 1;\n\n        // separate username:password\n        if ((index = url.auth.value.indexOf(AUTH_SEGMENTS_SEPARATOR)) !== -1) {\n            url.auth.value = [url.auth.value.slice(0, index), url.auth.value.slice(index + 1)];\n        }\n        else {\n            url.auth.value = [url.auth.value];\n        }\n    }\n\n    // 6. url.port\n    if ((index = urlString.lastIndexOf(PORT_SEPARATOR)) !== -1 &&\n        // eslint-disable-next-line lodash/prefer-includes\n        (port = urlString.slice(index + 1)).indexOf(CLOSING_SQUARE_BRACKET) === -1\n    ) {\n        // extract from the back\n        url.port.value = port;\n        url.port.beginIndex = pointer + index + 1;\n        url.port.endIndex = pointer + length;\n\n        urlString = urlString.slice(0, (length = index));\n    }\n\n    // 7. url.host\n    if (urlString) {\n        url.host.value = urlString.split(DOMAIN_SEPARATOR);\n        url.host.beginIndex = pointer;\n        url.host.endIndex = pointer + length;\n    }\n\n    // apply replacements back, if any\n    replacements.count() && applyReplacements(url, replacements);\n\n    // finally, prepare parsed url\n    parsedUrl.protocol = url.protocol.value;\n    parsedUrl.auth = url.auth.value;\n    parsedUrl.host = url.host.value;\n    parsedUrl.port = url.port.value;\n    parsedUrl.path = url.path.value;\n    parsedUrl.query = url.query.value;\n    parsedUrl.hash = url.hash.value;\n\n    return parsedUrl;\n}\n\nmodule.exports = {\n    parse\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}