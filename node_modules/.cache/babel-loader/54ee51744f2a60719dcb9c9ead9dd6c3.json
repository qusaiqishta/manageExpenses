{"ast":null,"code":"var _ = require('../util').lodash,\n  Property = require('../collection/property').Property,\n  Url = require('../collection/url').Url,\n  STRING = 'string',\n  UNDEFINED = 'undefined',\n  MATCH_ALL = '*',\n  PREFIX_DELIMITER = '^',\n  PROTOCOL_DELIMITER = '+',\n  POSTFIX_DELIMITER = '$',\n  MATCH_ALL_URLS = '<all_urls>',\n  ALLOWED_PROTOCOLS = ['http', 'https', 'file', 'ftp'],\n  ALLOWED_PROTOCOLS_REGEX = ALLOWED_PROTOCOLS.join('|'),\n  // @todo initialize this and ALLOWED_PROTOCOLS via UrlMatchPattern options\n  DEFAULT_PROTOCOL_PORT = {\n    ftp: '21',\n    http: '80',\n    https: '443'\n  },\n  regexes = {\n    escapeMatcher: /[.+^${}()|[\\]\\\\]/g,\n    escapeMatchReplacement: '\\\\$&',\n    questionmarkMatcher: /\\?/g,\n    questionmarkReplacment: '.',\n    starMatcher: '*',\n    starReplacement: '.*',\n    // @todo match valid HOST name\n    // @note PATH is required(can be empty '/' or '/*') i.e, {PROTOCOL}://{HOST}/\n    patternSplit: '^((' + ALLOWED_PROTOCOLS_REGEX + '|\\\\*)(\\\\+(' + ALLOWED_PROTOCOLS_REGEX + '))*)://(\\\\*|\\\\*\\\\.[^*/:]+|[^*/:]+)(:\\\\*|:\\\\d+)?(/.*)$'\n  },\n  UrlMatchPattern;\n\n/**\n * @typedef UrlMatchPattern.definition\n * @property {String} pattern The url match pattern string\n */\n_.inherit(\n/**\n * UrlMatchPattern allows to create rules to define Urls to match for.\n * It is based on Google's Match Pattern - https://developer.chrome.com/extensions/match_patterns\n *\n * @constructor\n * @extends {Property}\n * @param {UrlMatchPattern.definition} options -\n *\n * @example <caption>An example UrlMatchPattern</caption>\n * var matchPattern = new UrlMatchPattern('https://*.google.com/*');\n*/\nUrlMatchPattern = function UrlMatchPattern(options) {\n  // called as new UrlMatchPattern('https+http://*.example.com/*')\n  if (_.isString(options)) {\n    options = {\n      pattern: options\n    };\n  }\n\n  // this constructor is intended to inherit and as such the super constructor is required to be executed\n  UrlMatchPattern.super_.apply(this, arguments);\n\n  // Assign defaults before proceeding\n  _.assign(this, /** @lends UrlMatchPattern */{\n    /**\n     * The url match pattern string\n     *\n     * @type {String}\n     */\n    pattern: MATCH_ALL_URLS\n  });\n  this.update(options);\n}, Property);\n_.assign(UrlMatchPattern.prototype, /** @lends UrlMatchPattern.prototype */{\n  /**\n   * Assigns the given properties to the UrlMatchPattern.\n   *\n   * @param {{ pattern: (string) }} options -\n   */\n  update(options) {\n    _.has(options, 'pattern') && _.isString(options.pattern) && !_.isEmpty(options.pattern) && (this.pattern = options.pattern);\n\n    // create a match pattern and store it on cache\n    this._matchPatternObject = this.createMatchPattern();\n  },\n  /**\n   * Used to generate the match regex object from the match string we have.\n   *\n   * @private\n   * @returns {*} Match regex object\n   */\n  createMatchPattern() {\n    var matchPattern = this.pattern,\n      // Check the match pattern of sanity and split it into protocol, host and path\n      match = matchPattern.match(regexes.patternSplit);\n    if (!match) {\n      // This ensures it is a invalid match pattern\n      return;\n    }\n    return {\n      protocols: _.uniq(match[1].split(PROTOCOL_DELIMITER)),\n      host: match[5],\n      port: match[6] && match[6].substr(1),\n      // remove leading `:`\n      path: this.globPatternToRegexp(match[7])\n    };\n  },\n  /**\n   * Converts a given glob pattern into a regular expression.\n   *\n   * @private\n   * @param {String} pattern Glob pattern string\n   * @returns {RegExp=}\n   */\n  globPatternToRegexp(pattern) {\n    // Escape everything except ? and *.\n    pattern = pattern.replace(regexes.escapeMatcher, regexes.escapeMatchReplacement);\n    pattern = pattern.replace(regexes.questionmarkMatcher, regexes.questionmarkReplacment);\n    pattern = pattern.replace(regexes.starMatcher, regexes.starReplacement);\n\n    // eslint-disable-next-line security/detect-non-literal-regexp\n    return new RegExp(PREFIX_DELIMITER + pattern + POSTFIX_DELIMITER);\n  },\n  /**\n   * Tests if the given protocol string, is allowed by the pattern.\n   *\n   * @param {String=} protocol The protocol to be checked if the pattern allows.\n   * @returns {Boolean=}\n   */\n  testProtocol(protocol) {\n    var matchRegexObject = this._matchPatternObject;\n    return _.includes(ALLOWED_PROTOCOLS, protocol) && (_.includes(matchRegexObject.protocols, MATCH_ALL) || _.includes(matchRegexObject.protocols, protocol));\n  },\n  /**\n   * Returns the protocols supported\n   *\n   * @returns {Array.<String>}\n   */\n  getProtocols() {\n    return _.get(this, '_matchPatternObject.protocols') || [];\n  },\n  /**\n   * Tests if the given host string, is allowed by the pattern.\n   *\n   * @param {String=} host The host to be checked if the pattern allows.\n   * @returns {Boolean=}\n   */\n  testHost(host) {\n    /*\n    * For Host match, we are considering the port with the host, hence we are using getRemote() instead of getHost()\n    * We need to address three cases for the host urlStr\n    * 1. * It matches all the host + protocol,  hence we are not having any parsing logic for it.\n    * 2. *.foo.bar.com Here the prefix could be anything but it should end with foo.bar.com\n    * 3. foo.bar.com This is the absolute matching needs to done.\n    */\n    var matchRegexObject = this._matchPatternObject;\n    return this.matchAnyHost(matchRegexObject) || this.matchAbsoluteHostPattern(matchRegexObject, host) || this.matchSuffixHostPattern(matchRegexObject, host);\n  },\n  /**\n   * Checks whether the matchRegexObject has the MATCH_ALL host.\n   *\n   * @private\n   * @param {Object=} matchRegexObject The regex object generated by the createMatchPattern function.\n   * @returns {Boolean}\n   */\n  matchAnyHost(matchRegexObject) {\n    return matchRegexObject.host === MATCH_ALL;\n  },\n  /**\n    * Check for the (*.foo.bar.com) kind of matches with the remote provided.\n   *\n    * @private\n    * @param {Object=} matchRegexObject The regex object generated by the createMatchPattern function.\n    * @param {String=} remote The remote url (host+port) of the url for which the hostpattern needs to checked\n    * @returns {Boolean}\n    */\n  matchSuffixHostPattern(matchRegexObject, remote) {\n    var hostSuffix = matchRegexObject.host.substr(2);\n    return matchRegexObject.host[0] === MATCH_ALL && (remote === hostSuffix || remote.endsWith('.' + hostSuffix));\n  },\n  /**\n   * Check for the absolute host match.\n   *\n   * @private\n   * @param {Object=} matchRegexObject The regex object generated by the createMatchPattern function.\n   * @param {String=} remote The remote url, host+port of the url for which the hostpattern needs to checked\n   * @returns {Boolean}\n   */\n  matchAbsoluteHostPattern(matchRegexObject, remote) {\n    return matchRegexObject.host === remote;\n  },\n  /**\n   * Tests if the current pattern allows the given port.\n   *\n   * @param {String} port The port to be checked if the pattern allows.\n   * @param {String} protocol Protocol to refer default port.\n   * @returns {Boolean}\n   */\n  testPort(port, protocol) {\n    var portRegex = this._matchPatternObject.port,\n      // default port for given protocol\n      defaultPort = protocol && DEFAULT_PROTOCOL_PORT[protocol];\n\n    // return true if both given port and match pattern are absent\n    if (typeof port === UNDEFINED && typeof portRegex === UNDEFINED) {\n      return true;\n    }\n\n    // convert integer port to string\n    port && typeof port !== STRING && (port = String(port));\n\n    // assign default port or portRegex\n    !port && (port = defaultPort);\n    !portRegex && (portRegex = defaultPort);\n\n    // matches * or specific port\n    return portRegex === MATCH_ALL || portRegex === port;\n  },\n  /**\n   * Tests if the current pattern allows the given path.\n   *\n   * @param {String=} path The path to be checked if the pattern allows.\n   * @returns {Boolean=}\n   */\n  testPath(path) {\n    var matchRegexObject = this._matchPatternObject;\n    return !_.isEmpty(path.match(matchRegexObject.path));\n  },\n  /**\n    * Tests the url string with the match pattern provided.\n    * Follows the https://developer.chrome.com/extensions/match_patterns pattern for pattern validation and matching\n    *\n    * @param {String=} urlStr The url string for which the proxy match needs to be done.\n    * @returns {Boolean=}\n    */\n  test(urlStr) {\n    /*\n    * This function executes the code in the following sequence for early return avoiding the costly regex matches.\n    * To avoid most of the memory consuming code.\n    * 1. It check whether the match string is <all_urls> in that case, it return immediately without any further\n    *    processing.\n    * 2. Checks whether the matchPattern follows the rules, https://developer.chrome.com/extensions/match_patterns,\n    *    If not then, don't process it.\n    * 3. Check for the protocol, as it is a normal array check.\n    * 4. Checks the host, as it doesn't involve regex match and has only string comparisons.\n    * 5. Finally, checks for the path, which actually involves the Regex matching, the slow process.\n    */\n    // If the matchPattern is <all_urls> then there is no need for any validations.\n    if (this.pattern === MATCH_ALL_URLS) {\n      return true;\n    }\n\n    // Empty _matchPatternObject represents the match is INVALID match\n    if (_.isEmpty(this._matchPatternObject)) {\n      return false;\n    }\n    const url = new Url(urlStr);\n    return this.testProtocol(url.protocol) && this.testHost(url.getHost()) && this.testPort(url.port, url.protocol) && this.testPath(url.getPath());\n  },\n  /**\n   * Returns a string representation of the match pattern\n   *\n   * @returns {String} pattern\n   */\n  toString() {\n    return String(this.pattern);\n  },\n  /**\n   * Returns the JSON representation.\n   *\n   * @returns {{ pattern: (String) }}\n   */\n  toJSON() {\n    var pattern;\n    pattern = this.toString();\n    return {\n      pattern\n    };\n  }\n});\n_.assign(UrlMatchPattern, /** @lends UrlMatchPattern */{\n  /**\n   * Defines the name of this property for internal use\n   *\n   * @private\n   * @readOnly\n   * @type {String}\n   */\n  _postman_propertyName: 'UrlMatchPattern',\n  /**\n   * Multiple protocols in the match pattern should be separated by this string\n   *\n   * @readOnly\n   * @type {String}\n   */\n  PROTOCOL_DELIMITER: PROTOCOL_DELIMITER,\n  /**\n   * String representation for matching all urls - <all_urls>\n   *\n   * @readOnly\n   * @type {String}\n   */\n  MATCH_ALL_URLS: MATCH_ALL_URLS\n});\nmodule.exports = {\n  UrlMatchPattern\n};","map":{"version":3,"names":["_","require","lodash","Property","Url","STRING","UNDEFINED","MATCH_ALL","PREFIX_DELIMITER","PROTOCOL_DELIMITER","POSTFIX_DELIMITER","MATCH_ALL_URLS","ALLOWED_PROTOCOLS","ALLOWED_PROTOCOLS_REGEX","join","DEFAULT_PROTOCOL_PORT","ftp","http","https","regexes","escapeMatcher","escapeMatchReplacement","questionmarkMatcher","questionmarkReplacment","starMatcher","starReplacement","patternSplit","UrlMatchPattern","inherit","options","isString","pattern","super_","apply","arguments","assign","update","prototype","has","isEmpty","_matchPatternObject","createMatchPattern","matchPattern","match","protocols","uniq","split","host","port","substr","path","globPatternToRegexp","replace","RegExp","testProtocol","protocol","matchRegexObject","includes","getProtocols","get","testHost","matchAnyHost","matchAbsoluteHostPattern","matchSuffixHostPattern","remote","hostSuffix","endsWith","testPort","portRegex","defaultPort","String","testPath","test","urlStr","url","getHost","getPath","toString","toJSON","_postman_propertyName","module","exports"],"sources":["/Users/Qusai.Qishta/node_modules/postman-collection/lib/url-pattern/url-match-pattern.js"],"sourcesContent":["var _ = require('../util').lodash,\n    Property = require('../collection/property').Property,\n    Url = require('../collection/url').Url,\n\n    STRING = 'string',\n    UNDEFINED = 'undefined',\n\n    MATCH_ALL = '*',\n    PREFIX_DELIMITER = '^',\n    PROTOCOL_DELIMITER = '+',\n    POSTFIX_DELIMITER = '$',\n    MATCH_ALL_URLS = '<all_urls>',\n    ALLOWED_PROTOCOLS = ['http', 'https', 'file', 'ftp'],\n    ALLOWED_PROTOCOLS_REGEX = ALLOWED_PROTOCOLS.join('|'),\n\n    // @todo initialize this and ALLOWED_PROTOCOLS via UrlMatchPattern options\n    DEFAULT_PROTOCOL_PORT = {\n        ftp: '21',\n        http: '80',\n        https: '443'\n    },\n\n    regexes = {\n        escapeMatcher: /[.+^${}()|[\\]\\\\]/g,\n        escapeMatchReplacement: '\\\\$&',\n        questionmarkMatcher: /\\?/g,\n        questionmarkReplacment: '.',\n        starMatcher: '*',\n        starReplacement: '.*',\n        // @todo match valid HOST name\n        // @note PATH is required(can be empty '/' or '/*') i.e, {PROTOCOL}://{HOST}/\n        patternSplit: '^((' + ALLOWED_PROTOCOLS_REGEX + '|\\\\*)(\\\\+(' + ALLOWED_PROTOCOLS_REGEX +\n            '))*)://(\\\\*|\\\\*\\\\.[^*/:]+|[^*/:]+)(:\\\\*|:\\\\d+)?(/.*)$'\n    },\n\n    UrlMatchPattern;\n\n/**\n * @typedef UrlMatchPattern.definition\n * @property {String} pattern The url match pattern string\n */\n_.inherit((\n\n    /**\n     * UrlMatchPattern allows to create rules to define Urls to match for.\n     * It is based on Google's Match Pattern - https://developer.chrome.com/extensions/match_patterns\n     *\n     * @constructor\n     * @extends {Property}\n     * @param {UrlMatchPattern.definition} options -\n     *\n     * @example <caption>An example UrlMatchPattern</caption>\n     * var matchPattern = new UrlMatchPattern('https://*.google.com/*');\n    */\n    UrlMatchPattern = function UrlMatchPattern (options) {\n        // called as new UrlMatchPattern('https+http://*.example.com/*')\n        if (_.isString(options)) {\n            options = { pattern: options };\n        }\n\n        // this constructor is intended to inherit and as such the super constructor is required to be executed\n        UrlMatchPattern.super_.apply(this, arguments);\n\n        // Assign defaults before proceeding\n        _.assign(this, /** @lends UrlMatchPattern */ {\n            /**\n             * The url match pattern string\n             *\n             * @type {String}\n             */\n            pattern: MATCH_ALL_URLS\n        });\n\n        this.update(options);\n    }), Property);\n\n_.assign(UrlMatchPattern.prototype, /** @lends UrlMatchPattern.prototype */ {\n    /**\n     * Assigns the given properties to the UrlMatchPattern.\n     *\n     * @param {{ pattern: (string) }} options -\n     */\n    update (options) {\n        _.has(options, 'pattern') && (_.isString(options.pattern) && !_.isEmpty(options.pattern)) &&\n            (this.pattern = options.pattern);\n\n        // create a match pattern and store it on cache\n        this._matchPatternObject = this.createMatchPattern();\n    },\n\n    /**\n     * Used to generate the match regex object from the match string we have.\n     *\n     * @private\n     * @returns {*} Match regex object\n     */\n    createMatchPattern () {\n        var matchPattern = this.pattern,\n            // Check the match pattern of sanity and split it into protocol, host and path\n            match = matchPattern.match(regexes.patternSplit);\n\n        if (!match) {\n            // This ensures it is a invalid match pattern\n            return;\n        }\n\n        return {\n            protocols: _.uniq(match[1].split(PROTOCOL_DELIMITER)),\n            host: match[5],\n            port: match[6] && match[6].substr(1), // remove leading `:`\n            path: this.globPatternToRegexp(match[7])\n        };\n    },\n\n    /**\n     * Converts a given glob pattern into a regular expression.\n     *\n     * @private\n     * @param {String} pattern Glob pattern string\n     * @returns {RegExp=}\n     */\n    globPatternToRegexp (pattern) {\n        // Escape everything except ? and *.\n        pattern = pattern.replace(regexes.escapeMatcher, regexes.escapeMatchReplacement);\n        pattern = pattern.replace(regexes.questionmarkMatcher, regexes.questionmarkReplacment);\n        pattern = pattern.replace(regexes.starMatcher, regexes.starReplacement);\n\n        // eslint-disable-next-line security/detect-non-literal-regexp\n        return new RegExp(PREFIX_DELIMITER + pattern + POSTFIX_DELIMITER);\n    },\n\n    /**\n     * Tests if the given protocol string, is allowed by the pattern.\n     *\n     * @param {String=} protocol The protocol to be checked if the pattern allows.\n     * @returns {Boolean=}\n     */\n    testProtocol (protocol) {\n        var matchRegexObject = this._matchPatternObject;\n\n        return _.includes(ALLOWED_PROTOCOLS, protocol) &&\n            (_.includes(matchRegexObject.protocols, MATCH_ALL) || _.includes(matchRegexObject.protocols, protocol));\n    },\n\n    /**\n     * Returns the protocols supported\n     *\n     * @returns {Array.<String>}\n     */\n    getProtocols () {\n        return _.get(this, '_matchPatternObject.protocols') || [];\n    },\n\n    /**\n     * Tests if the given host string, is allowed by the pattern.\n     *\n     * @param {String=} host The host to be checked if the pattern allows.\n     * @returns {Boolean=}\n     */\n    testHost (host) {\n        /*\n        * For Host match, we are considering the port with the host, hence we are using getRemote() instead of getHost()\n        * We need to address three cases for the host urlStr\n        * 1. * It matches all the host + protocol,  hence we are not having any parsing logic for it.\n        * 2. *.foo.bar.com Here the prefix could be anything but it should end with foo.bar.com\n        * 3. foo.bar.com This is the absolute matching needs to done.\n        */\n        var matchRegexObject = this._matchPatternObject;\n\n        return (\n            this.matchAnyHost(matchRegexObject) ||\n            this.matchAbsoluteHostPattern(matchRegexObject, host) ||\n            this.matchSuffixHostPattern(matchRegexObject, host)\n        );\n    },\n\n    /**\n     * Checks whether the matchRegexObject has the MATCH_ALL host.\n     *\n     * @private\n     * @param {Object=} matchRegexObject The regex object generated by the createMatchPattern function.\n     * @returns {Boolean}\n     */\n    matchAnyHost (matchRegexObject) {\n        return matchRegexObject.host === MATCH_ALL;\n    },\n\n\n    /**\n      * Check for the (*.foo.bar.com) kind of matches with the remote provided.\n     *\n      * @private\n      * @param {Object=} matchRegexObject The regex object generated by the createMatchPattern function.\n      * @param {String=} remote The remote url (host+port) of the url for which the hostpattern needs to checked\n      * @returns {Boolean}\n      */\n    matchSuffixHostPattern (matchRegexObject, remote) {\n        var hostSuffix = matchRegexObject.host.substr(2);\n\n        return matchRegexObject.host[0] === MATCH_ALL && (remote === hostSuffix || remote.endsWith('.' + hostSuffix));\n    },\n\n    /**\n     * Check for the absolute host match.\n     *\n     * @private\n     * @param {Object=} matchRegexObject The regex object generated by the createMatchPattern function.\n     * @param {String=} remote The remote url, host+port of the url for which the hostpattern needs to checked\n     * @returns {Boolean}\n     */\n    matchAbsoluteHostPattern (matchRegexObject, remote) {\n        return matchRegexObject.host === remote;\n    },\n\n    /**\n     * Tests if the current pattern allows the given port.\n     *\n     * @param {String} port The port to be checked if the pattern allows.\n     * @param {String} protocol Protocol to refer default port.\n     * @returns {Boolean}\n     */\n    testPort (port, protocol) {\n        var portRegex = this._matchPatternObject.port,\n\n            // default port for given protocol\n            defaultPort = protocol && DEFAULT_PROTOCOL_PORT[protocol];\n\n        // return true if both given port and match pattern are absent\n        if (typeof port === UNDEFINED && typeof portRegex === UNDEFINED) {\n            return true;\n        }\n\n        // convert integer port to string\n        (port && typeof port !== STRING) && (port = String(port));\n\n        // assign default port or portRegex\n        !port && (port = defaultPort);\n        !portRegex && (portRegex = defaultPort);\n\n        // matches * or specific port\n        return (\n            portRegex === MATCH_ALL ||\n            portRegex === port\n        );\n    },\n\n    /**\n     * Tests if the current pattern allows the given path.\n     *\n     * @param {String=} path The path to be checked if the pattern allows.\n     * @returns {Boolean=}\n     */\n    testPath (path) {\n        var matchRegexObject = this._matchPatternObject;\n\n        return !_.isEmpty(path.match(matchRegexObject.path));\n    },\n\n    /**\n      * Tests the url string with the match pattern provided.\n      * Follows the https://developer.chrome.com/extensions/match_patterns pattern for pattern validation and matching\n      *\n      * @param {String=} urlStr The url string for which the proxy match needs to be done.\n      * @returns {Boolean=}\n      */\n    test (urlStr) {\n        /*\n        * This function executes the code in the following sequence for early return avoiding the costly regex matches.\n        * To avoid most of the memory consuming code.\n        * 1. It check whether the match string is <all_urls> in that case, it return immediately without any further\n        *    processing.\n        * 2. Checks whether the matchPattern follows the rules, https://developer.chrome.com/extensions/match_patterns,\n        *    If not then, don't process it.\n        * 3. Check for the protocol, as it is a normal array check.\n        * 4. Checks the host, as it doesn't involve regex match and has only string comparisons.\n        * 5. Finally, checks for the path, which actually involves the Regex matching, the slow process.\n        */\n        // If the matchPattern is <all_urls> then there is no need for any validations.\n        if (this.pattern === MATCH_ALL_URLS) {\n            return true;\n        }\n\n        // Empty _matchPatternObject represents the match is INVALID match\n        if (_.isEmpty(this._matchPatternObject)) {\n            return false;\n        }\n\n        const url = new Url(urlStr);\n\n        return (this.testProtocol(url.protocol) &&\n            this.testHost(url.getHost()) &&\n            this.testPort(url.port, url.protocol) &&\n            this.testPath(url.getPath()));\n    },\n\n    /**\n     * Returns a string representation of the match pattern\n     *\n     * @returns {String} pattern\n     */\n    toString () {\n        return String(this.pattern);\n    },\n\n    /**\n     * Returns the JSON representation.\n     *\n     * @returns {{ pattern: (String) }}\n     */\n    toJSON () {\n        var pattern;\n\n        pattern = this.toString();\n\n        return { pattern };\n    }\n});\n\n_.assign(UrlMatchPattern, /** @lends UrlMatchPattern */ {\n    /**\n     * Defines the name of this property for internal use\n     *\n     * @private\n     * @readOnly\n     * @type {String}\n     */\n    _postman_propertyName: 'UrlMatchPattern',\n\n    /**\n     * Multiple protocols in the match pattern should be separated by this string\n     *\n     * @readOnly\n     * @type {String}\n     */\n    PROTOCOL_DELIMITER: PROTOCOL_DELIMITER,\n\n    /**\n     * String representation for matching all urls - <all_urls>\n     *\n     * @readOnly\n     * @type {String}\n     */\n    MATCH_ALL_URLS: MATCH_ALL_URLS\n});\n\nmodule.exports = {\n    UrlMatchPattern\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}