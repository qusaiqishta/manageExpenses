{"ast":null,"code":"var _ = require('lodash'),\n  async = require('async'),\n  backpack = require('../backpack'),\n  Instruction = require('./instruction'),\n  Run; // constructor\n\n/**\n * The run object is the primary way to interact with a run in progress. It allows controlling the run (pausing,\n * starting, etc) and holds references to the helpers, such as requesters and authorizer.\n *\n * @param {Object} state -\n * @param {Object} options -\n *\n * @property {Requester} requester\n * @constructor\n */\nRun = function PostmanCollectionRun(state, options) {\n  // eslint-disable-line func-name-matching\n  _.assign(this, /** @lends Run.prototype */{\n    /**\n     * @private\n     * @type {Object}\n     * @todo: state also holds the host for now (if any).\n     */\n    state: _.assign({}, state),\n    /**\n     * @private\n     * @type {InstructionPool}\n     */\n    pool: Instruction.pool(Run.commands),\n    /**\n     * @private\n     * @type {Object}\n     */\n    stack: {},\n    /**\n     * @private\n     * @type {Object}\n     */\n    options: options || {}\n  });\n};\n_.assign(Run.prototype, {\n  // eslint-disable-next-line jsdoc/check-param-names\n  /**\n   * @param {String} action -\n   * @param {Object} [payload] -\n   */\n  queue(action, payload) {\n    // extract the arguments that are to be forwarded to the processor\n    return this._schedule(action, payload, _.slice(arguments, 2), false);\n  },\n  // eslint-disable-next-line jsdoc/check-param-names\n  /**\n   * @param {String} action -\n   * @param {Object} [payload] -\n   */\n  interrupt(action, payload) {\n    // extract the arguments that are to be forwarded to the processor\n    return this._schedule(action, payload, _.slice(arguments, 2), true);\n  },\n  // eslint-disable-next-line jsdoc/check-param-names\n  /**\n   * Suspends current instruction and executes the given instruction.\n   *\n   * This method explicitly chooses not to handle errors, to allow the caller to catch errors and continue execution\n   * without terminating the instruction queue. However, it is up to the caller to make sure errors are handled,\n   * or it will go unhandled.\n   *\n   * @param {String} action -\n   * @param {Object} payload -\n   */\n  immediate(action, payload) {\n    var scope = this,\n      instruction = this.pool.create(action, payload, _.slice(arguments, 2));\n\n    // we directly execute this instruction instead od queueing it.\n    setTimeout(function () {\n      // we do not have callback, hence we send _.noop. we could have had made callback in .execute optional, but\n      // that would suppress design-time bugs in majority use-case and hence we avoided the same.\n      instruction.execute(_.noop, scope);\n    }, 0);\n    return instruction;\n  },\n  /**\n   * @param {Function|Object} callback -\n   */\n  start(callback) {\n    // @todo add `when` parameter to backpack.normalise\n    callback = backpack.normalise(callback, Object.keys(Run.triggers));\n\n    // cannot start run if it is already running\n    if (this.triggers) {\n      return callback(new Error('run: already running'));\n    }\n    var timeback = callback;\n    if (_.isFinite(_.get(this.options, 'timeout.global'))) {\n      timeback = backpack.timeback(callback, this.options.timeout.global, this, function () {\n        this.pool.clear();\n      });\n    }\n\n    // invoke all the initialiser functions one after another and if it has any error then abort with callback.\n    async.series(_.map(Run.initialisers, function (initializer) {\n      return initializer.bind(this);\n    }.bind(this)), function (err) {\n      if (err) {\n        return callback(err);\n      }\n\n      // save the normalised callbacks as triggers\n      this.triggers = callback;\n      this.triggers.start(null, this.state.cursor.current()); // @todo may throw error if cursor absent\n      this._process(timeback);\n    }.bind(this));\n  },\n  /**\n   * @private\n   * @param {Object|Cursor} cursor -\n   * @return {Item}\n   */\n  resolveCursor(cursor) {\n    if (!cursor || !Array.isArray(this.state.items)) {\n      return;\n    }\n    return this.state.items[cursor.position];\n  },\n  /**\n   * @private\n   *\n   * @param {String} action -\n   * @param {Object} [payload] -\n   * @param {Array} [args] -\n   * @param {Boolean} [immediate] -\n   */\n  _schedule(action, payload, args, immediate) {\n    var instruction = this.pool.create(action, payload, args);\n\n    // based on whether the immediate flag is set, add to the top or bottom of the instruction queue.\n    (immediate ? this.pool.unshift : this.pool.push)(instruction);\n    return instruction;\n  },\n  _process(callback) {\n    // extract the command from the queue\n    var instruction = this.pool.shift();\n\n    // if there is nothing to process, exit\n    if (!instruction) {\n      callback(null, this.state.cursor.current());\n      return;\n    }\n    instruction.execute(function (err) {\n      return err ? callback(err, this.state.cursor.current()) : this._process(callback); // process recursively\n    }, this);\n  }\n});\n_.assign(Run, {\n  /**\n   * Stores all events that runner triggers\n   *\n   * @type {Object}\n   */\n  triggers: {\n    start: true\n  },\n  /**\n   * stores all execution commands\n   *\n   * @enum {Function}\n   *\n   * @note commands are loaded by flattening the modules in the `./commands` directory\n   */\n  commands: {},\n  /**\n   * Functions executed with commands on start\n   *\n   * @type {Array}\n   */\n  initialisers: []\n});\n\n// commands are loaded by flattening the modules in the `./commands` directory\nRun.commands = _.transform({\n  'control.command': require('./extensions/control.command'),\n  'event.command': require('./extensions/event.command'),\n  'httprequest.command': require('./extensions/http-request.command'),\n  'request.command': require('./extensions/request.command'),\n  'waterfall.command': require('./extensions/waterfall.command'),\n  'item.command': require('./extensions/item.command'),\n  'delay.command': require('./extensions/delay.command')\n}, function (all, extension) {\n  // extract the prototype from the command interface\n  if (_.has(extension, 'prototype')) {\n    _.forOwn(extension.prototype, function (value, prop) {\n      if (Object.hasOwnProperty.call(Run.prototype, prop)) {\n        throw new Error('run: duplicate command prototype extension ' + prop);\n      }\n      Run.prototype[prop] = value;\n    });\n  }\n\n  // put the triggers in a box\n  if (_.has(extension, 'triggers') && _.isArray(extension.triggers)) {\n    _.forEach(extension.triggers, function (name) {\n      name && (Run.triggers[name] = true);\n    });\n  }\n\n  // we add the processors to the processor list\n  if (_.has(extension, 'process')) {\n    _.forOwn(extension.process, function (command, name) {\n      if (!_.isFunction(command)) {\n        return;\n      }\n      if (Object.hasOwnProperty.call(all, name)) {\n        throw new Error('run: duplicate command processor ' + name);\n      }\n      // finally add the command function to the accumulator\n      all[name] = command;\n    });\n  }\n\n  // add the initialisation functions\n  _.has(extension, 'init') && _.isFunction(extension.init) && Run.initialisers.push(extension.init);\n});\nmodule.exports = Run;","map":{"version":3,"names":["_","require","async","backpack","Instruction","Run","PostmanCollectionRun","state","options","assign","pool","commands","stack","prototype","queue","action","payload","_schedule","slice","arguments","interrupt","immediate","scope","instruction","create","setTimeout","execute","noop","start","callback","normalise","Object","keys","triggers","Error","timeback","isFinite","get","timeout","global","clear","series","map","initialisers","initializer","bind","err","cursor","current","_process","resolveCursor","Array","isArray","items","position","args","unshift","push","shift","transform","all","extension","has","forOwn","value","prop","hasOwnProperty","call","forEach","name","process","command","isFunction","init","module","exports"],"sources":["/Users/Qusai.Qishta/node_modules/postman-runtime/lib/runner/run.js"],"sourcesContent":["var _ = require('lodash'),\n    async = require('async'),\n    backpack = require('../backpack'),\n    Instruction = require('./instruction'),\n\n    Run; // constructor\n\n/**\n * The run object is the primary way to interact with a run in progress. It allows controlling the run (pausing,\n * starting, etc) and holds references to the helpers, such as requesters and authorizer.\n *\n * @param {Object} state -\n * @param {Object} options -\n *\n * @property {Requester} requester\n * @constructor\n */\nRun = function PostmanCollectionRun (state, options) { // eslint-disable-line func-name-matching\n    _.assign(this, /** @lends Run.prototype */ {\n        /**\n         * @private\n         * @type {Object}\n         * @todo: state also holds the host for now (if any).\n         */\n        state: _.assign({}, state),\n\n        /**\n         * @private\n         * @type {InstructionPool}\n         */\n        pool: Instruction.pool(Run.commands),\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        stack: {},\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        options: options || {}\n    });\n};\n\n_.assign(Run.prototype, {\n    // eslint-disable-next-line jsdoc/check-param-names\n    /**\n     * @param {String} action -\n     * @param {Object} [payload] -\n     */\n    queue (action, payload) {\n        // extract the arguments that are to be forwarded to the processor\n        return this._schedule(action, payload, _.slice(arguments, 2), false);\n    },\n\n    // eslint-disable-next-line jsdoc/check-param-names\n    /**\n     * @param {String} action -\n     * @param {Object} [payload] -\n     */\n    interrupt (action, payload) {\n        // extract the arguments that are to be forwarded to the processor\n        return this._schedule(action, payload, _.slice(arguments, 2), true);\n    },\n\n    // eslint-disable-next-line jsdoc/check-param-names\n    /**\n     * Suspends current instruction and executes the given instruction.\n     *\n     * This method explicitly chooses not to handle errors, to allow the caller to catch errors and continue execution\n     * without terminating the instruction queue. However, it is up to the caller to make sure errors are handled,\n     * or it will go unhandled.\n     *\n     * @param {String} action -\n     * @param {Object} payload -\n     */\n    immediate (action, payload) {\n        var scope = this,\n            instruction = this.pool.create(action, payload, _.slice(arguments, 2));\n\n        // we directly execute this instruction instead od queueing it.\n        setTimeout(function () {\n            // we do not have callback, hence we send _.noop. we could have had made callback in .execute optional, but\n            // that would suppress design-time bugs in majority use-case and hence we avoided the same.\n            instruction.execute(_.noop, scope);\n        }, 0);\n\n        return instruction;\n    },\n\n    /**\n     * @param {Function|Object} callback -\n     */\n    start (callback) {\n        // @todo add `when` parameter to backpack.normalise\n        callback = backpack.normalise(callback, Object.keys(Run.triggers));\n\n        // cannot start run if it is already running\n        if (this.triggers) {\n            return callback(new Error('run: already running'));\n        }\n\n        var timeback = callback;\n\n        if (_.isFinite(_.get(this.options, 'timeout.global'))) {\n            timeback = backpack.timeback(callback, this.options.timeout.global, this, function () {\n                this.pool.clear();\n            });\n        }\n\n        // invoke all the initialiser functions one after another and if it has any error then abort with callback.\n        async.series(_.map(Run.initialisers, function (initializer) {\n            return initializer.bind(this);\n        }.bind(this)), function (err) {\n            if (err) { return callback(err); }\n\n            // save the normalised callbacks as triggers\n            this.triggers = callback;\n            this.triggers.start(null, this.state.cursor.current()); // @todo may throw error if cursor absent\n            this._process(timeback);\n        }.bind(this));\n    },\n\n    /**\n     * @private\n     * @param {Object|Cursor} cursor -\n     * @return {Item}\n     */\n    resolveCursor (cursor) {\n        if (!cursor || !Array.isArray(this.state.items)) { return; }\n\n        return this.state.items[cursor.position];\n    },\n\n    /**\n     * @private\n     *\n     * @param {String} action -\n     * @param {Object} [payload] -\n     * @param {Array} [args] -\n     * @param {Boolean} [immediate] -\n     */\n    _schedule (action, payload, args, immediate) {\n        var instruction = this.pool.create(action, payload, args);\n\n        // based on whether the immediate flag is set, add to the top or bottom of the instruction queue.\n        (immediate ? this.pool.unshift : this.pool.push)(instruction);\n\n        return instruction;\n    },\n\n    _process (callback) {\n        // extract the command from the queue\n        var instruction = this.pool.shift();\n\n        // if there is nothing to process, exit\n        if (!instruction) {\n            callback(null, this.state.cursor.current());\n\n            return;\n        }\n\n        instruction.execute(function (err) {\n            return err ? callback(err, this.state.cursor.current()) : this._process(callback); // process recursively\n        }, this);\n    }\n});\n\n_.assign(Run, {\n    /**\n     * Stores all events that runner triggers\n     *\n     * @type {Object}\n     */\n    triggers: {\n        start: true\n    },\n\n    /**\n     * stores all execution commands\n     *\n     * @enum {Function}\n     *\n     * @note commands are loaded by flattening the modules in the `./commands` directory\n     */\n    commands: {},\n\n    /**\n     * Functions executed with commands on start\n     *\n     * @type {Array}\n     */\n    initialisers: []\n});\n\n// commands are loaded by flattening the modules in the `./commands` directory\nRun.commands = _.transform({\n    'control.command': require('./extensions/control.command'),\n    'event.command': require('./extensions/event.command'),\n    'httprequest.command': require('./extensions/http-request.command'),\n    'request.command': require('./extensions/request.command'),\n    'waterfall.command': require('./extensions/waterfall.command'),\n    'item.command': require('./extensions/item.command'),\n    'delay.command': require('./extensions/delay.command')\n}, function (all, extension) {\n    // extract the prototype from the command interface\n    if (_.has(extension, 'prototype')) {\n        _.forOwn(extension.prototype, function (value, prop) {\n            if (Object.hasOwnProperty.call(Run.prototype, prop)) {\n                throw new Error('run: duplicate command prototype extension ' + prop);\n            }\n            Run.prototype[prop] = value;\n        });\n    }\n\n    // put the triggers in a box\n    if (_.has(extension, 'triggers') && _.isArray(extension.triggers)) {\n        _.forEach(extension.triggers, function (name) {\n            name && (Run.triggers[name] = true);\n        });\n    }\n\n    // we add the processors to the processor list\n    if (_.has(extension, 'process')) {\n        _.forOwn(extension.process, function (command, name) {\n            if (!_.isFunction(command)) { return; }\n            if (Object.hasOwnProperty.call(all, name)) {\n                throw new Error('run: duplicate command processor ' + name);\n            }\n            // finally add the command function to the accumulator\n            all[name] = command;\n        });\n    }\n\n    // add the initialisation functions\n    _.has(extension, 'init') && _.isFunction(extension.init) && Run.initialisers.push(extension.init);\n});\n\nmodule.exports = Run;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}