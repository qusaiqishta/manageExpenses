{"ast":null,"code":"var _ = require('lodash'),\n  crypto = require('crypto'),\n  oAuth1 = require('node-oauth1'),\n  urlEncoder = require('postman-url-encoder'),\n  RequestBody = require('postman-collection').RequestBody,\n  bodyBuilder = require('../requester/core-body-builder'),\n  EMPTY = '',\n  RSA = 'RSA',\n  HYPHEN = '-',\n  PROTOCOL_HTTP = 'http',\n  PROTOCOL_SEPARATOR = '://',\n  HTTPS_PORT = '443',\n  HTTP_PORT = '80',\n  OAUTH1_PARAMS = {\n    oauthConsumerKey: 'oauth_consumer_key',\n    oauthToken: 'oauth_token',\n    oauthSignatureMethod: 'oauth_signature_method',\n    oauthTimestamp: 'oauth_timestamp',\n    oauthNonce: 'oauth_nonce',\n    oauthVersion: 'oauth_version',\n    oauthSignature: 'oauth_signature',\n    oauthCallback: 'oauth_callback',\n    oauthVerifier: 'oauth_verifier',\n    oauthBodyHash: 'oauth_body_hash'\n  };\n\n/**\n * Returns a OAuth1.0-a compatible representation of the request URL, also called \"Base URL\".\n * For details, http://oauth.net/core/1.0a/#anchor13\n *\n * todo: should we ignore the auth parameters of the URL or not? (the standard does not mention them)\n * we currently are.\n *\n * @private\n * @param {Url} url - Node's URL object\n * @returns {String}\n */\nfunction getOAuth1BaseUrl(url) {\n  var port = url.port ? url.port : undefined,\n    host = (port === HTTP_PORT || port === HTTPS_PORT || port === undefined) && url.hostname || url.host,\n    path = url.path,\n    // trim to convert 'http:' from Node's URL object to 'http'\n    protocol = _.trimEnd(url.protocol || PROTOCOL_HTTP, PROTOCOL_SEPARATOR);\n  protocol = _.endsWith(protocol, PROTOCOL_SEPARATOR) ? protocol : protocol + PROTOCOL_SEPARATOR;\n  return protocol.toLowerCase() + host.toLowerCase() + path;\n}\n\n/**\n * Query parameters are encoded with WHATWG encoding in the request. OAuth1.0\n * requires the query params to be encoded with the RFC-3986 standard. This\n * function decodes the query parameters and encodes them to the required RFC-3986\n * standard. For details: https://oauth.net/core/1.0a/#encoding_parameters\n *\n * @param {Request} request - request to update query parameters\n * @param {Object} url - Node.js like url object\n */\nfunction updateQueryParamEncoding(request, url) {\n  // early bailout if no query is set.\n  if (!url.query) {\n    return;\n  }\n  const queryParams = oAuth1.decodeForm(url.query);\n\n  // clear all query parameters\n  request.url.query.clear();\n  _.forEach(queryParams, function (param) {\n    request.url.query.add({\n      key: param[0] && oAuth1.percentEncode(param[0]),\n      value: param[1] && oAuth1.percentEncode(param[1])\n    });\n  });\n}\n\n/**\n * Calculates body hash with given algorithm and digestEncoding.\n *\n * @param {RequestBody} body Request body\n * @param {String} algorithm Hash algorithm to use\n * @param {String} digestEncoding Encoding of the hash\n * @param {Function} callback Callback function that will be called with body hash\n */\nfunction computeBodyHash(body, algorithm, digestEncoding, callback) {\n  if (!(algorithm && digestEncoding)) {\n    return callback();\n  }\n  var hash = crypto.createHash(algorithm),\n    originalReadStream,\n    rawBody,\n    graphqlBody;\n\n  // if body is not available, return hash of empty string\n  if (!body || body.isEmpty()) {\n    return callback(hash.digest(digestEncoding));\n  }\n  if (body.mode === RequestBody.MODES.raw) {\n    rawBody = bodyBuilder.raw(body.raw).body;\n    hash.update(rawBody);\n    return callback(hash.digest(digestEncoding));\n  }\n\n  // calculations for url-encoded body are not done here unlike other\n  // auths(i.e. AWS/HAWK) because it is not required for OAuth1.0\n\n  if (body.mode === RequestBody.MODES.file) {\n    originalReadStream = _.get(body, 'file.content');\n    if (!originalReadStream) {\n      return callback();\n    }\n    return originalReadStream.cloneReadStream(function (err, clonedStream) {\n      if (err) {\n        return callback();\n      }\n      clonedStream.on('data', function (chunk) {\n        hash.update(chunk);\n      });\n      clonedStream.on('end', function () {\n        callback(hash.digest(digestEncoding));\n      });\n    });\n  }\n  if (body.mode === RequestBody.MODES.graphql) {\n    graphqlBody = bodyBuilder.graphql(body.graphql).body;\n    hash.update(graphqlBody);\n    return callback(hash.digest(digestEncoding));\n  }\n\n  // @todo: Figure out a way to calculate hash for formdata body type.\n\n  // ensure that callback is called if body.mode doesn't match with any of the above modes\n  return callback();\n}\n\n/**\n * @implements {AuthHandlerInterface}\n */\nmodule.exports = {\n  /**\n   * @property {AuthHandlerInterface~AuthManifest}\n   */\n  manifest: {\n    info: {\n      name: 'oauth1',\n      version: '1.0.0'\n    },\n    updates: [{\n      property: 'Authorization',\n      type: 'header'\n    }, {\n      property: OAUTH1_PARAMS.oauthConsumerKey,\n      type: 'url.param'\n    }, {\n      property: OAUTH1_PARAMS.oauthToken,\n      type: 'url.param'\n    }, {\n      property: OAUTH1_PARAMS.oauthCallback,\n      type: 'url.param'\n    }, {\n      property: OAUTH1_PARAMS.oauthVerifier,\n      type: 'url.param'\n    }, {\n      property: OAUTH1_PARAMS.oauthBodyHash,\n      type: 'url.param'\n    }, {\n      property: OAUTH1_PARAMS.oauthSignatureMethod,\n      type: 'url.param'\n    }, {\n      property: OAUTH1_PARAMS.oauthTimestamp,\n      type: 'url.param'\n    }, {\n      property: OAUTH1_PARAMS.oauthNonce,\n      type: 'url.param'\n    }, {\n      property: OAUTH1_PARAMS.oauthVersion,\n      type: 'url.param'\n    }, {\n      property: OAUTH1_PARAMS.oauthSignature,\n      type: 'url.param'\n    }, {\n      property: OAUTH1_PARAMS.oauthConsumerKey,\n      type: 'body.urlencoded'\n    }, {\n      property: OAUTH1_PARAMS.oauthToken,\n      type: 'body.urlencoded'\n    }, {\n      property: OAUTH1_PARAMS.oauthCallback,\n      type: 'body.urlencoded'\n    }, {\n      property: OAUTH1_PARAMS.oauthVerifier,\n      type: 'body.urlencoded'\n    }, {\n      property: OAUTH1_PARAMS.oauthSignatureMethod,\n      type: 'body.urlencoded'\n    }, {\n      property: OAUTH1_PARAMS.oauthTimestamp,\n      type: 'body.urlencoded'\n    }, {\n      property: OAUTH1_PARAMS.oauthNonce,\n      type: 'body.urlencoded'\n    }, {\n      property: OAUTH1_PARAMS.oauthVersion,\n      type: 'body.urlencoded'\n    }, {\n      property: OAUTH1_PARAMS.oauthSignature,\n      type: 'body.urlencoded'\n    }]\n  },\n  /**\n   * Initializes an item (extracts parameters from intermediate requests if any, etc)\n   * before the actual authorization step.\n   *\n   * @param {AuthInterface} auth -\n   * @param {Response} response -\n   * @param {AuthHandlerInterface~authInitHookCallback} done -\n   */\n  init: function (auth, response, done) {\n    done(null);\n  },\n  /**\n   * Verifies whether the request has valid basic auth credentials (which is always).\n   * Sanitizes the auth parameters if needed.\n   *\n   * @param {AuthInterface} auth -\n   * @param {AuthHandlerInterface~authPreHookCallback} done -\n   */\n  pre: function (auth, done) {\n    done(null, true);\n  },\n  /**\n   * Verifies whether the basic auth succeeded.\n   *\n   * @param {AuthInterface} auth -\n   * @param {Response} response -\n   * @param {AuthHandlerInterface~authPostHookCallback} done -\n   */\n  post: function (auth, response, done) {\n    done(null, true);\n  },\n  /**\n   * Generates and adds oAuth1 data to the request. This function modifies the\n   * request passed in the argument.\n   *\n   * @param {Request} request - request to add oauth1 parameters\n   * @param {Object} params - oauth data to generate signature\n   * @param {Object} protocolProfileBehavior - Protocol profile behaviors\n   * @param {Function} done - callback function\n   */\n  addAuthDataToRequest: function (request, params, protocolProfileBehavior, done) {\n    var url = urlEncoder.toNodeUrl(request.url),\n      signatureParams,\n      urlencodedBody,\n      bodyParams,\n      allParams,\n      signature,\n      message,\n      header,\n      accessor = {\n        consumerSecret: params.consumerSecret || EMPTY,\n        tokenSecret: params.tokenSecret || EMPTY,\n        privateKey: params.privateKey || EMPTY\n      },\n      disableUrlEncoding = protocolProfileBehavior && protocolProfileBehavior.disableUrlEncoding;\n    signatureParams = [{\n      system: true,\n      key: OAUTH1_PARAMS.oauthConsumerKey,\n      value: params.consumerKey\n    }, {\n      system: true,\n      key: OAUTH1_PARAMS.oauthToken,\n      value: params.token\n    }, {\n      system: true,\n      key: OAUTH1_PARAMS.oauthSignatureMethod,\n      value: params.signatureMethod\n    }, {\n      system: true,\n      key: OAUTH1_PARAMS.oauthTimestamp,\n      value: params.timestamp\n    }, {\n      system: true,\n      key: OAUTH1_PARAMS.oauthNonce,\n      value: params.nonce\n    }, {\n      system: true,\n      key: OAUTH1_PARAMS.oauthVersion,\n      value: params.version\n    }];\n\n    // bodyHash, callback and verifier parameters are part of extensions of the original OAuth1 spec.\n    // So we only include those in signature if they are non-empty, ignoring the addEmptyParamsToSign setting.\n    // Otherwise it causes problem for servers that don't support the respective OAuth1 extensions.\n    // Issue: https://github.com/postmanlabs/postman-app-support/issues/8737\n    if (params.bodyHash) {\n      signatureParams.push({\n        system: true,\n        key: OAUTH1_PARAMS.oauthBodyHash,\n        value: params.bodyHash\n      });\n    }\n    if (params.callback) {\n      signatureParams.push({\n        system: true,\n        key: OAUTH1_PARAMS.oauthCallback,\n        value: params.callback\n      });\n    }\n    if (params.verifier) {\n      signatureParams.push({\n        system: true,\n        key: OAUTH1_PARAMS.oauthVerifier,\n        value: params.verifier\n      });\n    }\n\n    // filter empty signature parameters\n    signatureParams = _.filter(signatureParams, function (param) {\n      return params.addEmptyParamsToSign || param.value;\n    });\n    urlencodedBody = request.body && request.body.mode === RequestBody.MODES.urlencoded && request.body.urlencoded;\n\n    // Body params only need to be included if they are URL encoded.\n    // http://oauth.net/core/1.0a/#anchor13\n    bodyParams = urlencodedBody ? urlencodedBody.filter(function (param) {\n      return !param.disabled;\n    }) : [];\n    allParams = [].concat(signatureParams, bodyParams);\n    message = {\n      action: getOAuth1BaseUrl(url),\n      method: request.method,\n      parameters: _.map(allParams, function (param) {\n        return [param.key, param.value];\n      })\n    };\n    try {\n      signature = oAuth1.SignatureMethod.sign(message, accessor);\n    } catch (err) {\n      // handle invalid private key errors for RSA signatures\n      return done(err);\n    }\n\n    // Update the encoding for query parameters to RFC-3986 in accordance with the\n    // OAuth1.0a specification: https://oauth.net/core/1.0a/#encoding_parameters\n    // disableUrlEncoding option should be respected in authorization flow as well\n    if (disableUrlEncoding !== true) {\n      updateQueryParamEncoding(request, url);\n    }\n    signatureParams.push({\n      system: true,\n      key: OAUTH1_PARAMS.oauthSignature,\n      value: signature\n    });\n\n    // Add signature params to the request. The OAuth specification says\n    // that we should add parameters in the following order of preference:\n    // 1. Auth Header\n    // 2. Body parameters\n    // 3. Query parameters\n    //\n    // http://oauth.net/core/1.0/#consumer_req_param\n    if (params.addParamsToHeader) {\n      header = oAuth1.getAuthorizationHeader(params.realm, _.map(signatureParams, function (param) {\n        return [param.key, param.value];\n      }), params.disableHeaderEncoding);\n      request.addHeader({\n        key: 'Authorization',\n        value: header,\n        system: true\n      });\n    } else if (/PUT|POST/.test(request.method) && urlencodedBody) {\n      _.forEach(signatureParams, function (param) {\n        urlencodedBody.add(param);\n      });\n    } else if (disableUrlEncoding === true) {\n      // disableUrlEncoding option should be respected in authorization flow as well\n      request.addQueryParams(signatureParams);\n    } else {\n      _.forEach(signatureParams, function (param) {\n        request.url.query.add({\n          key: param.key && oAuth1.percentEncode(param.key),\n          value: param.value && oAuth1.percentEncode(param.value),\n          system: true\n        });\n      });\n    }\n    done();\n  },\n  /**\n   * Signs a request.\n   *\n   * @param {AuthInterface} auth -\n   * @param {Request} request -\n   * @param {AuthHandlerInterface~authSignHookCallback} done -\n   */\n  sign: function (auth, request, done) {\n    var self = this,\n      params = auth.get(['consumerKey', 'consumerSecret', 'token', 'tokenSecret', 'privateKey', 'signatureMethod', 'callback', 'verifier', 'timestamp', 'nonce', 'version', 'realm', 'includeBodyHash', 'addParamsToHeader', 'addEmptyParamsToSign', 'disableHeaderEncoding']),\n      urlencodedBody = request.body,\n      signatureAlgo,\n      hashAlgo,\n      protocolProfileBehavior = auth._protocolProfileBehavior;\n\n    // extract hash and signature algorithm form signatureMethod\n    // signature methods are in this format: '<signatureAlgo>-<hashAlgo>' e.g. RSA-SHA1\n    hashAlgo = _.split(params.signatureMethod, HYPHEN);\n    signatureAlgo = _.upperCase(hashAlgo[0]);\n    hashAlgo = hashAlgo[1];\n    if (!params.consumerKey || signatureAlgo !== RSA && !params.consumerSecret || signatureAlgo === RSA && !params.privateKey) {\n      return done(); // Nothing to do if required parameters are not present.\n    }\n\n    // before this: urlencodedBody = request.body\n    // after this: urlencodedBody = request.body.urlencoded or undefined\n    urlencodedBody = urlencodedBody && urlencodedBody.mode === RequestBody.MODES.urlencoded ? urlencodedBody.urlencoded : undefined;\n\n    // Remove existing headers and params (if any)\n    request.removeHeader('Authorization');\n    request.removeQueryParams(_.values(OAUTH1_PARAMS));\n    urlencodedBody && urlencodedBody.remove(function (param) {\n      return _.includes(_.values(OAUTH1_PARAMS), param.key);\n    });\n\n    // Generate a new nonce and timestamp\n    params.nonce = params.nonce || oAuth1.nonce(11).toString();\n    params.timestamp = params.timestamp || oAuth1.timestamp().toString();\n\n    // Ensure that empty parameters are not added to the signature\n    if (!params.addEmptyParamsToSign) {\n      params = _.reduce(params, function (accumulator, value, key) {\n        if (_.isString(value) && value.trim() === EMPTY) {\n          return accumulator;\n        }\n        accumulator[key] = value;\n        return accumulator;\n      }, {});\n    }\n\n    // Don't include body hash as defined in specification\n    // @see: https://tools.ietf.org/id/draft-eaton-oauth-bodyhash-00.html#when_to_include\n    if (urlencodedBody || !(params.includeBodyHash && hashAlgo)) {\n      return self.addAuthDataToRequest(request, params, protocolProfileBehavior, done);\n    }\n    computeBodyHash(request.body, hashAlgo, 'base64', function (bodyHash) {\n      params.bodyHash = bodyHash;\n      return self.addAuthDataToRequest(request, params, protocolProfileBehavior, done);\n    });\n  }\n};","map":{"version":3,"names":["_","require","crypto","oAuth1","urlEncoder","RequestBody","bodyBuilder","EMPTY","RSA","HYPHEN","PROTOCOL_HTTP","PROTOCOL_SEPARATOR","HTTPS_PORT","HTTP_PORT","OAUTH1_PARAMS","oauthConsumerKey","oauthToken","oauthSignatureMethod","oauthTimestamp","oauthNonce","oauthVersion","oauthSignature","oauthCallback","oauthVerifier","oauthBodyHash","getOAuth1BaseUrl","url","port","undefined","host","hostname","path","protocol","trimEnd","endsWith","toLowerCase","updateQueryParamEncoding","request","query","queryParams","decodeForm","clear","forEach","param","add","key","percentEncode","value","computeBodyHash","body","algorithm","digestEncoding","callback","hash","createHash","originalReadStream","rawBody","graphqlBody","isEmpty","digest","mode","MODES","raw","update","file","get","cloneReadStream","err","clonedStream","on","chunk","graphql","module","exports","manifest","info","name","version","updates","property","type","init","auth","response","done","pre","post","addAuthDataToRequest","params","protocolProfileBehavior","toNodeUrl","signatureParams","urlencodedBody","bodyParams","allParams","signature","message","header","accessor","consumerSecret","tokenSecret","privateKey","disableUrlEncoding","system","consumerKey","token","signatureMethod","timestamp","nonce","bodyHash","push","verifier","filter","addEmptyParamsToSign","urlencoded","disabled","concat","action","method","parameters","map","SignatureMethod","sign","addParamsToHeader","getAuthorizationHeader","realm","disableHeaderEncoding","addHeader","test","addQueryParams","self","signatureAlgo","hashAlgo","_protocolProfileBehavior","split","upperCase","removeHeader","removeQueryParams","values","remove","includes","toString","reduce","accumulator","isString","trim","includeBodyHash"],"sources":["/Users/Qusai.Qishta/node_modules/postman-runtime/lib/authorizer/oauth1.js"],"sourcesContent":["var _ = require('lodash'),\n    crypto = require('crypto'),\n    oAuth1 = require('node-oauth1'),\n    urlEncoder = require('postman-url-encoder'),\n    RequestBody = require('postman-collection').RequestBody,\n    bodyBuilder = require('../requester/core-body-builder'),\n\n    EMPTY = '',\n    RSA = 'RSA',\n    HYPHEN = '-',\n    PROTOCOL_HTTP = 'http',\n    PROTOCOL_SEPARATOR = '://',\n    HTTPS_PORT = '443',\n    HTTP_PORT = '80',\n\n    OAUTH1_PARAMS = {\n        oauthConsumerKey: 'oauth_consumer_key',\n        oauthToken: 'oauth_token',\n        oauthSignatureMethod: 'oauth_signature_method',\n        oauthTimestamp: 'oauth_timestamp',\n        oauthNonce: 'oauth_nonce',\n        oauthVersion: 'oauth_version',\n        oauthSignature: 'oauth_signature',\n        oauthCallback: 'oauth_callback',\n        oauthVerifier: 'oauth_verifier',\n        oauthBodyHash: 'oauth_body_hash'\n    };\n\n/**\n * Returns a OAuth1.0-a compatible representation of the request URL, also called \"Base URL\".\n * For details, http://oauth.net/core/1.0a/#anchor13\n *\n * todo: should we ignore the auth parameters of the URL or not? (the standard does not mention them)\n * we currently are.\n *\n * @private\n * @param {Url} url - Node's URL object\n * @returns {String}\n */\nfunction getOAuth1BaseUrl (url) {\n    var port = url.port ? url.port : undefined,\n        host = ((port === HTTP_PORT ||\n            port === HTTPS_PORT ||\n            port === undefined) && url.hostname) || url.host,\n        path = url.path,\n\n        // trim to convert 'http:' from Node's URL object to 'http'\n        protocol = _.trimEnd(url.protocol || PROTOCOL_HTTP, PROTOCOL_SEPARATOR);\n\n    protocol = (_.endsWith(protocol, PROTOCOL_SEPARATOR) ? protocol : protocol + PROTOCOL_SEPARATOR);\n\n    return protocol.toLowerCase() + host.toLowerCase() + path;\n}\n\n/**\n * Query parameters are encoded with WHATWG encoding in the request. OAuth1.0\n * requires the query params to be encoded with the RFC-3986 standard. This\n * function decodes the query parameters and encodes them to the required RFC-3986\n * standard. For details: https://oauth.net/core/1.0a/#encoding_parameters\n *\n * @param {Request} request - request to update query parameters\n * @param {Object} url - Node.js like url object\n */\nfunction updateQueryParamEncoding (request, url) {\n    // early bailout if no query is set.\n    if (!url.query) {\n        return;\n    }\n\n    const queryParams = oAuth1.decodeForm(url.query);\n\n    // clear all query parameters\n    request.url.query.clear();\n\n    _.forEach(queryParams, function (param) {\n        request.url.query.add({\n            key: param[0] && oAuth1.percentEncode(param[0]),\n            value: param[1] && oAuth1.percentEncode(param[1])\n        });\n    });\n}\n\n/**\n * Calculates body hash with given algorithm and digestEncoding.\n *\n * @param {RequestBody} body Request body\n * @param {String} algorithm Hash algorithm to use\n * @param {String} digestEncoding Encoding of the hash\n * @param {Function} callback Callback function that will be called with body hash\n */\nfunction computeBodyHash (body, algorithm, digestEncoding, callback) {\n    if (!(algorithm && digestEncoding)) { return callback(); }\n\n    var hash = crypto.createHash(algorithm),\n        originalReadStream,\n        rawBody,\n        graphqlBody;\n\n    // if body is not available, return hash of empty string\n    if (!body || body.isEmpty()) {\n        return callback(hash.digest(digestEncoding));\n    }\n\n    if (body.mode === RequestBody.MODES.raw) {\n        rawBody = bodyBuilder.raw(body.raw).body;\n        hash.update(rawBody);\n\n        return callback(hash.digest(digestEncoding));\n    }\n\n    // calculations for url-encoded body are not done here unlike other\n    // auths(i.e. AWS/HAWK) because it is not required for OAuth1.0\n\n    if (body.mode === RequestBody.MODES.file) {\n        originalReadStream = _.get(body, 'file.content');\n\n        if (!originalReadStream) {\n            return callback();\n        }\n\n        return originalReadStream.cloneReadStream(function (err, clonedStream) {\n            if (err) { return callback(); }\n\n            clonedStream.on('data', function (chunk) {\n                hash.update(chunk);\n            });\n\n            clonedStream.on('end', function () {\n                callback(hash.digest(digestEncoding));\n            });\n        });\n    }\n\n    if (body.mode === RequestBody.MODES.graphql) {\n        graphqlBody = bodyBuilder.graphql(body.graphql).body;\n        hash.update(graphqlBody);\n\n        return callback(hash.digest(digestEncoding));\n    }\n\n    // @todo: Figure out a way to calculate hash for formdata body type.\n\n    // ensure that callback is called if body.mode doesn't match with any of the above modes\n    return callback();\n}\n\n/**\n * @implements {AuthHandlerInterface}\n */\nmodule.exports = {\n    /**\n     * @property {AuthHandlerInterface~AuthManifest}\n     */\n    manifest: {\n        info: {\n            name: 'oauth1',\n            version: '1.0.0'\n        },\n        updates: [\n            {\n                property: 'Authorization',\n                type: 'header'\n            },\n            {\n                property: OAUTH1_PARAMS.oauthConsumerKey,\n                type: 'url.param'\n            },\n            {\n                property: OAUTH1_PARAMS.oauthToken,\n                type: 'url.param'\n            },\n            {\n                property: OAUTH1_PARAMS.oauthCallback,\n                type: 'url.param'\n            },\n            {\n                property: OAUTH1_PARAMS.oauthVerifier,\n                type: 'url.param'\n            },\n            {\n                property: OAUTH1_PARAMS.oauthBodyHash,\n                type: 'url.param'\n            },\n            {\n                property: OAUTH1_PARAMS.oauthSignatureMethod,\n                type: 'url.param'\n            },\n            {\n                property: OAUTH1_PARAMS.oauthTimestamp,\n                type: 'url.param'\n            },\n            {\n                property: OAUTH1_PARAMS.oauthNonce,\n                type: 'url.param'\n            },\n            {\n                property: OAUTH1_PARAMS.oauthVersion,\n                type: 'url.param'\n            },\n            {\n                property: OAUTH1_PARAMS.oauthSignature,\n                type: 'url.param'\n            },\n            {\n                property: OAUTH1_PARAMS.oauthConsumerKey,\n                type: 'body.urlencoded'\n            },\n            {\n                property: OAUTH1_PARAMS.oauthToken,\n                type: 'body.urlencoded'\n            },\n            {\n                property: OAUTH1_PARAMS.oauthCallback,\n                type: 'body.urlencoded'\n            },\n            {\n                property: OAUTH1_PARAMS.oauthVerifier,\n                type: 'body.urlencoded'\n            },\n            {\n                property: OAUTH1_PARAMS.oauthSignatureMethod,\n                type: 'body.urlencoded'\n            },\n            {\n                property: OAUTH1_PARAMS.oauthTimestamp,\n                type: 'body.urlencoded'\n            },\n            {\n                property: OAUTH1_PARAMS.oauthNonce,\n                type: 'body.urlencoded'\n            },\n            {\n                property: OAUTH1_PARAMS.oauthVersion,\n                type: 'body.urlencoded'\n            },\n            {\n                property: OAUTH1_PARAMS.oauthSignature,\n                type: 'body.urlencoded'\n            }\n        ]\n    },\n\n    /**\n     * Initializes an item (extracts parameters from intermediate requests if any, etc)\n     * before the actual authorization step.\n     *\n     * @param {AuthInterface} auth -\n     * @param {Response} response -\n     * @param {AuthHandlerInterface~authInitHookCallback} done -\n     */\n    init: function (auth, response, done) {\n        done(null);\n    },\n\n    /**\n     * Verifies whether the request has valid basic auth credentials (which is always).\n     * Sanitizes the auth parameters if needed.\n     *\n     * @param {AuthInterface} auth -\n     * @param {AuthHandlerInterface~authPreHookCallback} done -\n     */\n    pre: function (auth, done) {\n        done(null, true);\n    },\n\n    /**\n     * Verifies whether the basic auth succeeded.\n     *\n     * @param {AuthInterface} auth -\n     * @param {Response} response -\n     * @param {AuthHandlerInterface~authPostHookCallback} done -\n     */\n    post: function (auth, response, done) {\n        done(null, true);\n    },\n\n    /**\n     * Generates and adds oAuth1 data to the request. This function modifies the\n     * request passed in the argument.\n     *\n     * @param {Request} request - request to add oauth1 parameters\n     * @param {Object} params - oauth data to generate signature\n     * @param {Object} protocolProfileBehavior - Protocol profile behaviors\n     * @param {Function} done - callback function\n     */\n    addAuthDataToRequest: function (request, params, protocolProfileBehavior, done) {\n        var url = urlEncoder.toNodeUrl(request.url),\n            signatureParams,\n            urlencodedBody,\n            bodyParams,\n            allParams,\n            signature,\n            message,\n            header,\n            accessor = {\n                consumerSecret: params.consumerSecret || EMPTY,\n                tokenSecret: params.tokenSecret || EMPTY,\n                privateKey: params.privateKey || EMPTY\n            },\n            disableUrlEncoding = protocolProfileBehavior && protocolProfileBehavior.disableUrlEncoding;\n\n        signatureParams = [\n            { system: true, key: OAUTH1_PARAMS.oauthConsumerKey, value: params.consumerKey },\n            { system: true, key: OAUTH1_PARAMS.oauthToken, value: params.token },\n            { system: true, key: OAUTH1_PARAMS.oauthSignatureMethod, value: params.signatureMethod },\n            { system: true, key: OAUTH1_PARAMS.oauthTimestamp, value: params.timestamp },\n            { system: true, key: OAUTH1_PARAMS.oauthNonce, value: params.nonce },\n            { system: true, key: OAUTH1_PARAMS.oauthVersion, value: params.version }\n        ];\n\n        // bodyHash, callback and verifier parameters are part of extensions of the original OAuth1 spec.\n        // So we only include those in signature if they are non-empty, ignoring the addEmptyParamsToSign setting.\n        // Otherwise it causes problem for servers that don't support the respective OAuth1 extensions.\n        // Issue: https://github.com/postmanlabs/postman-app-support/issues/8737\n        if (params.bodyHash) {\n            signatureParams.push({ system: true, key: OAUTH1_PARAMS.oauthBodyHash, value: params.bodyHash });\n        }\n\n        if (params.callback) {\n            signatureParams.push({ system: true, key: OAUTH1_PARAMS.oauthCallback, value: params.callback });\n        }\n\n        if (params.verifier) {\n            signatureParams.push({ system: true, key: OAUTH1_PARAMS.oauthVerifier, value: params.verifier });\n        }\n\n        // filter empty signature parameters\n        signatureParams = _.filter(signatureParams, function (param) {\n            return params.addEmptyParamsToSign || param.value;\n        });\n\n        urlencodedBody = request.body &&\n            request.body.mode === RequestBody.MODES.urlencoded &&\n            request.body.urlencoded;\n\n        // Body params only need to be included if they are URL encoded.\n        // http://oauth.net/core/1.0a/#anchor13\n        bodyParams = urlencodedBody ? urlencodedBody.filter(function (param) {\n            return !param.disabled;\n        }) : [];\n\n        allParams = [].concat(signatureParams, bodyParams);\n\n        message = {\n            action: getOAuth1BaseUrl(url),\n            method: request.method,\n            parameters: _.map(allParams, function (param) {\n                return [param.key, param.value];\n            })\n        };\n\n        try {\n            signature = oAuth1.SignatureMethod.sign(message, accessor);\n        }\n        catch (err) {\n            // handle invalid private key errors for RSA signatures\n            return done(err);\n        }\n\n        // Update the encoding for query parameters to RFC-3986 in accordance with the\n        // OAuth1.0a specification: https://oauth.net/core/1.0a/#encoding_parameters\n        // disableUrlEncoding option should be respected in authorization flow as well\n        if (disableUrlEncoding !== true) {\n            updateQueryParamEncoding(request, url);\n        }\n\n        signatureParams.push({ system: true, key: OAUTH1_PARAMS.oauthSignature, value: signature });\n\n        // Add signature params to the request. The OAuth specification says\n        // that we should add parameters in the following order of preference:\n        // 1. Auth Header\n        // 2. Body parameters\n        // 3. Query parameters\n        //\n        // http://oauth.net/core/1.0/#consumer_req_param\n        if (params.addParamsToHeader) {\n            header = oAuth1.getAuthorizationHeader(params.realm, _.map(signatureParams, function (param) {\n                return [param.key, param.value];\n            }), params.disableHeaderEncoding);\n\n            request.addHeader({\n                key: 'Authorization',\n                value: header,\n                system: true\n            });\n        }\n        else if ((/PUT|POST/).test(request.method) && urlencodedBody) {\n            _.forEach(signatureParams, function (param) {\n                urlencodedBody.add(param);\n            });\n        }\n        else if (disableUrlEncoding === true) {\n            // disableUrlEncoding option should be respected in authorization flow as well\n            request.addQueryParams(signatureParams);\n        }\n        else {\n            _.forEach(signatureParams, function (param) {\n                request.url.query.add({\n                    key: param.key && oAuth1.percentEncode(param.key),\n                    value: param.value && oAuth1.percentEncode(param.value),\n                    system: true\n                });\n            });\n        }\n\n        done();\n    },\n\n    /**\n     * Signs a request.\n     *\n     * @param {AuthInterface} auth -\n     * @param {Request} request -\n     * @param {AuthHandlerInterface~authSignHookCallback} done -\n     */\n    sign: function (auth, request, done) {\n        var self = this,\n            params = auth.get([\n                'consumerKey',\n                'consumerSecret',\n                'token',\n                'tokenSecret',\n                'privateKey',\n                'signatureMethod',\n                'callback',\n                'verifier',\n                'timestamp',\n                'nonce',\n                'version',\n                'realm',\n                'includeBodyHash',\n                'addParamsToHeader',\n                'addEmptyParamsToSign',\n                'disableHeaderEncoding'\n            ]),\n            urlencodedBody = request.body,\n            signatureAlgo,\n            hashAlgo,\n            protocolProfileBehavior = auth._protocolProfileBehavior;\n\n        // extract hash and signature algorithm form signatureMethod\n        // signature methods are in this format: '<signatureAlgo>-<hashAlgo>' e.g. RSA-SHA1\n        hashAlgo = _.split(params.signatureMethod, HYPHEN);\n        signatureAlgo = _.upperCase(hashAlgo[0]);\n        hashAlgo = hashAlgo[1];\n\n        if (!params.consumerKey ||\n            (signatureAlgo !== RSA && !params.consumerSecret) ||\n            (signatureAlgo === RSA && !params.privateKey)) {\n            return done(); // Nothing to do if required parameters are not present.\n        }\n\n        // before this: urlencodedBody = request.body\n        // after this: urlencodedBody = request.body.urlencoded or undefined\n        urlencodedBody = (urlencodedBody &&\n            urlencodedBody.mode === RequestBody.MODES.urlencoded\n        ) ? urlencodedBody.urlencoded : undefined;\n\n        // Remove existing headers and params (if any)\n        request.removeHeader('Authorization');\n        request.removeQueryParams(_.values(OAUTH1_PARAMS));\n        urlencodedBody && urlencodedBody.remove(function (param) {\n            return _.includes(_.values(OAUTH1_PARAMS), param.key);\n        });\n\n        // Generate a new nonce and timestamp\n        params.nonce = params.nonce || oAuth1.nonce(11).toString();\n        params.timestamp = params.timestamp || oAuth1.timestamp().toString();\n\n        // Ensure that empty parameters are not added to the signature\n        if (!params.addEmptyParamsToSign) {\n            params = _.reduce(params, function (accumulator, value, key) {\n                if (_.isString(value) && (value.trim() === EMPTY)) {\n                    return accumulator;\n                }\n                accumulator[key] = value;\n\n                return accumulator;\n            }, {});\n        }\n\n        // Don't include body hash as defined in specification\n        // @see: https://tools.ietf.org/id/draft-eaton-oauth-bodyhash-00.html#when_to_include\n        if (urlencodedBody || !(params.includeBodyHash && hashAlgo)) {\n            return self.addAuthDataToRequest(request, params, protocolProfileBehavior, done);\n        }\n\n        computeBodyHash(request.body, hashAlgo, 'base64', function (bodyHash) {\n            params.bodyHash = bodyHash;\n\n            return self.addAuthDataToRequest(request, params, protocolProfileBehavior, done);\n        });\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}