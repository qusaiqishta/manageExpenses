{"ast":null,"code":"const fs = require('fs'),\n  _ = require('lodash'),\n  path = require('path'),\n  util = require('util'),\n  Readable = require('stream').Readable,\n  PPERM_ERR = 'PPERM: insecure file access outside working directory',\n  FUNCTION = 'function',\n  DEPRECATED_SYNC_WRITE_STREAM = 'SyncWriteStream',\n  EXPERIMENTAL_PROMISE = 'promises',\n  // Use simple character check instead of regex to prevent regex attack\n  /*\n   * Windows root directory can be of the following from\n   *\n   * | File System | Actual           | Modified          |\n   * |-------------|------------------|-------------------|\n   * | LFS (Local) | C:\\Program       | /C:/Program       |\n   * | UNC         | \\\\Server\\Program | ///Server/Program |\n   */\n  isWindowsRoot = function (path) {\n    const drive = path.charAt(1);\n    return path.charAt(0) === '/' && (drive >= 'A' && drive <= 'Z' || drive >= 'a' && drive <= 'z') && path.charAt(2) === ':' || path.slice(0, 3) === '///'; // Modified UNC path\n  },\n  stripTrailingSep = function (thePath) {\n    if (thePath[thePath.length - 1] === path.sep) {\n      return thePath.slice(0, -1);\n    }\n    return thePath;\n  },\n  pathIsInside = function (thePath, potentialParent) {\n    // For inside-directory checking, we want to allow trailing slashes, so normalize.\n    thePath = stripTrailingSep(thePath);\n    potentialParent = stripTrailingSep(potentialParent);\n\n    // Node treats only Windows as case-insensitive in its path module; we follow those conventions.\n    if (global.process.platform === 'win32') {\n      thePath = thePath.toLowerCase();\n      potentialParent = potentialParent.toLowerCase();\n    }\n    return thePath.lastIndexOf(potentialParent, 0) === 0 && (thePath[potentialParent.length] === path.sep || thePath[potentialParent.length] === undefined);\n  };\n\n/**\n * Secure file resolver wrapper over fs. It only allow access to files inside working directory unless specified.\n *\n * @param {*} workingDir - Path of working directory\n * @param {*} [insecureFileRead=false] - If true, allow reading files outside working directory\n * @param {*} [fileWhitelist=[]] - List of allowed files outside of working directory\n */\nfunction SecureFS(workingDir) {\n  let insecureFileRead = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let fileWhitelist = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  this._fs = fs;\n  this._path = path;\n  this.constants = this._fs.constants;\n  this.workingDir = workingDir;\n  this.insecureFileRead = insecureFileRead;\n  this.fileWhitelist = fileWhitelist;\n  this.isWindows = global.process.platform === 'win32';\n}\n\n/**\n * Private method to resole the path based based on working directory\n *\n * @param {String} relOrAbsPath - Relative or absolute path to resolve\n * @param {Array} whiteList - A list of absolute path to whitelist\n *\n * @returns {String} The resolved path\n */\nSecureFS.prototype._resolve = function (relOrAbsPath, whiteList) {\n  // Special handling for windows absolute paths to work cross platform\n  this.isWindows && isWindowsRoot(relOrAbsPath) && (relOrAbsPath = relOrAbsPath.substring(1));\n\n  // Resolve the path from the working directory. The file should always be resolved so that\n  // cross os variations are mitigated\n  let resolvedPath = this._path.resolve(this.workingDir, relOrAbsPath);\n\n  // Check file is within working directory\n  if (!this.insecureFileRead &&\n  // insecureFile read disabled\n  !pathIsInside(resolvedPath, this.workingDir) &&\n  // File not inside working directory\n  !_.includes(whiteList, resolvedPath)) {\n    // File not in whitelist\n    // Exit\n    return undefined;\n  }\n  return resolvedPath;\n};\n\n/**\n * Asynchronous path resolver function\n *\n * @param {String} relOrAbsPath - Relative or absolute path to resolve\n * @param {Array} [whiteList] - A optional list of additional absolute path to whitelist\n * @param {Function} callback -\n */\nSecureFS.prototype.resolvePath = function (relOrAbsPath, whiteList, callback) {\n  if (!callback && typeof whiteList === FUNCTION) {\n    callback = whiteList;\n    whiteList = [];\n  }\n  let resolvedPath = this._resolve(relOrAbsPath, _.concat(this.fileWhitelist, whiteList));\n  if (!resolvedPath) {\n    return callback(new Error(PPERM_ERR));\n  }\n  return callback(null, resolvedPath);\n};\n\n/**\n * Synchronous path resolver function\n *\n * @param {String} relOrAbsPath - Relative or absolute path to resolve\n * @param {Array} [whiteList] - A optional list of additional absolute path to whitelist\n *\n * @returns {String} The resolved path\n */\nSecureFS.prototype.resolvePathSync = function (relOrAbsPath, whiteList) {\n  // Resolve the path from the working directory\n  const resolvedPath = this._resolve(relOrAbsPath, _.concat(this.fileWhitelist, whiteList));\n  if (!resolvedPath) {\n    throw new Error(PPERM_ERR);\n  }\n  return resolvedPath;\n};\n\n// Attach all functions in fs to postman-fs\nObject.getOwnPropertyNames(fs).map(prop => {\n  // Bail-out early to prevent fs module from logging warning for deprecated and experimental methods\n  if (prop === DEPRECATED_SYNC_WRITE_STREAM || prop === EXPERIMENTAL_PROMISE || typeof fs[prop] !== FUNCTION) {\n    return;\n  }\n  SecureFS.prototype[prop] = fs[prop];\n});\n\n// Override the required functions\nSecureFS.prototype.stat = function (path, callback) {\n  this.resolvePath(path, (err, resolvedPath) => {\n    if (err) {\n      return callback(err);\n    }\n    return this._fs.stat(resolvedPath, callback);\n  });\n};\nSecureFS.prototype.createReadStream = function (path, options) {\n  try {\n    return this._fs.createReadStream(this.resolvePathSync(path), options);\n  } catch (err) {\n    // Create a fake read steam that emits and error and\n    const ErrorReadStream = function () {\n      // Replicating behavior of fs module of disabling emitClose on destroy\n      Readable.call(this, {\n        emitClose: false\n      });\n\n      // Emit the error event with insure file access error\n      this.emit('error', new Error(PPERM_ERR));\n\n      // Options exists and disables autoClose then don't destroy\n      options && !options.autoClose || this.destroy();\n    };\n    util.inherits(ErrorReadStream, Readable);\n    return new ErrorReadStream();\n  }\n};\nmodule.exports = SecureFS;","map":{"version":3,"names":["fs","require","_","path","util","Readable","PPERM_ERR","FUNCTION","DEPRECATED_SYNC_WRITE_STREAM","EXPERIMENTAL_PROMISE","isWindowsRoot","drive","charAt","slice","stripTrailingSep","thePath","length","sep","pathIsInside","potentialParent","global","process","platform","toLowerCase","lastIndexOf","undefined","SecureFS","workingDir","insecureFileRead","fileWhitelist","_fs","_path","constants","isWindows","prototype","_resolve","relOrAbsPath","whiteList","substring","resolvedPath","resolve","includes","resolvePath","callback","concat","Error","resolvePathSync","Object","getOwnPropertyNames","map","prop","stat","err","createReadStream","options","ErrorReadStream","call","emitClose","emit","autoClose","destroy","inherits","module","exports"],"sources":["/Users/Qusai.Qishta/node_modules/newman/lib/run/secure-fs.js"],"sourcesContent":["const fs = require('fs'),\n    _ = require('lodash'),\n    path = require('path'),\n    util = require('util'),\n    Readable = require('stream').Readable,\n\n    PPERM_ERR = 'PPERM: insecure file access outside working directory',\n    FUNCTION = 'function',\n    DEPRECATED_SYNC_WRITE_STREAM = 'SyncWriteStream',\n    EXPERIMENTAL_PROMISE = 'promises',\n\n    // Use simple character check instead of regex to prevent regex attack\n    /*\n     * Windows root directory can be of the following from\n     *\n     * | File System | Actual           | Modified          |\n     * |-------------|------------------|-------------------|\n     * | LFS (Local) | C:\\Program       | /C:/Program       |\n     * | UNC         | \\\\Server\\Program | ///Server/Program |\n     */\n    isWindowsRoot = function (path) {\n        const drive = path.charAt(1);\n\n        return ((path.charAt(0) === '/') &&\n            ((drive >= 'A' && drive <= 'Z') || (drive >= 'a' && drive <= 'z')) &&\n            (path.charAt(2) === ':')) ||\n            path.slice(0, 3) === '///'; // Modified UNC path\n    },\n\n    stripTrailingSep = function (thePath) {\n        if (thePath[thePath.length - 1] === path.sep) {\n            return thePath.slice(0, -1);\n        }\n\n        return thePath;\n    },\n\n    pathIsInside = function (thePath, potentialParent) {\n        // For inside-directory checking, we want to allow trailing slashes, so normalize.\n        thePath = stripTrailingSep(thePath);\n        potentialParent = stripTrailingSep(potentialParent);\n\n        // Node treats only Windows as case-insensitive in its path module; we follow those conventions.\n        if (global.process.platform === 'win32') {\n            thePath = thePath.toLowerCase();\n            potentialParent = potentialParent.toLowerCase();\n        }\n\n        return thePath.lastIndexOf(potentialParent, 0) === 0 &&\n            (\n                thePath[potentialParent.length] === path.sep ||\n                thePath[potentialParent.length] === undefined\n            );\n    };\n\n/**\n * Secure file resolver wrapper over fs. It only allow access to files inside working directory unless specified.\n *\n * @param {*} workingDir - Path of working directory\n * @param {*} [insecureFileRead=false] - If true, allow reading files outside working directory\n * @param {*} [fileWhitelist=[]] - List of allowed files outside of working directory\n */\nfunction SecureFS (workingDir, insecureFileRead = false, fileWhitelist = []) {\n    this._fs = fs;\n    this._path = path;\n    this.constants = this._fs.constants;\n\n    this.workingDir = workingDir;\n    this.insecureFileRead = insecureFileRead;\n    this.fileWhitelist = fileWhitelist;\n\n    this.isWindows = global.process.platform === 'win32';\n}\n\n/**\n * Private method to resole the path based based on working directory\n *\n * @param {String} relOrAbsPath - Relative or absolute path to resolve\n * @param {Array} whiteList - A list of absolute path to whitelist\n *\n * @returns {String} The resolved path\n */\nSecureFS.prototype._resolve = function (relOrAbsPath, whiteList) {\n    // Special handling for windows absolute paths to work cross platform\n    this.isWindows && isWindowsRoot(relOrAbsPath) && (relOrAbsPath = relOrAbsPath.substring(1));\n\n    // Resolve the path from the working directory. The file should always be resolved so that\n    // cross os variations are mitigated\n    let resolvedPath = this._path.resolve(this.workingDir, relOrAbsPath);\n\n    // Check file is within working directory\n    if (!this.insecureFileRead && // insecureFile read disabled\n        !pathIsInside(resolvedPath, this.workingDir) && // File not inside working directory\n        !_.includes(whiteList, resolvedPath)) { // File not in whitelist\n        // Exit\n        return undefined;\n    }\n\n    return resolvedPath;\n};\n\n/**\n * Asynchronous path resolver function\n *\n * @param {String} relOrAbsPath - Relative or absolute path to resolve\n * @param {Array} [whiteList] - A optional list of additional absolute path to whitelist\n * @param {Function} callback -\n */\nSecureFS.prototype.resolvePath = function (relOrAbsPath, whiteList, callback) {\n    if (!callback && typeof whiteList === FUNCTION) {\n        callback = whiteList;\n        whiteList = [];\n    }\n\n    let resolvedPath = this._resolve(relOrAbsPath, _.concat(this.fileWhitelist, whiteList));\n\n    if (!resolvedPath) {\n        return callback(new Error(PPERM_ERR));\n    }\n\n    return callback(null, resolvedPath);\n};\n\n/**\n * Synchronous path resolver function\n *\n * @param {String} relOrAbsPath - Relative or absolute path to resolve\n * @param {Array} [whiteList] - A optional list of additional absolute path to whitelist\n *\n * @returns {String} The resolved path\n */\nSecureFS.prototype.resolvePathSync = function (relOrAbsPath, whiteList) {\n    // Resolve the path from the working directory\n    const resolvedPath = this._resolve(relOrAbsPath, _.concat(this.fileWhitelist, whiteList));\n\n    if (!resolvedPath) {\n        throw new Error(PPERM_ERR);\n    }\n\n    return resolvedPath;\n};\n\n// Attach all functions in fs to postman-fs\nObject.getOwnPropertyNames(fs).map((prop) => {\n    // Bail-out early to prevent fs module from logging warning for deprecated and experimental methods\n    if (prop === DEPRECATED_SYNC_WRITE_STREAM || prop === EXPERIMENTAL_PROMISE || typeof fs[prop] !== FUNCTION) {\n        return;\n    }\n\n    SecureFS.prototype[prop] = fs[prop];\n});\n\n// Override the required functions\nSecureFS.prototype.stat = function (path, callback) {\n    this.resolvePath(path, (err, resolvedPath) => {\n        if (err) {\n            return callback(err);\n        }\n\n        return this._fs.stat(resolvedPath, callback);\n    });\n};\n\nSecureFS.prototype.createReadStream = function (path, options) {\n    try {\n        return this._fs.createReadStream(this.resolvePathSync(path), options);\n    }\n    catch (err) {\n        // Create a fake read steam that emits and error and\n        const ErrorReadStream = function () {\n            // Replicating behavior of fs module of disabling emitClose on destroy\n            Readable.call(this, { emitClose: false });\n\n            // Emit the error event with insure file access error\n            this.emit('error', new Error(PPERM_ERR));\n\n            // Options exists and disables autoClose then don't destroy\n            (options && !options.autoClose) || this.destroy();\n        };\n\n        util.inherits(ErrorReadStream, Readable);\n\n        return new ErrorReadStream();\n    }\n};\n\nmodule.exports = SecureFS;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}