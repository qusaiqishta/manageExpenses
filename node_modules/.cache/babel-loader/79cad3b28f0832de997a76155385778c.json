{"ast":null,"code":"// Copyright 2012 Joyent, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\nvar utils = require('./utils');\n\n///--- Globals\n\nvar HASH_ALGOS = utils.HASH_ALGOS;\nvar PK_ALGOS = utils.PK_ALGOS;\nvar HttpSignatureError = utils.HttpSignatureError;\nvar InvalidAlgorithmError = utils.InvalidAlgorithmError;\nvar validateAlgorithm = utils.validateAlgorithm;\nvar State = {\n  New: 0,\n  Params: 1\n};\nvar ParamsState = {\n  Name: 0,\n  Quote: 1,\n  Value: 2,\n  Comma: 3,\n  Number: 4\n};\n\n///--- Specific Errors\n\nfunction ExpiredRequestError(message) {\n  HttpSignatureError.call(this, message, ExpiredRequestError);\n}\nutil.inherits(ExpiredRequestError, HttpSignatureError);\nfunction InvalidHeaderError(message) {\n  HttpSignatureError.call(this, message, InvalidHeaderError);\n}\nutil.inherits(InvalidHeaderError, HttpSignatureError);\nfunction InvalidParamsError(message) {\n  HttpSignatureError.call(this, message, InvalidParamsError);\n}\nutil.inherits(InvalidParamsError, HttpSignatureError);\nfunction MissingHeaderError(message) {\n  HttpSignatureError.call(this, message, MissingHeaderError);\n}\nutil.inherits(MissingHeaderError, HttpSignatureError);\nfunction StrictParsingError(message) {\n  HttpSignatureError.call(this, message, StrictParsingError);\n}\nutil.inherits(StrictParsingError, HttpSignatureError);\n\n///--- Exported API\n\nmodule.exports = {\n  /**\n   * Parses the 'Authorization' header out of an http.ServerRequest object.\n   *\n   * Note that this API will fully validate the Authorization header, and throw\n   * on any error.  It will not however check the signature, or the keyId format\n   * as those are specific to your environment.  You can use the options object\n   * to pass in extra constraints.\n   *\n   * As a response object you can expect this:\n   *\n   *     {\n   *       \"scheme\": \"Signature\",\n   *       \"params\": {\n   *         \"keyId\": \"foo\",\n   *         \"algorithm\": \"rsa-sha256\",\n   *         \"headers\": [\n   *           \"date\" or \"x-date\",\n   *           \"digest\"\n   *         ],\n   *         \"signature\": \"base64\"\n   *       },\n   *       \"signingString\": \"ready to be passed to crypto.verify()\"\n   *     }\n   *\n   * @param {Object} request an http.ServerRequest.\n   * @param {Object} options an optional options object with:\n   *                   - clockSkew: allowed clock skew in seconds (default 300).\n   *                   - headers: required header names (def: date or x-date)\n   *                   - algorithms: algorithms to support (default: all).\n   *                   - strict: should enforce latest spec parsing\n   *                             (default: false).\n   * @return {Object} parsed out object (see above).\n   * @throws {TypeError} on invalid input.\n   * @throws {InvalidHeaderError} on an invalid Authorization header error.\n   * @throws {InvalidParamsError} if the params in the scheme are invalid.\n   * @throws {MissingHeaderError} if the params indicate a header not present,\n   *                              either in the request headers from the params,\n   *                              or not in the params from a required header\n   *                              in options.\n   * @throws {StrictParsingError} if old attributes are used in strict parsing\n   *                              mode.\n   * @throws {ExpiredRequestError} if the value of date or x-date exceeds skew.\n   */\n  parseRequest: function parseRequest(request, options) {\n    assert.object(request, 'request');\n    assert.object(request.headers, 'request.headers');\n    if (options === undefined) {\n      options = {};\n    }\n    assert.object(options, 'options');\n    assert.optionalFinite(options.clockSkew, 'options.clockSkew');\n    var headers = [request.headers['x-date'] ? 'x-date' : 'date'];\n    if (options.headers !== undefined) {\n      assert.arrayOfString(headers, 'options.headers');\n      headers = options.headers;\n    }\n    var authzHeaderName = options.authorizationHeaderName;\n    var authz = request.headers[authzHeaderName] || request.headers[utils.HEADER.AUTH] || request.headers[utils.HEADER.SIG];\n    if (!authz) {\n      var errHeader = authzHeaderName ? authzHeaderName : utils.HEADER.AUTH + ' or ' + utils.HEADER.SIG;\n      throw new MissingHeaderError('no ' + errHeader + ' header ' + 'present in the request');\n    }\n    options.clockSkew = options.clockSkew || 300;\n    var i = 0;\n    var state = authz === request.headers[utils.HEADER.SIG] ? State.Params : State.New;\n    var substate = ParamsState.Name;\n    var tmpName = '';\n    var tmpValue = '';\n    var parsed = {\n      scheme: authz === request.headers[utils.HEADER.SIG] ? 'Signature' : '',\n      params: {},\n      signingString: ''\n    };\n    for (i = 0; i < authz.length; i++) {\n      var c = authz.charAt(i);\n      switch (Number(state)) {\n        case State.New:\n          if (c !== ' ') parsed.scheme += c;else state = State.Params;\n          break;\n        case State.Params:\n          switch (Number(substate)) {\n            case ParamsState.Name:\n              var code = c.charCodeAt(0);\n              // restricted name of A-Z / a-z\n              if (code >= 0x41 && code <= 0x5a ||\n              // A-Z\n              code >= 0x61 && code <= 0x7a) {\n                // a-z\n                tmpName += c;\n              } else if (c === '=') {\n                if (tmpName.length === 0) throw new InvalidHeaderError('bad param format');\n                substate = ParamsState.Quote;\n              } else {\n                throw new InvalidHeaderError('bad param format');\n              }\n              break;\n            case ParamsState.Quote:\n              if (c === '\"') {\n                tmpValue = '';\n                substate = ParamsState.Value;\n              } else {\n                //number\n                substate = ParamsState.Number;\n                code = c.charCodeAt(0);\n                if (code < 0x30 || code > 0x39) {\n                  //character not in 0-9\n                  throw new InvalidHeaderError('bad param format');\n                }\n                tmpValue = c;\n              }\n              break;\n            case ParamsState.Value:\n              if (c === '\"') {\n                parsed.params[tmpName] = tmpValue;\n                substate = ParamsState.Comma;\n              } else {\n                tmpValue += c;\n              }\n              break;\n            case ParamsState.Number:\n              if (c === ',') {\n                parsed.params[tmpName] = parseInt(tmpValue, 10);\n                tmpName = '';\n                substate = ParamsState.Name;\n              } else {\n                code = c.charCodeAt(0);\n                if (code < 0x30 || code > 0x39) {\n                  //character not in 0-9\n                  throw new InvalidHeaderError('bad param format');\n                }\n                tmpValue += c;\n              }\n              break;\n            case ParamsState.Comma:\n              if (c === ',') {\n                tmpName = '';\n                substate = ParamsState.Name;\n              } else {\n                throw new InvalidHeaderError('bad param format');\n              }\n              break;\n            default:\n              throw new Error('Invalid substate');\n          }\n          break;\n        default:\n          throw new Error('Invalid substate');\n      }\n    }\n    if (!parsed.params.headers || parsed.params.headers === '') {\n      if (request.headers['x-date']) {\n        parsed.params.headers = ['x-date'];\n      } else {\n        parsed.params.headers = ['date'];\n      }\n    } else {\n      parsed.params.headers = parsed.params.headers.split(' ');\n    }\n\n    // Minimally validate the parsed object\n    if (!parsed.scheme || parsed.scheme !== 'Signature') throw new InvalidHeaderError('scheme was not \"Signature\"');\n    if (!parsed.params.keyId) throw new InvalidHeaderError('keyId was not specified');\n    if (!parsed.params.algorithm) throw new InvalidHeaderError('algorithm was not specified');\n    if (!parsed.params.signature) throw new InvalidHeaderError('signature was not specified');\n\n    // Check the algorithm against the official list\n    try {\n      validateAlgorithm(parsed.params.algorithm);\n    } catch (e) {\n      if (e instanceof InvalidAlgorithmError) throw new InvalidParamsError(parsed.params.algorithm + ' is not ' + 'supported');else throw e;\n    }\n\n    // Build the signingString\n    for (i = 0; i < parsed.params.headers.length; i++) {\n      var h = parsed.params.headers[i].toLowerCase();\n      parsed.params.headers[i] = h;\n      if (h === 'request-line') {\n        if (!options.strict) {\n          /*\n           * We allow headers from the older spec drafts if strict parsing isn't\n           * specified in options.\n           */\n          parsed.signingString += request.method + ' ' + request.url + ' HTTP/' + request.httpVersion;\n        } else {\n          /* Strict parsing doesn't allow older draft headers. */\n          throw new StrictParsingError('request-line is not a valid header ' + 'with strict parsing enabled.');\n        }\n      } else if (h === '(request-target)') {\n        parsed.signingString += '(request-target): ' + request.method.toLowerCase() + ' ' + request.url;\n      } else if (h === '(keyid)') {\n        parsed.signingString += '(keyid): ' + parsed.params.keyId;\n      } else if (h === '(algorithm)') {\n        parsed.signingString += '(algorithm): ' + parsed.params.algorithm;\n      } else if (h === '(opaque)') {\n        var opaque = parsed.params.opaque;\n        if (opaque === undefined) {\n          throw new MissingHeaderError('opaque param was not in the ' + authzHeaderName + ' header');\n        }\n        parsed.signingString += '(opaque): ' + opaque;\n      } else if (h === '(created)') {\n        parsed.signingString += '(created): ' + parsed.params.created;\n      } else if (h === '(expires)') {\n        parsed.signingString += '(expires): ' + parsed.params.expires;\n      } else {\n        var value = request.headers[h];\n        if (value === undefined) throw new MissingHeaderError(h + ' was not in the request');\n        parsed.signingString += h + ': ' + value;\n      }\n      if (i + 1 < parsed.params.headers.length) parsed.signingString += '\\n';\n    }\n\n    // Check against the constraints\n    var date;\n    var skew;\n    if (request.headers.date || request.headers['x-date']) {\n      if (request.headers['x-date']) {\n        date = new Date(request.headers['x-date']);\n      } else {\n        date = new Date(request.headers.date);\n      }\n      var now = new Date();\n      skew = Math.abs(now.getTime() - date.getTime());\n      if (skew > options.clockSkew * 1000) {\n        throw new ExpiredRequestError('clock skew of ' + skew / 1000 + 's was greater than ' + options.clockSkew + 's');\n      }\n    }\n    if (parsed.params.created) {\n      skew = parsed.params.created - Math.floor(Date.now() / 1000);\n      if (skew > options.clockSkew) {\n        throw new ExpiredRequestError('Created lies in the future (with ' + 'skew ' + skew + 's greater than allowed ' + options.clockSkew + 's');\n      }\n    }\n    if (parsed.params.expires) {\n      var expiredSince = Math.floor(Date.now() / 1000) - parsed.params.expires;\n      if (expiredSince > options.clockSkew) {\n        throw new ExpiredRequestError('Request expired with skew ' + expiredSince + 's greater than allowed ' + options.clockSkew + 's');\n      }\n    }\n    headers.forEach(function (hdr) {\n      // Remember that we already checked any headers in the params\n      // were in the request, so if this passes we're good.\n      if (parsed.params.headers.indexOf(hdr.toLowerCase()) < 0) throw new MissingHeaderError(hdr + ' was not a signed header');\n    });\n    parsed.params.algorithm = parsed.params.algorithm.toLowerCase();\n    if (options.algorithms) {\n      if (options.algorithms.indexOf(parsed.params.algorithm) === -1) throw new InvalidParamsError(parsed.params.algorithm + ' is not a supported algorithm');\n    }\n    parsed.algorithm = parsed.params.algorithm.toUpperCase();\n    parsed.keyId = parsed.params.keyId;\n    parsed.opaque = parsed.params.opaque;\n    return parsed;\n  }\n};","map":{"version":3,"names":["assert","require","util","utils","HASH_ALGOS","PK_ALGOS","HttpSignatureError","InvalidAlgorithmError","validateAlgorithm","State","New","Params","ParamsState","Name","Quote","Value","Comma","Number","ExpiredRequestError","message","call","inherits","InvalidHeaderError","InvalidParamsError","MissingHeaderError","StrictParsingError","module","exports","parseRequest","request","options","object","headers","undefined","optionalFinite","clockSkew","arrayOfString","authzHeaderName","authorizationHeaderName","authz","HEADER","AUTH","SIG","errHeader","i","state","substate","tmpName","tmpValue","parsed","scheme","params","signingString","length","c","charAt","code","charCodeAt","parseInt","Error","split","keyId","algorithm","signature","e","h","toLowerCase","strict","method","url","httpVersion","opaque","created","expires","value","date","skew","Date","now","Math","abs","getTime","floor","expiredSince","forEach","hdr","indexOf","algorithms","toUpperCase"],"sources":["/Users/Qusai.Qishta/node_modules/http-signature/lib/parser.js"],"sourcesContent":["// Copyright 2012 Joyent, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\nvar utils = require('./utils');\n\n\n\n///--- Globals\n\nvar HASH_ALGOS = utils.HASH_ALGOS;\nvar PK_ALGOS = utils.PK_ALGOS;\nvar HttpSignatureError = utils.HttpSignatureError;\nvar InvalidAlgorithmError = utils.InvalidAlgorithmError;\nvar validateAlgorithm = utils.validateAlgorithm;\n\nvar State = {\n  New: 0,\n  Params: 1\n};\n\nvar ParamsState = {\n  Name: 0,\n  Quote: 1,\n  Value: 2,\n  Comma: 3,\n  Number: 4\n};\n\n///--- Specific Errors\n\n\nfunction ExpiredRequestError(message) {\n  HttpSignatureError.call(this, message, ExpiredRequestError);\n}\nutil.inherits(ExpiredRequestError, HttpSignatureError);\n\n\nfunction InvalidHeaderError(message) {\n  HttpSignatureError.call(this, message, InvalidHeaderError);\n}\nutil.inherits(InvalidHeaderError, HttpSignatureError);\n\n\nfunction InvalidParamsError(message) {\n  HttpSignatureError.call(this, message, InvalidParamsError);\n}\nutil.inherits(InvalidParamsError, HttpSignatureError);\n\n\nfunction MissingHeaderError(message) {\n  HttpSignatureError.call(this, message, MissingHeaderError);\n}\nutil.inherits(MissingHeaderError, HttpSignatureError);\n\nfunction StrictParsingError(message) {\n  HttpSignatureError.call(this, message, StrictParsingError);\n}\nutil.inherits(StrictParsingError, HttpSignatureError);\n\n///--- Exported API\n\nmodule.exports = {\n\n  /**\n   * Parses the 'Authorization' header out of an http.ServerRequest object.\n   *\n   * Note that this API will fully validate the Authorization header, and throw\n   * on any error.  It will not however check the signature, or the keyId format\n   * as those are specific to your environment.  You can use the options object\n   * to pass in extra constraints.\n   *\n   * As a response object you can expect this:\n   *\n   *     {\n   *       \"scheme\": \"Signature\",\n   *       \"params\": {\n   *         \"keyId\": \"foo\",\n   *         \"algorithm\": \"rsa-sha256\",\n   *         \"headers\": [\n   *           \"date\" or \"x-date\",\n   *           \"digest\"\n   *         ],\n   *         \"signature\": \"base64\"\n   *       },\n   *       \"signingString\": \"ready to be passed to crypto.verify()\"\n   *     }\n   *\n   * @param {Object} request an http.ServerRequest.\n   * @param {Object} options an optional options object with:\n   *                   - clockSkew: allowed clock skew in seconds (default 300).\n   *                   - headers: required header names (def: date or x-date)\n   *                   - algorithms: algorithms to support (default: all).\n   *                   - strict: should enforce latest spec parsing\n   *                             (default: false).\n   * @return {Object} parsed out object (see above).\n   * @throws {TypeError} on invalid input.\n   * @throws {InvalidHeaderError} on an invalid Authorization header error.\n   * @throws {InvalidParamsError} if the params in the scheme are invalid.\n   * @throws {MissingHeaderError} if the params indicate a header not present,\n   *                              either in the request headers from the params,\n   *                              or not in the params from a required header\n   *                              in options.\n   * @throws {StrictParsingError} if old attributes are used in strict parsing\n   *                              mode.\n   * @throws {ExpiredRequestError} if the value of date or x-date exceeds skew.\n   */\n  parseRequest: function parseRequest(request, options) {\n    assert.object(request, 'request');\n    assert.object(request.headers, 'request.headers');\n    if (options === undefined) {\n      options = {};\n    }\n    assert.object(options, 'options');\n    assert.optionalFinite(options.clockSkew, 'options.clockSkew');\n\n    var headers = [request.headers['x-date'] ? 'x-date' : 'date'];\n    if (options.headers !== undefined) {\n      assert.arrayOfString(headers, 'options.headers');\n      headers = options.headers;\n    }\n\n    var authzHeaderName = options.authorizationHeaderName;\n    var authz = request.headers[authzHeaderName] ||\n      request.headers[utils.HEADER.AUTH] || request.headers[utils.HEADER.SIG];\n\n    if (!authz) {\n      var errHeader = authzHeaderName ? authzHeaderName :\n        utils.HEADER.AUTH + ' or ' + utils.HEADER.SIG;\n\n      throw new MissingHeaderError('no ' + errHeader + ' header ' +\n        'present in the request');\n    }\n\n    options.clockSkew = options.clockSkew || 300;\n\n\n    var i = 0;\n    var state = authz === request.headers[utils.HEADER.SIG] ?\n      State.Params : State.New;\n    var substate = ParamsState.Name;\n    var tmpName = '';\n    var tmpValue = '';\n\n    var parsed = {\n      scheme: authz === request.headers[utils.HEADER.SIG] ? 'Signature' : '',\n      params: {},\n      signingString: ''\n    };\n\n    for (i = 0; i < authz.length; i++) {\n      var c = authz.charAt(i);\n\n      switch (Number(state)) {\n\n        case State.New:\n          if (c !== ' ') parsed.scheme += c;\n          else state = State.Params;\n          break;\n\n        case State.Params:\n          switch (Number(substate)) {\n\n            case ParamsState.Name:\n              var code = c.charCodeAt(0);\n              // restricted name of A-Z / a-z\n              if ((code >= 0x41 && code <= 0x5a) || // A-Z\n                (code >= 0x61 && code <= 0x7a)) { // a-z\n                tmpName += c;\n              } else if (c === '=') {\n                if (tmpName.length === 0)\n                  throw new InvalidHeaderError('bad param format');\n                substate = ParamsState.Quote;\n              } else {\n                throw new InvalidHeaderError('bad param format');\n              }\n              break;\n\n            case ParamsState.Quote:\n              if (c === '\"') {\n                tmpValue = '';\n                substate = ParamsState.Value;\n              } else {\n                //number\n                substate = ParamsState.Number;\n                code = c.charCodeAt(0);\n                if (code < 0x30 || code > 0x39) { //character not in 0-9\n                  throw new InvalidHeaderError('bad param format');\n                }\n                tmpValue = c;\n              }\n              break;\n\n            case ParamsState.Value:\n              if (c === '\"') {\n                parsed.params[tmpName] = tmpValue;\n                substate = ParamsState.Comma;\n              } else {\n                tmpValue += c;\n              }\n              break;\n\n            case ParamsState.Number:\n              if (c === ',') {\n                parsed.params[tmpName] = parseInt(tmpValue, 10);\n                tmpName = '';\n                substate = ParamsState.Name;\n              } else {\n                code = c.charCodeAt(0);\n                if (code < 0x30 || code > 0x39) { //character not in 0-9\n                  throw new InvalidHeaderError('bad param format');\n                }\n                tmpValue += c;\n              }\n              break;\n\n\n            case ParamsState.Comma:\n              if (c === ',') {\n                tmpName = '';\n                substate = ParamsState.Name;\n              } else {\n                throw new InvalidHeaderError('bad param format');\n              }\n              break;\n\n            default:\n              throw new Error('Invalid substate');\n          }\n          break;\n\n        default:\n          throw new Error('Invalid substate');\n      }\n\n    }\n\n    if (!parsed.params.headers || parsed.params.headers === '') {\n      if (request.headers['x-date']) {\n        parsed.params.headers = ['x-date'];\n      } else {\n        parsed.params.headers = ['date'];\n      }\n    } else {\n      parsed.params.headers = parsed.params.headers.split(' ');\n    }\n\n    // Minimally validate the parsed object\n    if (!parsed.scheme || parsed.scheme !== 'Signature')\n      throw new InvalidHeaderError('scheme was not \"Signature\"');\n\n    if (!parsed.params.keyId)\n      throw new InvalidHeaderError('keyId was not specified');\n\n    if (!parsed.params.algorithm)\n      throw new InvalidHeaderError('algorithm was not specified');\n\n    if (!parsed.params.signature)\n      throw new InvalidHeaderError('signature was not specified');\n\n    // Check the algorithm against the official list\n    try {\n      validateAlgorithm(parsed.params.algorithm);\n    } catch (e) {\n      if (e instanceof InvalidAlgorithmError)\n        throw (new InvalidParamsError(parsed.params.algorithm + ' is not ' +\n          'supported'));\n      else\n        throw (e);\n    }\n\n    // Build the signingString\n    for (i = 0; i < parsed.params.headers.length; i++) {\n      var h = parsed.params.headers[i].toLowerCase();\n      parsed.params.headers[i] = h;\n\n      if (h === 'request-line') {\n        if (!options.strict) {\n          /*\n           * We allow headers from the older spec drafts if strict parsing isn't\n           * specified in options.\n           */\n          parsed.signingString +=\n            request.method + ' ' + request.url + ' HTTP/' + request.httpVersion;\n        } else {\n          /* Strict parsing doesn't allow older draft headers. */\n          throw (new StrictParsingError('request-line is not a valid header ' +\n            'with strict parsing enabled.'));\n        }\n      } else if (h === '(request-target)') {\n        parsed.signingString +=\n          '(request-target): ' + request.method.toLowerCase() + ' ' +\n          request.url;\n      } else if (h === '(keyid)') {\n        parsed.signingString += '(keyid): ' + parsed.params.keyId;\n      } else if (h === '(algorithm)') {\n        parsed.signingString += '(algorithm): ' + parsed.params.algorithm;\n      } else if (h === '(opaque)') {\n        var opaque = parsed.params.opaque;\n        if (opaque === undefined) {\n          throw new MissingHeaderError('opaque param was not in the ' +\n            authzHeaderName + ' header');\n        }\n        parsed.signingString += '(opaque): ' + opaque;\n      } else if (h === '(created)') {\n        parsed.signingString += '(created): ' + parsed.params.created;\n    } else if (h === '(expires)') {\n        parsed.signingString += '(expires): ' + parsed.params.expires;\n      } else {\n        var value = request.headers[h];\n        if (value === undefined)\n          throw new MissingHeaderError(h + ' was not in the request');\n        parsed.signingString += h + ': ' + value;\n      }\n\n      if ((i + 1) < parsed.params.headers.length)\n        parsed.signingString += '\\n';\n    }\n\n    // Check against the constraints\n    var date;\n    var skew;\n    if (request.headers.date || request.headers['x-date']) {\n      if (request.headers['x-date']) {\n        date = new Date(request.headers['x-date']);\n      } else {\n        date = new Date(request.headers.date);\n      }\n      var now = new Date();\n      skew = Math.abs(now.getTime() - date.getTime());\n\n      if (skew > options.clockSkew * 1000) {\n        throw new ExpiredRequestError('clock skew of ' +\n          (skew / 1000) +\n          's was greater than ' +\n          options.clockSkew + 's');\n      }\n    }\n\n    if (parsed.params.created) {\n      skew = parsed.params.created  - Math.floor(Date.now() / 1000);\n      if (skew > options.clockSkew) {\n        throw new ExpiredRequestError('Created lies in the future (with ' +\n          'skew ' + skew + 's greater than allowed ' + options.clockSkew +\n          's');\n      }\n    }\n\n    if (parsed.params.expires) {\n      var expiredSince = Math.floor(Date.now() / 1000) - parsed.params.expires;\n      if (expiredSince > options.clockSkew) {\n        throw new ExpiredRequestError('Request expired with skew ' +\n          expiredSince + 's greater than allowed ' + options.clockSkew + 's');\n      }\n    }\n\n    headers.forEach(function (hdr) {\n      // Remember that we already checked any headers in the params\n      // were in the request, so if this passes we're good.\n      if (parsed.params.headers.indexOf(hdr.toLowerCase()) < 0)\n        throw new MissingHeaderError(hdr + ' was not a signed header');\n    });\n\n    parsed.params.algorithm = parsed.params.algorithm.toLowerCase();\n    if (options.algorithms) {\n      if (options.algorithms.indexOf(parsed.params.algorithm) === -1)\n        throw new InvalidParamsError(parsed.params.algorithm +\n          ' is not a supported algorithm');\n    }\n\n    parsed.algorithm = parsed.params.algorithm.toUpperCase();\n    parsed.keyId = parsed.params.keyId;\n    parsed.opaque = parsed.params.opaque;\n    return parsed;\n  }\n\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}