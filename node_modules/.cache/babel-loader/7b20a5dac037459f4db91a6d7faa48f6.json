{"ast":null,"code":"var url = require('url'),\n  _ = require('lodash'),\n  crypto = require('crypto'),\n  Hawk = require('postman-request/lib/hawk'),\n  RequestBody = require('postman-collection').RequestBody,\n  bodyBuilder = require('../requester/core-body-builder'),\n  urlEncoder = require('postman-url-encoder'),\n  ASCII_SOURCE = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789',\n  ASCII_SOURCE_LENGTH = ASCII_SOURCE.length,\n  AUTHORIZATION = 'Authorization',\n  EMPTY = '';\n\n/**\n * Generates a random string of given length (useful for nonce generation, etc).\n *\n * @param {Number} length -\n */\nfunction randomString(length) {\n  length = length || 6;\n  var result = [],\n    i;\n  for (i = 0; i < length; i++) {\n    result[i] = ASCII_SOURCE[Math.random() * ASCII_SOURCE_LENGTH | 0];\n  }\n  return result.join(EMPTY);\n}\n\n/**\n * Calculates body hash with given algorithm and digestEncoding.\n * REFER: https://github.com/postmanlabs/postman-request/blob/master/lib/hawk.js#L12\n *\n * @param {RequestBody} body -\n * @param {String} algorithm -\n * @param {String} digestEncoding -\n * @param {String} contentType -\n * @param {Function} callback -\n */\nfunction computeBodyHash(body, algorithm, digestEncoding, contentType, callback) {\n  if (!(body && algorithm && digestEncoding) || body.isEmpty()) {\n    return callback();\n  }\n  var hash = crypto.createHash(algorithm),\n    originalReadStream,\n    rawBody,\n    urlencodedBody,\n    graphqlBody;\n  hash.update('hawk.1.payload\\n');\n  hash.update((contentType ? contentType.split(';')[0].trim().toLowerCase() : '') + '\\n');\n  if (body.mode === RequestBody.MODES.raw) {\n    rawBody = bodyBuilder.raw(body.raw).body;\n    hash.update(rawBody);\n    hash.update('\\n');\n    return callback(hash.digest(digestEncoding));\n  }\n  if (body.mode === RequestBody.MODES.urlencoded) {\n    urlencodedBody = bodyBuilder.urlencoded(body.urlencoded).form;\n    urlencodedBody = urlEncoder.encodeQueryString(urlencodedBody);\n    hash.update(urlencodedBody);\n    hash.update('\\n');\n    return callback(hash.digest(digestEncoding));\n  }\n  if (body.mode === RequestBody.MODES.file) {\n    originalReadStream = _.get(body, 'file.content');\n    if (!originalReadStream) {\n      return callback();\n    }\n    return originalReadStream.cloneReadStream(function (err, clonedStream) {\n      if (err) {\n        return callback();\n      }\n      clonedStream.on('data', function (chunk) {\n        hash.update(chunk);\n      });\n      clonedStream.on('end', function () {\n        hash.update('\\n');\n        callback(hash.digest(digestEncoding));\n      });\n    });\n  }\n  if (body.mode === RequestBody.MODES.graphql) {\n    graphqlBody = bodyBuilder.graphql(body.graphql).body;\n    hash.update(graphqlBody);\n    hash.update('\\n');\n    return callback(hash.digest(digestEncoding));\n  }\n\n  // @todo: Figure out a way to calculate hash for formdata body type.\n\n  // ensure that callback is called if body.mode doesn't match with any of the above modes\n  return callback();\n}\n\n/**\n * @implements {AuthHandlerInterface}\n */\nmodule.exports = {\n  /**\n   * @property {AuthHandlerInterface~AuthManifest}\n   */\n  manifest: {\n    info: {\n      name: 'hawk',\n      version: '1.0.0'\n    },\n    updates: [{\n      property: 'Authorization',\n      type: 'header'\n    }, {\n      property: 'nonce',\n      type: 'auth'\n    }, {\n      property: 'timestamp',\n      type: 'auth'\n    }]\n  },\n  /**\n   * Initializes an item (extracts parameters from intermediate requests if any, etc)\n   * before the actual authorization step.\n   *\n   * @param {AuthInterface} auth -\n   * @param {Response} response -\n   * @param {AuthHandlerInterface~authInitHookCallback} done -\n   */\n  init: function (auth, response, done) {\n    done(null);\n  },\n  /**\n   * Checks the item, and fetches any parameters that are not already provided.\n   * Sanitizes the auth parameters if needed.\n   *\n   * @param {AuthInterface} auth -\n   * @param {AuthHandlerInterface~authPreHookCallback} done -\n   */\n  pre: function (auth, done) {\n    !auth.get('nonce') && auth.set('nonce', randomString(6));\n    !_.parseInt(auth.get('timestamp')) && auth.set('timestamp', Math.floor(Date.now() / 1e3));\n    done(null, true);\n  },\n  /**\n   * Verifies whether the request was successfully authorized after being sent.\n   *\n   * @param {AuthInterface} auth -\n   * @param {Response} response -\n   * @param {AuthHandlerInterface~authPostHookCallback} done -\n   */\n  post: function (auth, response, done) {\n    done(null, true);\n  },\n  /**\n   * Computes signature and Auth header for a request.\n   *\n   * @param {Object} params -\n   * @param {Object} params.credentials Contains hawk auth credentials, \"id\", \"key\" and \"algorithm\"\n   * @param {String} params.nonce -\n   * @param {String} params.ext Extra data that may be associated with the request.\n   * @param {String} params.app Application ID used in Oz authorization protocol\n   * @param {String} params.dlg Delegation information (used in the Oz protocol)\n   * @param {String} params.user User id\n   * @param {String} params.url Complete request URL\n   * @param {String} params.method Request method\n   *\n   * @returns {*}\n   */\n  computeHeader: function (params) {\n    return Hawk.header(url.parse(params.url), params.method, params);\n  },\n  /**\n   * Signs a request.\n   *\n   * @param {AuthInterface} auth -\n   * @param {Request} request -\n   * @param {AuthHandlerInterface~authSignHookCallback} done -\n   */\n  sign: function (auth, request, done) {\n    var params = auth.get(['authId', 'authKey', 'algorithm', 'nonce', 'timestamp', 'extraData', 'app', 'delegation', 'user', 'includePayloadHash']),\n      contentType = request.headers.get('content-type'),\n      self = this,\n      signRequest = function (bodyHash) {\n        // force toString to add a protocol to the URL.\n        var url = urlEncoder.toNodeUrl(request.url),\n          result = self.computeHeader({\n            credentials: {\n              id: params.authId,\n              key: params.authKey,\n              algorithm: params.algorithm\n            },\n            nonce: params.nonce,\n            timestamp: params.timestamp,\n            ext: params.extraData,\n            app: params.app,\n            dlg: params.delegation,\n            user: params.user,\n            url: url.href,\n            method: request.method,\n            hash: bodyHash\n          });\n        request.addHeader({\n          key: AUTHORIZATION,\n          value: result,\n          system: true\n        });\n        return done();\n      };\n    if (!params.authId || !params.authKey) {\n      return done(); // Nothing to do if required parameters are not present.\n    }\n\n    request.removeHeader(AUTHORIZATION, {\n      ignoreCase: true\n    });\n\n    // @note: Payload verification is optional in hawk auth according to specifications (see below link). If user\n    //        opt-in for payload verification, `Content-Type` header must be specified explicitely otherwise\n    //        authentication might fail because we automatically add `Content-Type` header after auth handlers which\n    //        is not accounted while calculating payload hash for hawk auth.\n    //        documentation: https://github.com/hapijs/hawk#payload-validation\n    //        issue: https://github.com/postmanlabs/postman-app-support/issues/6550\n    //\n    // @todo: Change flow of auto adding `Content-Type` header to happen before auth handlers\n    if (!params.includePayloadHash) {\n      return signRequest(); // sign request without calculating payload hash\n    }\n\n    computeBodyHash(request.body, params.algorithm, 'base64', contentType, signRequest);\n  }\n};","map":{"version":3,"names":["url","require","_","crypto","Hawk","RequestBody","bodyBuilder","urlEncoder","ASCII_SOURCE","ASCII_SOURCE_LENGTH","length","AUTHORIZATION","EMPTY","randomString","result","i","Math","random","join","computeBodyHash","body","algorithm","digestEncoding","contentType","callback","isEmpty","hash","createHash","originalReadStream","rawBody","urlencodedBody","graphqlBody","update","split","trim","toLowerCase","mode","MODES","raw","digest","urlencoded","form","encodeQueryString","file","get","cloneReadStream","err","clonedStream","on","chunk","graphql","module","exports","manifest","info","name","version","updates","property","type","init","auth","response","done","pre","set","parseInt","floor","Date","now","post","computeHeader","params","header","parse","method","sign","request","headers","self","signRequest","bodyHash","toNodeUrl","credentials","id","authId","key","authKey","nonce","timestamp","ext","extraData","app","dlg","delegation","user","href","addHeader","value","system","removeHeader","ignoreCase","includePayloadHash"],"sources":["/Users/Qusai.Qishta/node_modules/postman-runtime/lib/authorizer/hawk.js"],"sourcesContent":["var url = require('url'),\n    _ = require('lodash'),\n    crypto = require('crypto'),\n    Hawk = require('postman-request/lib/hawk'),\n    RequestBody = require('postman-collection').RequestBody,\n    bodyBuilder = require('../requester/core-body-builder'),\n    urlEncoder = require('postman-url-encoder'),\n\n    ASCII_SOURCE = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789',\n    ASCII_SOURCE_LENGTH = ASCII_SOURCE.length,\n    AUTHORIZATION = 'Authorization',\n    EMPTY = '';\n\n/**\n * Generates a random string of given length (useful for nonce generation, etc).\n *\n * @param {Number} length -\n */\nfunction randomString (length) {\n    length = length || 6;\n\n    var result = [],\n        i;\n\n    for (i = 0; i < length; i++) {\n        result[i] = ASCII_SOURCE[(Math.random() * ASCII_SOURCE_LENGTH) | 0];\n    }\n\n    return result.join(EMPTY);\n}\n\n/**\n * Calculates body hash with given algorithm and digestEncoding.\n * REFER: https://github.com/postmanlabs/postman-request/blob/master/lib/hawk.js#L12\n *\n * @param {RequestBody} body -\n * @param {String} algorithm -\n * @param {String} digestEncoding -\n * @param {String} contentType -\n * @param {Function} callback -\n */\nfunction computeBodyHash (body, algorithm, digestEncoding, contentType, callback) {\n    if (!(body && algorithm && digestEncoding) || body.isEmpty()) { return callback(); }\n\n    var hash = crypto.createHash(algorithm),\n        originalReadStream,\n        rawBody,\n        urlencodedBody,\n        graphqlBody;\n\n    hash.update('hawk.1.payload\\n');\n    hash.update((contentType ? contentType.split(';')[0].trim().toLowerCase() : '') + '\\n');\n\n    if (body.mode === RequestBody.MODES.raw) {\n        rawBody = bodyBuilder.raw(body.raw).body;\n        hash.update(rawBody);\n        hash.update('\\n');\n\n        return callback(hash.digest(digestEncoding));\n    }\n\n    if (body.mode === RequestBody.MODES.urlencoded) {\n        urlencodedBody = bodyBuilder.urlencoded(body.urlencoded).form;\n        urlencodedBody = urlEncoder.encodeQueryString(urlencodedBody);\n        hash.update(urlencodedBody);\n        hash.update('\\n');\n\n        return callback(hash.digest(digestEncoding));\n    }\n\n    if (body.mode === RequestBody.MODES.file) {\n        originalReadStream = _.get(body, 'file.content');\n\n        if (!originalReadStream) {\n            return callback();\n        }\n\n        return originalReadStream.cloneReadStream(function (err, clonedStream) {\n            if (err) { return callback(); }\n\n            clonedStream.on('data', function (chunk) {\n                hash.update(chunk);\n            });\n\n            clonedStream.on('end', function () {\n                hash.update('\\n');\n                callback(hash.digest(digestEncoding));\n            });\n        });\n    }\n\n    if (body.mode === RequestBody.MODES.graphql) {\n        graphqlBody = bodyBuilder.graphql(body.graphql).body;\n        hash.update(graphqlBody);\n        hash.update('\\n');\n\n        return callback(hash.digest(digestEncoding));\n    }\n\n    // @todo: Figure out a way to calculate hash for formdata body type.\n\n    // ensure that callback is called if body.mode doesn't match with any of the above modes\n    return callback();\n}\n\n/**\n * @implements {AuthHandlerInterface}\n */\nmodule.exports = {\n    /**\n     * @property {AuthHandlerInterface~AuthManifest}\n     */\n    manifest: {\n        info: {\n            name: 'hawk',\n            version: '1.0.0'\n        },\n        updates: [\n            {\n                property: 'Authorization',\n                type: 'header'\n            },\n            {\n                property: 'nonce',\n                type: 'auth'\n            },\n            {\n                property: 'timestamp',\n                type: 'auth'\n            }\n        ]\n    },\n\n    /**\n     * Initializes an item (extracts parameters from intermediate requests if any, etc)\n     * before the actual authorization step.\n     *\n     * @param {AuthInterface} auth -\n     * @param {Response} response -\n     * @param {AuthHandlerInterface~authInitHookCallback} done -\n     */\n    init: function (auth, response, done) {\n        done(null);\n    },\n\n    /**\n     * Checks the item, and fetches any parameters that are not already provided.\n     * Sanitizes the auth parameters if needed.\n     *\n     * @param {AuthInterface} auth -\n     * @param {AuthHandlerInterface~authPreHookCallback} done -\n     */\n    pre: function (auth, done) {\n        !auth.get('nonce') && auth.set('nonce', randomString(6));\n        !_.parseInt(auth.get('timestamp')) && auth.set('timestamp', Math.floor(Date.now() / 1e3));\n        done(null, true);\n    },\n\n    /**\n     * Verifies whether the request was successfully authorized after being sent.\n     *\n     * @param {AuthInterface} auth -\n     * @param {Response} response -\n     * @param {AuthHandlerInterface~authPostHookCallback} done -\n     */\n    post: function (auth, response, done) {\n        done(null, true);\n    },\n\n    /**\n     * Computes signature and Auth header for a request.\n     *\n     * @param {Object} params -\n     * @param {Object} params.credentials Contains hawk auth credentials, \"id\", \"key\" and \"algorithm\"\n     * @param {String} params.nonce -\n     * @param {String} params.ext Extra data that may be associated with the request.\n     * @param {String} params.app Application ID used in Oz authorization protocol\n     * @param {String} params.dlg Delegation information (used in the Oz protocol)\n     * @param {String} params.user User id\n     * @param {String} params.url Complete request URL\n     * @param {String} params.method Request method\n     *\n     * @returns {*}\n     */\n    computeHeader: function (params) {\n        return Hawk.header(url.parse(params.url), params.method, params);\n    },\n\n    /**\n     * Signs a request.\n     *\n     * @param {AuthInterface} auth -\n     * @param {Request} request -\n     * @param {AuthHandlerInterface~authSignHookCallback} done -\n     */\n    sign: function (auth, request, done) {\n        var params = auth.get([\n                'authId',\n                'authKey',\n                'algorithm',\n                'nonce',\n                'timestamp',\n                'extraData',\n                'app',\n                'delegation',\n                'user',\n                'includePayloadHash'\n            ]),\n\n            contentType = request.headers.get('content-type'),\n\n            self = this,\n\n            signRequest = function (bodyHash) {\n                // force toString to add a protocol to the URL.\n                var url = urlEncoder.toNodeUrl(request.url),\n\n                    result = self.computeHeader({\n                        credentials: {\n                            id: params.authId,\n                            key: params.authKey,\n                            algorithm: params.algorithm\n                        },\n                        nonce: params.nonce,\n                        timestamp: params.timestamp,\n                        ext: params.extraData,\n                        app: params.app,\n                        dlg: params.delegation,\n                        user: params.user,\n                        url: url.href,\n                        method: request.method,\n                        hash: bodyHash\n                    });\n\n                request.addHeader({\n                    key: AUTHORIZATION,\n                    value: result,\n                    system: true\n                });\n\n                return done();\n            };\n\n        if (!params.authId || !params.authKey) {\n            return done(); // Nothing to do if required parameters are not present.\n        }\n\n        request.removeHeader(AUTHORIZATION, { ignoreCase: true });\n\n        // @note: Payload verification is optional in hawk auth according to specifications (see below link). If user\n        //        opt-in for payload verification, `Content-Type` header must be specified explicitely otherwise\n        //        authentication might fail because we automatically add `Content-Type` header after auth handlers which\n        //        is not accounted while calculating payload hash for hawk auth.\n        //        documentation: https://github.com/hapijs/hawk#payload-validation\n        //        issue: https://github.com/postmanlabs/postman-app-support/issues/6550\n        //\n        // @todo: Change flow of auto adding `Content-Type` header to happen before auth handlers\n        if (!params.includePayloadHash) {\n            return signRequest(); // sign request without calculating payload hash\n        }\n\n        computeBodyHash(request.body, params.algorithm, 'base64', contentType, signRequest);\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}