{"ast":null,"code":"var _ = require('../util').lodash,\n  uuid = require('uuid'),\n  PropertyBase = require('./property-base').PropertyBase,\n  Description = require('./description').Description,\n  Substitutor = require('../superstring').Substitutor,\n  DISABLED = 'disabled',\n  DESCRIPTION = 'description',\n  REGEX_EXTRACT_VARS = Substitutor.REGEX_EXTRACT_VARS,\n  Property; // constructor\n\n/**\n * Recursively traverses a variable and detects all instances of variable\n * replacements within the string of the object.\n *\n * @private\n * @param {*} value Any JS variable within which we are trying to discover {{variables}}\n * @param {[Object]} seen Set of objects traversed before to avoid infinite recursion\n * @param {[Object]} result Set of variables to accumulate result in the recursive call\n * @returns {Object} Set of variables\n */\nfunction _findSubstitutions(value) {\n  let seen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n  let result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n  if (!value || seen.has(value)) {\n    return result;\n  }\n  if (Array.isArray(value)) {\n    seen.add(value);\n    for (let i = 0, ii = value.length; i < ii; i++) {\n      _findSubstitutions(value[i], seen, result);\n    }\n  } else if (typeof value === 'object') {\n    seen.add(value);\n    for (const key in value) {\n      if (Object.hasOwnProperty.call(value, key)) {\n        _findSubstitutions(value[key], seen, result);\n      }\n    }\n  } else if (typeof value === 'string') {\n    let match;\n    while ((match = REGEX_EXTRACT_VARS.exec(value)) !== null) {\n      result.add(match[0].slice(2, -2));\n    }\n  }\n  return result;\n}\n\n/**\n * @typedef Property.definition\n * @property {String=} [id] A unique string that identifies the property.\n * @property {String=} [name] A distinctive and human-readable name of the property.\n * @property {Boolean=} [disabled] Denotes whether the property is disabled or not.\n * @property {Object=} [info] The meta information regarding the Property is provided as the `info` object.\n * @property {String=} [info.id] If set, this is used instead of the definition root's id.\n * @property {String=} [info.name] If set, this is used instead of the definition root's name.\n */\n_.inherit(\n/**\n * The Property class forms the base of all postman collection SDK elements. This is to be used only for SDK\n * development or to extend the SDK with additional functionalities. All SDK classes (constructors) that are\n * supposed to be identifyable (i.e. ones that can have a `name` and `id`) are derived from this class.\n *\n * For more information on what is the structure of the `definition` the function parameter, have a look at\n * {@link Property.definition}.\n *\n * > This is intended to be a private class except for those who want to extend the SDK itself and add more\n * > functionalities.\n *\n * @constructor\n * @extends {PropertyBase}\n *\n * @param {Property.definition=} [definition] Every constructor inherited from `Property` is required to call the\n * super constructor function. This implies that construction parameters of every inherited member is propagated\n * to be sent up to this point.\n *\n * @see Property.definition\n */\nProperty = function PostmanProperty(definition) {\n  // this constructor is intended to inherit and as such the super constructor is required to be executed\n  Property.super_.apply(this, arguments);\n\n  // The definition can have an `info` object that stores the identification of this property. If that is present,\n  // we use it instead of the definition root.\n  var src = definition && definition.info || definition,\n    id;\n\n  // first we extract id from all possible sources\n  // we also check if this property is marked to require an ID, we generate one if not found.\n  id = src && src.id || this.id || this._ && this._.postman_id || this._postman_propertyRequiresId && uuid.v4();\n\n  /**\n   * The `id` of the property is a unique string that identifies this property and can be used to refer to\n   * this property from relevant other places. It is a good practice to define the id or let the system\n   * auto generate a UUID if one is not defined for properties that require an `id`.\n   *\n   * @name id\n   * @type {String}\n   * @memberOf Property.prototype\n   *\n   * @note The property can also be present in the `postman_id` meta in case it is not specified in the\n   * object. An auto-generated property is used wherever one is not specified\n   */\n  id && (this.id = id);\n\n  /**\n   * A property can have a distinctive and human-readable name. This is to be used to display the name of the\n   * property within Postman, Newman or other runtimes that consume collection. In certain cases, the absence\n   * of name might cause the runtime to use the `id` as a fallback.\n   *\n   * @name name\n   * @memberOf Property.prototype\n   * @type {String}\n   */\n  src && src.name && (this.name = src.name);\n\n  /**\n   * This (optional) flag denotes whether this property is disabled or not. Usually, this is helpful when a\n   * property is part of a {@link PropertyList}. For example, in a PropertyList of {@link Header}s, the ones\n   * that are disabled can be filtered out and not processed.\n   *\n   * @type {Boolean}\n   * @optional\n   * @name disabled\n   *\n   * @memberOf Property.prototype\n   */\n  definition && _.has(definition, DISABLED) && (this.disabled = Boolean(definition.disabled));\n\n  /**\n   * The `description` property holds the detailed documentation of any property.\n   * It is recommended that this property be updated using the [describe](#describe) function.\n   *\n   * @type {Description}\n   * @see Property#describe\n   *\n   * @example <caption>Accessing descriptions of all root items in a collection</caption>\n   * var fs = require('fs'), // needed to read JSON file from disk\n   *     Collection = require('postman-collection').Collection,\n   *     myCollection;\n   *\n   * // Load a collection to memory from a JSON file on disk (say, sample-collection.json)\n   * myCollection = new Collection(JSON.stringify(fs.readFileSync('sample-collection.json').toString()));\n   *\n   * // Log the description of all root items\n   * myCollection.item.all().forEach(function (item) {\n   *     console.log(item.name || 'Untitled Item');\n   *     item.description && console.log(item.description.toString());\n   * });\n   */\n  // eslint-disable-next-line max-len\n  _.has(src, DESCRIPTION) && (this.description = _.createDefined(src, DESCRIPTION, Description, this.description));\n}, PropertyBase);\n_.assign(Property.prototype, /** @lends Property.prototype */{\n  /**\n   * This function allows to describe the property for the purpose of detailed identification or documentation\n   * generation. This function sets or updates the `description` child-property of this property.\n   *\n   * @param {String} content The content of the description can be provided here as a string. Note that it is expected\n   * that if the content is formatted in any other way than simple text, it should be specified in the subsequent\n   * `type` parameter.\n   * @param {String=} [type=\"text/plain\"] The type of the content.\n   *\n   * @example <caption>Add a description to an instance of Collection</caption>\n   *  var Collection = require('postman-collection').Collection,\n   *     mycollection;\n   *\n   * // create a blank collection\n   * myCollection = new Collection();\n   * myCollection.describe('Hey! This is a cool collection.');\n   *\n   * console.log(myCollection.description.toString()); // read the description\n   */\n  describe(content, type) {\n    (Description.isDescription(this.description) ? this.description : this.description = new Description()).update(content, type);\n  },\n  /**\n   * Returns an object representation of the Property with its variable references substituted.\n   *\n   * @example <caption>Resolve an object using variable definitions from itself and its parents</caption>\n   * property.toObjectResolved();\n   *\n   * @example <caption>Resolve an object using variable definitions on a different object</caption>\n   * property.toObjectResolved(item);\n   *\n   * @example <caption>Resolve an object using variables definitions as a flat list of variables</caption>\n   * property.toObjectResolved(null, [variablesDefinition1, variablesDefinition1], {ignoreOwnVariables: true});\n   *\n   * @private\n   * @draft\n   * @param {?Item|ItemGroup=} [scope] - One can specifically provide an item or group with `.variables`. In\n   * the event one is not provided, the variables are taken from this object or one from the parent tree.\n   * @param {Array<Object>} overrides - additional objects to lookup for variable values\n   * @param {Object} [options] -\n   * @param {Boolean} [options.ignoreOwnVariables] - if set to true, `.variables` on self(or scope)\n   * will not be used for variable resolution. Only variables in `overrides` will be used for resolution.\n   * @returns {Object|undefined}\n   * @throws {Error} If `variables` cannot be resolved up the parent chain.\n   */\n  toObjectResolved(scope, overrides, options) {\n    var ignoreOwnVariables = options && options.ignoreOwnVariables,\n      variableSourceObj,\n      variables,\n      reference;\n\n    // ensure you do not substitute variables itself!\n    reference = this.toJSON();\n    _.isArray(reference.variable) && delete reference.variable;\n\n    // if `ignoreScopeVariables` is turned on, ignore `.variables` and resolve with only `overrides`\n    // otherwise find `.variables` on current object or `scope`\n    if (ignoreOwnVariables) {\n      return Property.replaceSubstitutionsIn(reference, overrides);\n    }\n\n    // 1. if variables is passed as params, use it or fall back to oneself\n    // 2. for a source from point (1), and look for `.variables`\n    // 3. if `.variables` is not found, then rise up the parent to find first .variables\n    variableSourceObj = scope || this;\n    do {\n      variables = variableSourceObj.variables;\n      variableSourceObj = variableSourceObj.__parent;\n    } while (!variables && variableSourceObj);\n    if (!variables) {\n      // worst case = no variable param and none detected in tree or object\n      throw Error('Unable to resolve variables. Require a List type property for variable auto resolution.');\n    }\n    return variables.substitute(reference, overrides);\n  },\n  /**\n   * Returns all the substitutions (variables) that are needed (or referenced) in this property (recursively).\n   *\n   * @returns {String[]}\n   *\n   * @example\n   * // returns ['host', 'path1']\n   * prop.findSubstitutions({request: 'https://{{host}}/{{path1}}-action/'});\n   *\n   * @see {Property.findSubstitutions}\n   */\n  findSubstitutions() {\n    return Property.findSubstitutions(this.toJSON());\n  }\n});\n_.assign(Property, /** @lends Property */{\n  /**\n   * Defines the name of this property for internal use.\n   *\n   * @private\n   * @readOnly\n   * @type {String}\n   */\n  _postman_propertyName: 'Property',\n  /**\n   * This function accepts a string followed by a number of variable sources as arguments. One or more variable\n   * sources can be provided and it will use the one that has the value in left-to-right order.\n   *\n   * @param {String} str -\n   * @param {VariableList|Object|Array.<VariableList|Object>} variables -\n   * @returns {String}\n   */\n  // @todo: improve algorithm via variable replacement caching\n  replaceSubstitutions: function (str, variables) {\n    // if there is nothing to replace, we move on\n    if (!(str && _.isString(str))) {\n      return str;\n    }\n\n    // if variables object is not an instance of substitutor then ensure that it is an array so that it becomes\n    // compatible with the constructor arguments for a substitutor\n    !Substitutor.isInstance(variables) && !_.isArray(variables) && (variables = _.tail(arguments));\n    return Substitutor.box(variables, Substitutor.DEFAULT_VARS).parse(str).toString();\n  },\n  /**\n   * This function accepts an object followed by a number of variable sources as arguments. One or more variable\n   * sources can be provided and it will use the one that has the value in left-to-right order.\n   *\n   * @param {Object} obj -\n   * @param {Array.<VariableList|Object>} variables -\n   * @returns {Object}\n   */\n  replaceSubstitutionsIn: function (obj, variables) {\n    // if there is nothing to replace, we move on\n    if (!(obj && _.isObject(obj))) {\n      return obj;\n    }\n\n    // convert the variables to a substitutor object (will not reconvert if already substitutor)\n    variables = Substitutor.box(variables, Substitutor.DEFAULT_VARS);\n    var customizer = function (objectValue, sourceValue) {\n      objectValue = objectValue || {};\n      if (!_.isString(sourceValue)) {\n        _.forOwn(sourceValue, function (value, key) {\n          sourceValue[key] = customizer(objectValue[key], value);\n        });\n        return sourceValue;\n      }\n      return this.replaceSubstitutions(sourceValue, variables);\n    }.bind(this);\n    return _.mergeWith({}, obj, customizer);\n  },\n  /**\n   * This function recursively traverses a variable and detects all instances of variable replacements\n   * within the string of the object\n   *\n   * @param {*} obj Any JS variable within which we are trying to discover {{variables}}\n   * @returns {String[]}\n   *\n   * @example\n   * // returns ['host', 'path1']\n   * Property.findSubstitutions({request: 'https://{{host}}/{{path1}}-action/'});\n   *\n   * @todo\n   * - tonne of scope for performance optimizations\n   * - accept a reference variable scope so that substitutions can be applied to find recursive\n   *   replacements (e.g. {{hello-{{hi}}-var}})\n   */\n  findSubstitutions: function (obj) {\n    return Array.from(_findSubstitutions(obj));\n  }\n});\nmodule.exports = {\n  Property\n};","map":{"version":3,"names":["_","require","lodash","uuid","PropertyBase","Description","Substitutor","DISABLED","DESCRIPTION","REGEX_EXTRACT_VARS","Property","_findSubstitutions","value","seen","Set","result","has","Array","isArray","add","i","ii","length","key","Object","hasOwnProperty","call","match","exec","slice","inherit","PostmanProperty","definition","super_","apply","arguments","src","info","id","postman_id","_postman_propertyRequiresId","v4","name","disabled","Boolean","description","createDefined","assign","prototype","describe","content","type","isDescription","update","toObjectResolved","scope","overrides","options","ignoreOwnVariables","variableSourceObj","variables","reference","toJSON","variable","replaceSubstitutionsIn","__parent","Error","substitute","findSubstitutions","_postman_propertyName","replaceSubstitutions","str","isString","isInstance","tail","box","DEFAULT_VARS","parse","toString","obj","isObject","customizer","objectValue","sourceValue","forOwn","bind","mergeWith","from","module","exports"],"sources":["/Users/Qusai.Qishta/node_modules/postman-collection/lib/collection/property.js"],"sourcesContent":["var _ = require('../util').lodash,\n    uuid = require('uuid'),\n    PropertyBase = require('./property-base').PropertyBase,\n    Description = require('./description').Description,\n    Substitutor = require('../superstring').Substitutor,\n\n    DISABLED = 'disabled',\n    DESCRIPTION = 'description',\n    REGEX_EXTRACT_VARS = Substitutor.REGEX_EXTRACT_VARS,\n\n    Property; // constructor\n\n/**\n * Recursively traverses a variable and detects all instances of variable\n * replacements within the string of the object.\n *\n * @private\n * @param {*} value Any JS variable within which we are trying to discover {{variables}}\n * @param {[Object]} seen Set of objects traversed before to avoid infinite recursion\n * @param {[Object]} result Set of variables to accumulate result in the recursive call\n * @returns {Object} Set of variables\n */\nfunction _findSubstitutions (value, seen = new Set(), result = new Set()) {\n    if (!value || seen.has(value)) {\n        return result;\n    }\n\n    if (Array.isArray(value)) {\n        seen.add(value);\n\n        for (let i = 0, ii = value.length; i < ii; i++) {\n            _findSubstitutions(value[i], seen, result);\n        }\n    }\n    else if (typeof value === 'object') {\n        seen.add(value);\n\n        for (const key in value) {\n            if (Object.hasOwnProperty.call(value, key)) {\n                _findSubstitutions(value[key], seen, result);\n            }\n        }\n    }\n    else if (typeof value === 'string') {\n        let match;\n\n        while ((match = REGEX_EXTRACT_VARS.exec(value)) !== null) {\n            result.add(match[0].slice(2, -2));\n        }\n    }\n\n    return result;\n}\n\n/**\n * @typedef Property.definition\n * @property {String=} [id] A unique string that identifies the property.\n * @property {String=} [name] A distinctive and human-readable name of the property.\n * @property {Boolean=} [disabled] Denotes whether the property is disabled or not.\n * @property {Object=} [info] The meta information regarding the Property is provided as the `info` object.\n * @property {String=} [info.id] If set, this is used instead of the definition root's id.\n * @property {String=} [info.name] If set, this is used instead of the definition root's name.\n */\n_.inherit((\n\n    /**\n     * The Property class forms the base of all postman collection SDK elements. This is to be used only for SDK\n     * development or to extend the SDK with additional functionalities. All SDK classes (constructors) that are\n     * supposed to be identifyable (i.e. ones that can have a `name` and `id`) are derived from this class.\n     *\n     * For more information on what is the structure of the `definition` the function parameter, have a look at\n     * {@link Property.definition}.\n     *\n     * > This is intended to be a private class except for those who want to extend the SDK itself and add more\n     * > functionalities.\n     *\n     * @constructor\n     * @extends {PropertyBase}\n     *\n     * @param {Property.definition=} [definition] Every constructor inherited from `Property` is required to call the\n     * super constructor function. This implies that construction parameters of every inherited member is propagated\n     * to be sent up to this point.\n     *\n     * @see Property.definition\n     */\n    Property = function PostmanProperty (definition) {\n        // this constructor is intended to inherit and as such the super constructor is required to be executed\n        Property.super_.apply(this, arguments);\n\n        // The definition can have an `info` object that stores the identification of this property. If that is present,\n        // we use it instead of the definition root.\n        var src = definition && definition.info || definition,\n            id;\n\n        // first we extract id from all possible sources\n        // we also check if this property is marked to require an ID, we generate one if not found.\n        id = (src && src.id) || this.id || (this._ && this._.postman_id) || (this._postman_propertyRequiresId &&\n            uuid.v4());\n\n        /**\n         * The `id` of the property is a unique string that identifies this property and can be used to refer to\n         * this property from relevant other places. It is a good practice to define the id or let the system\n         * auto generate a UUID if one is not defined for properties that require an `id`.\n         *\n         * @name id\n         * @type {String}\n         * @memberOf Property.prototype\n         *\n         * @note The property can also be present in the `postman_id` meta in case it is not specified in the\n         * object. An auto-generated property is used wherever one is not specified\n         */\n        id && (this.id = id);\n\n        /**\n         * A property can have a distinctive and human-readable name. This is to be used to display the name of the\n         * property within Postman, Newman or other runtimes that consume collection. In certain cases, the absence\n         * of name might cause the runtime to use the `id` as a fallback.\n         *\n         * @name name\n         * @memberOf Property.prototype\n         * @type {String}\n         */\n        src && src.name && (this.name = src.name);\n\n        /**\n         * This (optional) flag denotes whether this property is disabled or not. Usually, this is helpful when a\n         * property is part of a {@link PropertyList}. For example, in a PropertyList of {@link Header}s, the ones\n         * that are disabled can be filtered out and not processed.\n         *\n         * @type {Boolean}\n         * @optional\n         * @name disabled\n         *\n         * @memberOf Property.prototype\n         */\n        definition && _.has(definition, DISABLED) && (this.disabled = Boolean(definition.disabled));\n\n        /**\n         * The `description` property holds the detailed documentation of any property.\n         * It is recommended that this property be updated using the [describe](#describe) function.\n         *\n         * @type {Description}\n         * @see Property#describe\n         *\n         * @example <caption>Accessing descriptions of all root items in a collection</caption>\n         * var fs = require('fs'), // needed to read JSON file from disk\n         *     Collection = require('postman-collection').Collection,\n         *     myCollection;\n         *\n         * // Load a collection to memory from a JSON file on disk (say, sample-collection.json)\n         * myCollection = new Collection(JSON.stringify(fs.readFileSync('sample-collection.json').toString()));\n         *\n         * // Log the description of all root items\n         * myCollection.item.all().forEach(function (item) {\n         *     console.log(item.name || 'Untitled Item');\n         *     item.description && console.log(item.description.toString());\n         * });\n         */\n        // eslint-disable-next-line max-len\n        _.has(src, DESCRIPTION) && (this.description = _.createDefined(src, DESCRIPTION, Description, this.description));\n    }), PropertyBase);\n\n_.assign(Property.prototype, /** @lends Property.prototype */ {\n    /**\n     * This function allows to describe the property for the purpose of detailed identification or documentation\n     * generation. This function sets or updates the `description` child-property of this property.\n     *\n     * @param {String} content The content of the description can be provided here as a string. Note that it is expected\n     * that if the content is formatted in any other way than simple text, it should be specified in the subsequent\n     * `type` parameter.\n     * @param {String=} [type=\"text/plain\"] The type of the content.\n     *\n     * @example <caption>Add a description to an instance of Collection</caption>\n     *  var Collection = require('postman-collection').Collection,\n     *     mycollection;\n     *\n     * // create a blank collection\n     * myCollection = new Collection();\n     * myCollection.describe('Hey! This is a cool collection.');\n     *\n     * console.log(myCollection.description.toString()); // read the description\n     */\n    describe (content, type) {\n        (Description.isDescription(this.description) ? this.description : (this.description = new Description()))\n            .update(content, type);\n    },\n\n    /**\n     * Returns an object representation of the Property with its variable references substituted.\n     *\n     * @example <caption>Resolve an object using variable definitions from itself and its parents</caption>\n     * property.toObjectResolved();\n     *\n     * @example <caption>Resolve an object using variable definitions on a different object</caption>\n     * property.toObjectResolved(item);\n     *\n     * @example <caption>Resolve an object using variables definitions as a flat list of variables</caption>\n     * property.toObjectResolved(null, [variablesDefinition1, variablesDefinition1], {ignoreOwnVariables: true});\n     *\n     * @private\n     * @draft\n     * @param {?Item|ItemGroup=} [scope] - One can specifically provide an item or group with `.variables`. In\n     * the event one is not provided, the variables are taken from this object or one from the parent tree.\n     * @param {Array<Object>} overrides - additional objects to lookup for variable values\n     * @param {Object} [options] -\n     * @param {Boolean} [options.ignoreOwnVariables] - if set to true, `.variables` on self(or scope)\n     * will not be used for variable resolution. Only variables in `overrides` will be used for resolution.\n     * @returns {Object|undefined}\n     * @throws {Error} If `variables` cannot be resolved up the parent chain.\n     */\n    toObjectResolved (scope, overrides, options) {\n        var ignoreOwnVariables = options && options.ignoreOwnVariables,\n            variableSourceObj,\n            variables,\n            reference;\n\n        // ensure you do not substitute variables itself!\n        reference = this.toJSON();\n        _.isArray(reference.variable) && (delete reference.variable);\n\n        // if `ignoreScopeVariables` is turned on, ignore `.variables` and resolve with only `overrides`\n        // otherwise find `.variables` on current object or `scope`\n        if (ignoreOwnVariables) {\n            return Property.replaceSubstitutionsIn(reference, overrides);\n        }\n\n        // 1. if variables is passed as params, use it or fall back to oneself\n        // 2. for a source from point (1), and look for `.variables`\n        // 3. if `.variables` is not found, then rise up the parent to find first .variables\n        variableSourceObj = scope || this;\n        do {\n            variables = variableSourceObj.variables;\n            variableSourceObj = variableSourceObj.__parent;\n        } while (!variables && variableSourceObj);\n\n        if (!variables) { // worst case = no variable param and none detected in tree or object\n            throw Error('Unable to resolve variables. Require a List type property for variable auto resolution.');\n        }\n\n        return variables.substitute(reference, overrides);\n    },\n\n    /**\n     * Returns all the substitutions (variables) that are needed (or referenced) in this property (recursively).\n     *\n     * @returns {String[]}\n     *\n     * @example\n     * // returns ['host', 'path1']\n     * prop.findSubstitutions({request: 'https://{{host}}/{{path1}}-action/'});\n     *\n     * @see {Property.findSubstitutions}\n     */\n    findSubstitutions () {\n        return Property.findSubstitutions(this.toJSON());\n    }\n});\n\n_.assign(Property, /** @lends Property */ {\n    /**\n     * Defines the name of this property for internal use.\n     *\n     * @private\n     * @readOnly\n     * @type {String}\n     */\n    _postman_propertyName: 'Property',\n\n    /**\n     * This function accepts a string followed by a number of variable sources as arguments. One or more variable\n     * sources can be provided and it will use the one that has the value in left-to-right order.\n     *\n     * @param {String} str -\n     * @param {VariableList|Object|Array.<VariableList|Object>} variables -\n     * @returns {String}\n     */\n    // @todo: improve algorithm via variable replacement caching\n    replaceSubstitutions: function (str, variables) {\n        // if there is nothing to replace, we move on\n        if (!(str && _.isString(str))) { return str; }\n\n        // if variables object is not an instance of substitutor then ensure that it is an array so that it becomes\n        // compatible with the constructor arguments for a substitutor\n        !Substitutor.isInstance(variables) && !_.isArray(variables) && (variables = _.tail(arguments));\n\n        return Substitutor.box(variables, Substitutor.DEFAULT_VARS).parse(str).toString();\n    },\n\n    /**\n     * This function accepts an object followed by a number of variable sources as arguments. One or more variable\n     * sources can be provided and it will use the one that has the value in left-to-right order.\n     *\n     * @param {Object} obj -\n     * @param {Array.<VariableList|Object>} variables -\n     * @returns {Object}\n     */\n    replaceSubstitutionsIn: function (obj, variables) {\n        // if there is nothing to replace, we move on\n        if (!(obj && _.isObject(obj))) {\n            return obj;\n        }\n\n        // convert the variables to a substitutor object (will not reconvert if already substitutor)\n        variables = Substitutor.box(variables, Substitutor.DEFAULT_VARS);\n\n        var customizer = function (objectValue, sourceValue) {\n            objectValue = objectValue || {};\n            if (!_.isString(sourceValue)) {\n                _.forOwn(sourceValue, function (value, key) {\n                    sourceValue[key] = customizer(objectValue[key], value);\n                });\n\n                return sourceValue;\n            }\n\n            return this.replaceSubstitutions(sourceValue, variables);\n        }.bind(this);\n\n        return _.mergeWith({}, obj, customizer);\n    },\n\n    /**\n     * This function recursively traverses a variable and detects all instances of variable replacements\n     * within the string of the object\n     *\n     * @param {*} obj Any JS variable within which we are trying to discover {{variables}}\n     * @returns {String[]}\n     *\n     * @example\n     * // returns ['host', 'path1']\n     * Property.findSubstitutions({request: 'https://{{host}}/{{path1}}-action/'});\n     *\n     * @todo\n     * - tonne of scope for performance optimizations\n     * - accept a reference variable scope so that substitutions can be applied to find recursive\n     *   replacements (e.g. {{hello-{{hi}}-var}})\n     */\n    findSubstitutions: function (obj) {\n        return Array.from(_findSubstitutions(obj));\n    }\n});\n\nmodule.exports = {\n    Property\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}