{"ast":null,"code":"var url = require('url'),\n  /**\n   * @private\n   * @const\n   * @type {String}\n   */\n  E = '',\n  /**\n   * @private\n   * @const\n   * @type {String}\n   */\n  QUERY_SEPARATOR = '?',\n  /**\n   * @private\n   * @const\n   * @type {String}\n   */\n  AMPERSAND = '&',\n  /**\n   * @private\n   * @const\n   * @type {String}\n   */\n  EQUALS = '=',\n  /**\n   * @private\n   * @const\n   * @type {String}\n   */\n  PERCENT = '%',\n  /**\n   * @private\n   * @const\n   * @type {string}\n   */\n  ZERO = '0',\n  /**\n   * @private\n   * @const\n   * @type {string}\n   */\n  STRING = 'string',\n  encoder;\nencoder = {\n  /**\n   * Percent encode a character with given code.\n   *\n   * @param {Number} c - character code of the character to encode\n   * @returns {String} - percent encoding of given character\n   */\n  percentEncode(c) {\n    var hex = c.toString(16).toUpperCase();\n    hex.length === 1 && (hex = ZERO + hex);\n    return PERCENT + hex;\n  },\n  /**\n   * Checks if character at given index in the buffer is already percent encoded or not.\n   *\n   * @param {Buffer} buffer -\n   * @param {Number} i -\n   * @returns {Boolean}\n   */\n  isPreEncoded(buffer, i) {\n    // If it is % check next two bytes for percent encode characters\n    // looking for pattern %00 - %FF\n    return buffer[i] === 0x25 && encoder.isPreEncodedCharacter(buffer[i + 1]) && encoder.isPreEncodedCharacter(buffer[i + 2]);\n  },\n  /**\n   * Checks if character with given code is valid hexadecimal digit or not.\n   *\n   * @param {Number} byte -\n   * @returns {Boolean}\n   */\n  isPreEncodedCharacter(byte) {\n    return byte >= 0x30 && byte <= 0x39 ||\n    // 0-9\n    byte >= 0x41 && byte <= 0x46 ||\n    // A-F\n    byte >= 0x61 && byte <= 0x66; // a-f\n  },\n\n  /**\n   * Checks whether given character should be percent encoded or not for fixture.\n   *\n   * @param {Number} byte -\n   * @returns {Boolean}\n   */\n  charactersToPercentEncode(byte) {\n    return byte < 0x23 || byte > 0x7E ||\n    // Below # and after ~\n    byte === 0x3C || byte === 0x3E ||\n    // > and <\n    byte === 0x28 || byte === 0x29 ||\n    // ( and )\n    byte === 0x25 ||\n    // %\n    byte === 0x27 ||\n    // '\n    byte === 0x2A // *\n    ;\n  },\n\n  /**\n   * Percent encode a query string according to RFC 3986.\n   * Note: This function is supposed to be used on top of node's inbuilt url encoding\n   *       to solve issue https://github.com/nodejs/node/issues/8321\n   *\n   * @param {String} value -\n   * @returns {String}\n   */\n  encode(value) {\n    if (!value) {\n      return E;\n    }\n    var buffer = Buffer.from(value),\n      ret = E,\n      i,\n      ii;\n    for (i = 0, ii = buffer.length; i < ii; ++i) {\n      if (encoder.charactersToPercentEncode(buffer[i]) && !encoder.isPreEncoded(buffer, i)) {\n        ret += encoder.percentEncode(buffer[i]);\n      } else {\n        ret += String.fromCodePoint(buffer[i]); // Only works in ES6 (available in Node v4+)\n      }\n    }\n\n    return ret;\n  }\n};\n\n/**\n * Parses a query string into an array, preserving parameter values\n *\n * @private\n * @param {String} string -\n * @returns {*}\n */\nfunction parseQueryString(string) {\n  var parts;\n  if (typeof string === STRING) {\n    parts = string.split(AMPERSAND);\n    return parts.map(function (param, idx) {\n      if (param === E && idx !== parts.length - 1) {\n        return {\n          key: null,\n          value: null\n        };\n      }\n      var index = typeof param === STRING ? param.indexOf(EQUALS) : -1,\n        paramObj = {};\n\n      // this means that there was no value for this key (not even blank,\n      // so we store this info) and the value is set to null\n      if (index < 0) {\n        paramObj.key = param.substr(0, param.length);\n        paramObj.value = null;\n      } else {\n        paramObj.key = param.substr(0, index);\n        paramObj.value = param.substr(index + 1);\n      }\n      return paramObj;\n    });\n  }\n  return [];\n}\n\n/**\n * Stringifies a query string, from an array of parameters\n *\n * @private\n * @param {Object[]} parameters -\n * @returns {string}\n */\nfunction stringifyQueryParams(parameters) {\n  return parameters ? parameters.map(function (param) {\n    var key = param.key,\n      value = param.value;\n    if (value === undefined) {\n      return E;\n    }\n    if (key === null) {\n      key = E;\n    }\n    if (value === null) {\n      return encoder.encode(key);\n    }\n    return encoder.encode(key) + EQUALS + encoder.encode(value);\n  }).join(AMPERSAND) : E;\n}\n\n/**\n * Converts URL string into Node's Url object with encoded values\n *\n * @private\n * @param {String} urlString -\n * @returns {Url}\n */\nfunction toNodeUrl(urlString) {\n  var parsed = url.parse(urlString),\n    rawQs = parsed.query,\n    qs,\n    search,\n    path,\n    str;\n  if (!(rawQs && rawQs.length)) {\n    return parsed;\n  }\n  qs = stringifyQueryParams(parseQueryString(rawQs));\n  search = QUERY_SEPARATOR + qs;\n  path = parsed.pathname + search;\n  parsed.query = qs;\n  parsed.search = search;\n  parsed.path = path;\n  str = url.format(parsed);\n\n  // Parse again, because Node does not guarantee consistency of properties\n  return url.parse(str);\n}\nmodule.exports = {\n  toNodeUrl\n};","map":{"version":3,"names":["url","require","E","QUERY_SEPARATOR","AMPERSAND","EQUALS","PERCENT","ZERO","STRING","encoder","percentEncode","c","hex","toString","toUpperCase","length","isPreEncoded","buffer","i","isPreEncodedCharacter","byte","charactersToPercentEncode","encode","value","Buffer","from","ret","ii","String","fromCodePoint","parseQueryString","string","parts","split","map","param","idx","key","index","indexOf","paramObj","substr","stringifyQueryParams","parameters","undefined","join","toNodeUrl","urlString","parsed","parse","rawQs","query","qs","search","path","str","pathname","format","module","exports"],"sources":["/Users/Qusai.Qishta/node_modules/postman-url-encoder/legacy.js"],"sourcesContent":["var url = require('url'),\n\n    /**\n     * @private\n     * @const\n     * @type {String}\n     */\n    E = '',\n\n    /**\n     * @private\n     * @const\n     * @type {String}\n     */\n    QUERY_SEPARATOR = '?',\n\n    /**\n     * @private\n     * @const\n     * @type {String}\n     */\n    AMPERSAND = '&',\n\n    /**\n     * @private\n     * @const\n     * @type {String}\n     */\n    EQUALS = '=',\n\n    /**\n     * @private\n     * @const\n     * @type {String}\n     */\n    PERCENT = '%',\n\n    /**\n     * @private\n     * @const\n     * @type {string}\n     */\n    ZERO = '0',\n\n    /**\n     * @private\n     * @const\n     * @type {string}\n     */\n    STRING = 'string',\n\n    encoder;\n\nencoder = {\n    /**\n     * Percent encode a character with given code.\n     *\n     * @param {Number} c - character code of the character to encode\n     * @returns {String} - percent encoding of given character\n     */\n    percentEncode (c) {\n        var hex = c.toString(16).toUpperCase();\n\n        (hex.length === 1) && (hex = ZERO + hex);\n\n        return PERCENT + hex;\n    },\n\n    /**\n     * Checks if character at given index in the buffer is already percent encoded or not.\n     *\n     * @param {Buffer} buffer -\n     * @param {Number} i -\n     * @returns {Boolean}\n     */\n    isPreEncoded (buffer, i) {\n        // If it is % check next two bytes for percent encode characters\n        // looking for pattern %00 - %FF\n        return (buffer[i] === 0x25 &&\n            (encoder.isPreEncodedCharacter(buffer[i + 1]) &&\n            encoder.isPreEncodedCharacter(buffer[i + 2]))\n        );\n    },\n\n    /**\n     * Checks if character with given code is valid hexadecimal digit or not.\n     *\n     * @param {Number} byte -\n     * @returns {Boolean}\n     */\n    isPreEncodedCharacter (byte) {\n        return (byte >= 0x30 && byte <= 0x39) || // 0-9\n            (byte >= 0x41 && byte <= 0x46) || // A-F\n            (byte >= 0x61 && byte <= 0x66); // a-f\n    },\n\n    /**\n     * Checks whether given character should be percent encoded or not for fixture.\n     *\n     * @param {Number} byte -\n     * @returns {Boolean}\n     */\n    charactersToPercentEncode (byte) {\n        return (byte < 0x23 || byte > 0x7E || // Below # and after ~\n            byte === 0x3C || byte === 0x3E || // > and <\n            byte === 0x28 || byte === 0x29 || // ( and )\n            byte === 0x25 || // %\n            byte === 0x27 || // '\n            byte === 0x2A // *\n        );\n    },\n\n    /**\n     * Percent encode a query string according to RFC 3986.\n     * Note: This function is supposed to be used on top of node's inbuilt url encoding\n     *       to solve issue https://github.com/nodejs/node/issues/8321\n     *\n     * @param {String} value -\n     * @returns {String}\n     */\n    encode (value) {\n        if (!value) { return E; }\n\n        var buffer = Buffer.from(value),\n            ret = E,\n            i,\n            ii;\n\n        for (i = 0, ii = buffer.length; i < ii; ++i) {\n            if (encoder.charactersToPercentEncode(buffer[i]) && !encoder.isPreEncoded(buffer, i)) {\n                ret += encoder.percentEncode(buffer[i]);\n            }\n            else {\n                ret += String.fromCodePoint(buffer[i]); // Only works in ES6 (available in Node v4+)\n            }\n        }\n\n        return ret;\n    }\n};\n\n/**\n * Parses a query string into an array, preserving parameter values\n *\n * @private\n * @param {String} string -\n * @returns {*}\n */\nfunction parseQueryString (string) {\n    var parts;\n\n    if (typeof string === STRING) {\n        parts = string.split(AMPERSAND);\n\n        return parts.map(function (param, idx) {\n            if (param === E && idx !== (parts.length - 1)) {\n                return { key: null, value: null };\n            }\n\n            var index = (typeof param === STRING) ? param.indexOf(EQUALS) : -1,\n                paramObj = {};\n\n            // this means that there was no value for this key (not even blank,\n            // so we store this info) and the value is set to null\n            if (index < 0) {\n                paramObj.key = param.substr(0, param.length);\n                paramObj.value = null;\n            }\n            else {\n                paramObj.key = param.substr(0, index);\n                paramObj.value = param.substr(index + 1);\n            }\n\n            return paramObj;\n        });\n    }\n\n    return [];\n}\n\n/**\n * Stringifies a query string, from an array of parameters\n *\n * @private\n * @param {Object[]} parameters -\n * @returns {string}\n */\nfunction stringifyQueryParams (parameters) {\n    return parameters ? parameters.map(function (param) {\n        var key = param.key,\n            value = param.value;\n\n        if (value === undefined) {\n            return E;\n        }\n\n        if (key === null) {\n            key = E;\n        }\n\n        if (value === null) {\n            return encoder.encode(key);\n        }\n\n        return encoder.encode(key) + EQUALS + encoder.encode(value);\n    }).join(AMPERSAND) : E;\n}\n\n/**\n * Converts URL string into Node's Url object with encoded values\n *\n * @private\n * @param {String} urlString -\n * @returns {Url}\n */\nfunction toNodeUrl (urlString) {\n    var parsed = url.parse(urlString),\n        rawQs = parsed.query,\n        qs,\n        search,\n        path,\n        str;\n\n    if (!(rawQs && rawQs.length)) { return parsed; }\n\n    qs = stringifyQueryParams(parseQueryString(rawQs));\n    search = QUERY_SEPARATOR + qs;\n    path = parsed.pathname + search;\n\n    parsed.query = qs;\n    parsed.search = search;\n    parsed.path = path;\n\n    str = url.format(parsed);\n\n    // Parse again, because Node does not guarantee consistency of properties\n    return url.parse(str);\n}\n\nmodule.exports = {\n    toNodeUrl\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}