{"ast":null,"code":"var _ = require('lodash'),\n  backpack = require('../backpack'),\n  Run = require('./run'),\n  extractRunnableItems = require('./extract-runnable-items').extractRunnableItems,\n  Runner,\n  defaultTimeouts = {\n    global: 3 * 60 * 1000,\n    // 3 minutes\n    request: Infinity,\n    script: Infinity\n  };\n\n/**\n * @typedef {runCallback}\n * @property {Function} [done]\n * @property {Function} [error]\n * @property {Function} [success]\n */\n\n/**\n * @constructor\n *\n * @param {Object} [options] -\n */\nRunner = function PostmanCollectionRunner(options) {\n  // eslint-disable-line func-name-matching\n  this.options = _.assign({}, options);\n};\n_.assign(Runner.prototype, {\n  /**\n   * Prepares `run` config by combining `runner` config with given run options.\n   *\n   * @param {Object} [options] -\n   * @param {Object} [options.timeout] -\n   * @param {Object} [options.timeout.global] -\n   * @param {Object} [options.timeout.request] -\n   * @param {Object} [options.timeout.script] -\n   */\n  prepareRunConfig(options) {\n    // combine runner config and make a copy\n    var runOptions = _.merge(_.omit(options, ['environment', 'globals', 'data']), this.options.run) || {};\n\n    // start timeout sanitization\n    !runOptions.timeout && (runOptions.timeout = {});\n    _.mergeWith(runOptions.timeout, defaultTimeouts, function (userTimeout, defaultTimeout) {\n      // non numbers, Infinity and missing values are set to default\n      if (!_.isFinite(userTimeout)) {\n        return defaultTimeout;\n      }\n\n      // 0 and negative numbers are set to Infinity, which only leaves positive numbers\n      return userTimeout > 0 ? userTimeout : Infinity;\n    });\n    return runOptions;\n  },\n  /**\n   * Runs a collection or a folder.\n   *\n   * @param {Collection} collection -\n   * @param {Object} [options] -\n   * @param {Array.<Item>} options.items -\n   * @param {Array.<Object>}  [options.data] -\n   * @param {Object} [options.globals] -\n   * @param {Object} [options.environment] -\n   * @param {Number} [options.iterationCount] -\n   * @param {CertificateList} [options.certificates] -\n   * @param {ProxyConfigList} [options.proxies] -\n   * @param {Object} [options.entrypoint] -\n   * @param {String} [options.entrypoint.execute] ID of the item-group to be run.\n   * Can be Name if `entrypoint.lookupStrategy` is `idOrName`\n   * @param {String} [options.entrypoint.lookupStrategy=idOrName] strategy to lookup the entrypoint [idOrName, path]\n   * @param {Array<String>} [options.entrypoint.path] path to lookup\n   * @param {Object} [options.run] Run-specific options, such as options related to the host\n   *\n   * @param {Function} callback -\n   */\n  run(collection, options, callback) {\n    var self = this,\n      runOptions = this.prepareRunConfig(options);\n    callback = backpack.normalise(callback);\n    !_.isObject(options) && (options = {});\n\n    // @todo make the extract runnables interface better defined and documented\n    // - give the ownership of error to each strategy lookup functions\n    // - think about moving these codes into an extension command prior to waterfall\n    // - the third argument in callback that returns control, is ambiguous and can be removed if error is controlled\n    //   by each lookup function.\n    // - the interface can be further broken down to have the \"flattenNode\" action be made common and not be\n    //   required to be coded in each lookup strategy\n    //\n    // serialise the items into a linear array based on the lookup strategy provided as input\n    extractRunnableItems(collection, options.entrypoint, function (err, runnableItems, entrypoint) {\n      if (err || !runnableItems) {\n        return callback(new Error('Error fetching run items'));\n      }\n\n      // Bail out only if: abortOnError is set and the returned entrypoint is invalid\n      if (options.abortOnError && !entrypoint) {\n        // eslint-disable-next-line max-len\n        return callback(new Error(`Unable to find a folder or request: ${_.get(options, 'entrypoint.execute')}`));\n      }\n\n      // ensure data is an array\n      !_.isArray(options.data) && (options.data = [{}]);\n\n      // get iterationCount from data if not set\n      if (!runOptions.iterationCount) {\n        runOptions.iterationCount = options.data.length;\n      }\n      return callback(null, new Run({\n        items: runnableItems,\n        data: options.data,\n        environment: options.environment,\n        globals: _.has(options, 'globals') ? options.globals : self.options.globals,\n        // @todo Move to item level to support Item and ItemGroup variables\n        collectionVariables: collection.variables,\n        certificates: options.certificates,\n        proxies: options.proxies\n      }, runOptions));\n    });\n  }\n});\n_.assign(Runner, {\n  /**\n   * Expose Run instance for testability\n   *\n   * @type {Run}\n   */\n  Run\n});\nmodule.exports = Runner;","map":{"version":3,"names":["_","require","backpack","Run","extractRunnableItems","Runner","defaultTimeouts","global","request","Infinity","script","PostmanCollectionRunner","options","assign","prototype","prepareRunConfig","runOptions","merge","omit","run","timeout","mergeWith","userTimeout","defaultTimeout","isFinite","collection","callback","self","normalise","isObject","entrypoint","err","runnableItems","Error","abortOnError","get","isArray","data","iterationCount","length","items","environment","globals","has","collectionVariables","variables","certificates","proxies","module","exports"],"sources":["/Users/Qusai.Qishta/node_modules/postman-runtime/lib/runner/index.js"],"sourcesContent":["var _ = require('lodash'),\n    backpack = require('../backpack'),\n    Run = require('./run'),\n    extractRunnableItems = require('./extract-runnable-items').extractRunnableItems,\n\n    Runner,\n\n    defaultTimeouts = {\n        global: 3 * 60 * 1000, // 3 minutes\n        request: Infinity,\n        script: Infinity\n    };\n\n/**\n * @typedef {runCallback}\n * @property {Function} [done]\n * @property {Function} [error]\n * @property {Function} [success]\n */\n\n/**\n * @constructor\n *\n * @param {Object} [options] -\n */\nRunner = function PostmanCollectionRunner (options) { // eslint-disable-line func-name-matching\n    this.options = _.assign({}, options);\n};\n\n_.assign(Runner.prototype, {\n    /**\n     * Prepares `run` config by combining `runner` config with given run options.\n     *\n     * @param {Object} [options] -\n     * @param {Object} [options.timeout] -\n     * @param {Object} [options.timeout.global] -\n     * @param {Object} [options.timeout.request] -\n     * @param {Object} [options.timeout.script] -\n     */\n    prepareRunConfig (options) {\n        // combine runner config and make a copy\n        var runOptions = _.merge(_.omit(options, ['environment', 'globals', 'data']), this.options.run) || {};\n\n        // start timeout sanitization\n        !runOptions.timeout && (runOptions.timeout = {});\n\n        _.mergeWith(runOptions.timeout, defaultTimeouts, function (userTimeout, defaultTimeout) {\n            // non numbers, Infinity and missing values are set to default\n            if (!_.isFinite(userTimeout)) { return defaultTimeout; }\n\n            // 0 and negative numbers are set to Infinity, which only leaves positive numbers\n            return userTimeout > 0 ? userTimeout : Infinity;\n        });\n\n        return runOptions;\n    },\n\n    /**\n     * Runs a collection or a folder.\n     *\n     * @param {Collection} collection -\n     * @param {Object} [options] -\n     * @param {Array.<Item>} options.items -\n     * @param {Array.<Object>}  [options.data] -\n     * @param {Object} [options.globals] -\n     * @param {Object} [options.environment] -\n     * @param {Number} [options.iterationCount] -\n     * @param {CertificateList} [options.certificates] -\n     * @param {ProxyConfigList} [options.proxies] -\n     * @param {Object} [options.entrypoint] -\n     * @param {String} [options.entrypoint.execute] ID of the item-group to be run.\n     * Can be Name if `entrypoint.lookupStrategy` is `idOrName`\n     * @param {String} [options.entrypoint.lookupStrategy=idOrName] strategy to lookup the entrypoint [idOrName, path]\n     * @param {Array<String>} [options.entrypoint.path] path to lookup\n     * @param {Object} [options.run] Run-specific options, such as options related to the host\n     *\n     * @param {Function} callback -\n     */\n    run (collection, options, callback) {\n        var self = this,\n            runOptions = this.prepareRunConfig(options);\n\n        callback = backpack.normalise(callback);\n        !_.isObject(options) && (options = {});\n\n        // @todo make the extract runnables interface better defined and documented\n        // - give the ownership of error to each strategy lookup functions\n        // - think about moving these codes into an extension command prior to waterfall\n        // - the third argument in callback that returns control, is ambiguous and can be removed if error is controlled\n        //   by each lookup function.\n        // - the interface can be further broken down to have the \"flattenNode\" action be made common and not be\n        //   required to be coded in each lookup strategy\n        //\n        // serialise the items into a linear array based on the lookup strategy provided as input\n        extractRunnableItems(collection, options.entrypoint, function (err, runnableItems, entrypoint) {\n            if (err || !runnableItems) { return callback(new Error('Error fetching run items')); }\n\n            // Bail out only if: abortOnError is set and the returned entrypoint is invalid\n            if (options.abortOnError && !entrypoint) {\n                // eslint-disable-next-line max-len\n                return callback(new Error(`Unable to find a folder or request: ${_.get(options, 'entrypoint.execute')}`));\n            }\n\n            // ensure data is an array\n            !_.isArray(options.data) && (options.data = [{}]);\n\n            // get iterationCount from data if not set\n            if (!runOptions.iterationCount) {\n                runOptions.iterationCount = options.data.length;\n            }\n\n            return callback(null, (new Run({\n                items: runnableItems,\n                data: options.data,\n                environment: options.environment,\n                globals: _.has(options, 'globals') ? options.globals : self.options.globals,\n                // @todo Move to item level to support Item and ItemGroup variables\n                collectionVariables: collection.variables,\n                certificates: options.certificates,\n                proxies: options.proxies\n            }, runOptions)));\n        });\n    }\n});\n\n_.assign(Runner, {\n    /**\n     * Expose Run instance for testability\n     *\n     * @type {Run}\n     */\n    Run\n});\n\nmodule.exports = Runner;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}