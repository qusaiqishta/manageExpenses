{"ast":null,"code":"/**\n * @fileOverview\n *\n * Implements the EdgeGrid authentication method.\n * Specification document: https://developer.akamai.com/legacy/introduction/Client_Auth.html\n * Sample impletentation by Akamai: https://github.com/akamai/AkamaiOPEN-edgegrid-node\n */\n\nvar _ = require('lodash'),\n  uuid = require('uuid'),\n  crypto = require('crypto'),\n  sdk = require('postman-collection'),\n  RequestBody = sdk.RequestBody,\n  urlEncoder = require('postman-url-encoder'),\n  bodyBuilder = require('../requester/core-body-builder'),\n  EMPTY = '',\n  COLON = ':',\n  UTC_OFFSET = '+0000',\n  ZERO = '0',\n  DATE_TIME_SEPARATOR = 'T',\n  TAB = '\\t',\n  SPACE = ' ',\n  SLASH = '/',\n  STRING = 'string',\n  SIGNING_ALGORITHM = 'EG1-HMAC-SHA256 ',\n  AUTHORIZATION = 'Authorization',\n  /**\n   * Returns current timestamp in the format described in EdgeGrid specification (yyyyMMddTHH:mm:ss+0000)\n   *\n   * @returns {String} UTC timestamp in format yyyyMMddTHH:mm:ss+0000\n   */\n  getTimestamp = function () {\n    var date = new Date();\n    return date.getUTCFullYear() + _.padStart(date.getUTCMonth() + 1, 2, ZERO) + _.padStart(date.getUTCDate(), 2, ZERO) + DATE_TIME_SEPARATOR + _.padStart(date.getUTCHours(), 2, ZERO) + COLON + _.padStart(date.getUTCMinutes(), 2, ZERO) + COLON + _.padStart(date.getUTCSeconds(), 2, ZERO) + UTC_OFFSET;\n  },\n  /**\n   * Creates a String containing a tab delimited set of headers.\n   *\n   * @param {String[]} headersToSign Headers to include in signature\n   * @param {Object} headers Request headers\n   * @returns {String} Canonicalized headers\n   */\n  canonicalizeHeaders = function (headersToSign, headers) {\n    var formattedHeaders = [],\n      headerValue;\n    headersToSign.forEach(function (headerName) {\n      if (typeof headerName !== STRING) {\n        return;\n      }\n\n      // trim the header name to remove extra spaces from user input\n      headerName = headerName.trim().toLowerCase();\n      headerValue = headers[headerName];\n\n      // should not include empty headers as per the specification\n      if (typeof headerValue !== STRING || headerValue === EMPTY) {\n        return;\n      }\n      formattedHeaders.push(`${headerName}:${headerValue.trim().replace(/\\s+/g, SPACE)}`);\n    });\n    return formattedHeaders.join(TAB);\n  },\n  /**\n   * Returns base64 encoding of the SHA-256 HMAC of given data signed with given key\n   *\n   * @param {String} data Data to sign\n   * @param {String} key Key to use while signing the data\n   * @returns {String} Base64 encoded signature\n   */\n  base64HmacSha256 = function (data, key) {\n    var encrypt = crypto.createHmac('sha256', key);\n    encrypt.update(data);\n    return encrypt.digest('base64');\n  },\n  /**\n   * Calculates body hash with given algorithm and digestEncoding.\n   *\n   * @param {RequestBody} body Request body\n   * @param {String} algorithm Hash algorithm to use\n   * @param {String} digestEncoding Encoding of the hash\n   * @param {Function} callback Callback function that will be called with body hash\n   */\n  computeBodyHash = function (body, algorithm, digestEncoding, callback) {\n    if (!(body && algorithm && digestEncoding) || body.isEmpty()) {\n      return callback();\n    }\n    var hash = crypto.createHash(algorithm),\n      originalReadStream,\n      rawBody,\n      urlencodedBody,\n      graphqlBody;\n    if (body.mode === RequestBody.MODES.raw) {\n      rawBody = bodyBuilder.raw(body.raw).body;\n      hash.update(rawBody);\n      return callback(hash.digest(digestEncoding));\n    }\n    if (body.mode === RequestBody.MODES.urlencoded) {\n      urlencodedBody = bodyBuilder.urlencoded(body.urlencoded).form;\n      urlencodedBody = urlEncoder.encodeQueryString(urlencodedBody);\n      hash.update(urlencodedBody);\n      return callback(hash.digest(digestEncoding));\n    }\n    if (body.mode === RequestBody.MODES.file) {\n      originalReadStream = _.get(body, 'file.content');\n      if (!originalReadStream) {\n        return callback();\n      }\n      return originalReadStream.cloneReadStream(function (err, clonedStream) {\n        if (err) {\n          return callback();\n        }\n        clonedStream.on('data', function (chunk) {\n          hash.update(chunk);\n        });\n        clonedStream.on('end', function () {\n          callback(hash.digest(digestEncoding));\n        });\n      });\n    }\n    if (body.mode === RequestBody.MODES.graphql) {\n      graphqlBody = bodyBuilder.graphql(body.graphql).body;\n      hash.update(graphqlBody);\n      return callback(hash.digest(digestEncoding));\n    }\n\n    // @todo: Figure out a way to calculate hash for form-data body type.\n\n    // ensure that callback is called if body.mode doesn't match with any of the above modes\n    return callback();\n  };\n\n/**\n * @implements {AuthHandlerInterface}\n */\nmodule.exports = {\n  /**\n   * @property {AuthHandlerInterface~AuthManifest}\n   */\n  manifest: {\n    info: {\n      name: 'edgegrid',\n      version: '1.0.0'\n    },\n    updates: [{\n      property: 'Authorization',\n      type: 'header'\n    }]\n  },\n  /**\n   * Initializes a item (fetches all required parameters, etc) before the actual authorization step.\n   *\n   * @param {AuthInterface} auth AuthInterface instance created with request auth\n   * @param {Response} response Response of intermediate request (it any)\n   * @param {AuthHandlerInterface~authInitHookCallback} done Callback function called with error as first argument\n   */\n  init: function (auth, response, done) {\n    done(null);\n  },\n  /**\n   * Checks the item, and fetches any parameters that are not already provided.\n   *\n   * @param {AuthInterface} auth AuthInterface instance created with request auth\n   * @param {AuthHandlerInterface~authPreHookCallback} done Callback function called with error, success and request\n   */\n  pre: function (auth, done) {\n    // only check required auth params here\n    done(null, Boolean(auth.get('accessToken') && auth.get('clientToken') && auth.get('clientSecret')));\n  },\n  /**\n   * Verifies whether the request was successful after being sent.\n   *\n   * @param {AuthInterface} auth AuthInterface instance created with request auth\n   * @param {Requester} response Response of the request\n   * @param {AuthHandlerInterface~authPostHookCallback} done Callback function called with error and success\n   */\n  post: function (auth, response, done) {\n    done(null, true);\n  },\n  /**\n   * Generates the signature, and returns the Authorization header.\n   *\n   * @param {Object} params Auth parameters to use in header calculation\n   * @param {String} params.accessToken Access token provided by service provider\n   * @param {String} params.clientToken Client token provided by service provider\n   * @param {String} params.clientSecret Client secret provided by service provider\n   * @param {String} params.nonce Nonce to include in authorization header\n   * @param {String} params.timestamp Timestamp as defined in protocol specification\n   * @param {String} [params.bodyHash] Base64-encoded SHA-256 hash of request body for POST request\n   * @param {Object[]} params.headers Request headers\n   * @param {String[]} params.headersToSign Ordered list of headers to include in signature\n   * @param {String} params.method Request method\n   * @param {Url} params.url Node's URL object\n   * @returns {String} Authorization header\n   */\n  computeHeader: function (params) {\n    var authHeader = SIGNING_ALGORITHM,\n      signingKey = base64HmacSha256(params.timestamp, params.clientSecret),\n      dataToSign;\n    authHeader += `client_token=${params.clientToken};`;\n    authHeader += `access_token=${params.accessToken};`;\n    authHeader += `timestamp=${params.timestamp};`;\n    authHeader += `nonce=${params.nonce};`;\n    dataToSign = [params.method,\n    // trim to convert 'http:' from Node's URL object to 'http'\n    _.trimEnd(params.url.protocol, COLON), params.baseURL || params.url.host, params.url.path || SLASH, canonicalizeHeaders(params.headersToSign, params.headers), params.bodyHash || EMPTY, authHeader].join(TAB);\n    return authHeader + 'signature=' + base64HmacSha256(dataToSign, signingKey);\n  },\n  /**\n   * Signs a request.\n   *\n   * @param {AuthInterface} auth AuthInterface instance created with request auth\n   * @param {Request} request Request to be sent\n   * @param {AuthHandlerInterface~authSignHookCallback} done Callback function\n   */\n  sign: function (auth, request, done) {\n    var params = auth.get(['accessToken', 'clientToken', 'clientSecret', 'baseURL', 'nonce', 'timestamp', 'headersToSign']),\n      url = urlEncoder.toNodeUrl(request.url),\n      self = this;\n    if (!(params.accessToken && params.clientToken && params.clientSecret)) {\n      return done(); // Nothing to do if required parameters are not present.\n    }\n\n    request.removeHeader(AUTHORIZATION, {\n      ignoreCase: true\n    });\n\n    // Extract host from provided baseURL.\n    params.baseURL = params.baseURL && urlEncoder.toNodeUrl(params.baseURL).host;\n    params.nonce = params.nonce || uuid.v4();\n    params.timestamp = params.timestamp || getTimestamp();\n    params.url = url;\n    params.method = request.method;\n\n    // ensure that headers are case-insensitive as specified in the documentation\n    params.headers = request.getHeaders({\n      enabled: true,\n      ignoreCase: true\n    });\n    if (typeof params.headersToSign === STRING) {\n      params.headersToSign = params.headersToSign.split(',');\n    } else if (!_.isArray(params.headersToSign)) {\n      params.headersToSign = [];\n    }\n\n    // only calculate body hash for POST requests according to specification\n    if (request.method === 'POST') {\n      return computeBodyHash(request.body, 'sha256', 'base64', function (bodyHash) {\n        params.bodyHash = bodyHash;\n        request.addHeader({\n          key: AUTHORIZATION,\n          value: self.computeHeader(params),\n          system: true\n        });\n        return done();\n      });\n    }\n    request.addHeader({\n      key: AUTHORIZATION,\n      value: self.computeHeader(params),\n      system: true\n    });\n    return done();\n  }\n};","map":{"version":3,"names":["_","require","uuid","crypto","sdk","RequestBody","urlEncoder","bodyBuilder","EMPTY","COLON","UTC_OFFSET","ZERO","DATE_TIME_SEPARATOR","TAB","SPACE","SLASH","STRING","SIGNING_ALGORITHM","AUTHORIZATION","getTimestamp","date","Date","getUTCFullYear","padStart","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","canonicalizeHeaders","headersToSign","headers","formattedHeaders","headerValue","forEach","headerName","trim","toLowerCase","push","replace","join","base64HmacSha256","data","key","encrypt","createHmac","update","digest","computeBodyHash","body","algorithm","digestEncoding","callback","isEmpty","hash","createHash","originalReadStream","rawBody","urlencodedBody","graphqlBody","mode","MODES","raw","urlencoded","form","encodeQueryString","file","get","cloneReadStream","err","clonedStream","on","chunk","graphql","module","exports","manifest","info","name","version","updates","property","type","init","auth","response","done","pre","Boolean","post","computeHeader","params","authHeader","signingKey","timestamp","clientSecret","dataToSign","clientToken","accessToken","nonce","method","trimEnd","url","protocol","baseURL","host","path","bodyHash","sign","request","toNodeUrl","self","removeHeader","ignoreCase","v4","getHeaders","enabled","split","isArray","addHeader","value","system"],"sources":["/Users/Qusai.Qishta/node_modules/postman-runtime/lib/authorizer/edgegrid.js"],"sourcesContent":["/**\n * @fileOverview\n *\n * Implements the EdgeGrid authentication method.\n * Specification document: https://developer.akamai.com/legacy/introduction/Client_Auth.html\n * Sample impletentation by Akamai: https://github.com/akamai/AkamaiOPEN-edgegrid-node\n */\n\nvar _ = require('lodash'),\n    uuid = require('uuid'),\n    crypto = require('crypto'),\n    sdk = require('postman-collection'),\n    RequestBody = sdk.RequestBody,\n    urlEncoder = require('postman-url-encoder'),\n    bodyBuilder = require('../requester/core-body-builder'),\n\n    EMPTY = '',\n    COLON = ':',\n    UTC_OFFSET = '+0000',\n    ZERO = '0',\n    DATE_TIME_SEPARATOR = 'T',\n    TAB = '\\t',\n    SPACE = ' ',\n    SLASH = '/',\n    STRING = 'string',\n    SIGNING_ALGORITHM = 'EG1-HMAC-SHA256 ',\n    AUTHORIZATION = 'Authorization',\n\n    /**\n     * Returns current timestamp in the format described in EdgeGrid specification (yyyyMMddTHH:mm:ss+0000)\n     *\n     * @returns {String} UTC timestamp in format yyyyMMddTHH:mm:ss+0000\n     */\n    getTimestamp = function () {\n        var date = new Date();\n\n        return date.getUTCFullYear() +\n                _.padStart(date.getUTCMonth() + 1, 2, ZERO) +\n                _.padStart(date.getUTCDate(), 2, ZERO) +\n                DATE_TIME_SEPARATOR +\n                _.padStart(date.getUTCHours(), 2, ZERO) +\n                COLON +\n                _.padStart(date.getUTCMinutes(), 2, ZERO) +\n                COLON +\n                _.padStart(date.getUTCSeconds(), 2, ZERO) +\n                UTC_OFFSET;\n    },\n\n    /**\n     * Creates a String containing a tab delimited set of headers.\n     *\n     * @param {String[]} headersToSign Headers to include in signature\n     * @param {Object} headers Request headers\n     * @returns {String} Canonicalized headers\n     */\n    canonicalizeHeaders = function (headersToSign, headers) {\n        var formattedHeaders = [],\n            headerValue;\n\n        headersToSign.forEach(function (headerName) {\n            if (typeof headerName !== STRING) { return; }\n\n            // trim the header name to remove extra spaces from user input\n            headerName = headerName.trim().toLowerCase();\n            headerValue = headers[headerName];\n\n            // should not include empty headers as per the specification\n            if (typeof headerValue !== STRING || headerValue === EMPTY) { return; }\n\n            formattedHeaders.push(`${headerName}:${headerValue.trim().replace(/\\s+/g, SPACE)}`);\n        });\n\n        return formattedHeaders.join(TAB);\n    },\n\n    /**\n     * Returns base64 encoding of the SHA-256 HMAC of given data signed with given key\n     *\n     * @param {String} data Data to sign\n     * @param {String} key Key to use while signing the data\n     * @returns {String} Base64 encoded signature\n     */\n    base64HmacSha256 = function (data, key) {\n        var encrypt = crypto.createHmac('sha256', key);\n\n        encrypt.update(data);\n\n        return encrypt.digest('base64');\n    },\n\n    /**\n     * Calculates body hash with given algorithm and digestEncoding.\n     *\n     * @param {RequestBody} body Request body\n     * @param {String} algorithm Hash algorithm to use\n     * @param {String} digestEncoding Encoding of the hash\n     * @param {Function} callback Callback function that will be called with body hash\n     */\n    computeBodyHash = function (body, algorithm, digestEncoding, callback) {\n        if (!(body && algorithm && digestEncoding) || body.isEmpty()) { return callback(); }\n\n        var hash = crypto.createHash(algorithm),\n            originalReadStream,\n            rawBody,\n            urlencodedBody,\n            graphqlBody;\n\n        if (body.mode === RequestBody.MODES.raw) {\n            rawBody = bodyBuilder.raw(body.raw).body;\n            hash.update(rawBody);\n\n            return callback(hash.digest(digestEncoding));\n        }\n\n        if (body.mode === RequestBody.MODES.urlencoded) {\n            urlencodedBody = bodyBuilder.urlencoded(body.urlencoded).form;\n            urlencodedBody = urlEncoder.encodeQueryString(urlencodedBody);\n            hash.update(urlencodedBody);\n\n            return callback(hash.digest(digestEncoding));\n        }\n\n        if (body.mode === RequestBody.MODES.file) {\n            originalReadStream = _.get(body, 'file.content');\n\n            if (!originalReadStream) {\n                return callback();\n            }\n\n            return originalReadStream.cloneReadStream(function (err, clonedStream) {\n                if (err) { return callback(); }\n\n                clonedStream.on('data', function (chunk) {\n                    hash.update(chunk);\n                });\n\n                clonedStream.on('end', function () {\n                    callback(hash.digest(digestEncoding));\n                });\n            });\n        }\n\n        if (body.mode === RequestBody.MODES.graphql) {\n            graphqlBody = bodyBuilder.graphql(body.graphql).body;\n            hash.update(graphqlBody);\n\n            return callback(hash.digest(digestEncoding));\n        }\n\n        // @todo: Figure out a way to calculate hash for form-data body type.\n\n        // ensure that callback is called if body.mode doesn't match with any of the above modes\n        return callback();\n    };\n\n/**\n * @implements {AuthHandlerInterface}\n */\nmodule.exports = {\n    /**\n     * @property {AuthHandlerInterface~AuthManifest}\n     */\n    manifest: {\n        info: {\n            name: 'edgegrid',\n            version: '1.0.0'\n        },\n        updates: [\n            {\n                property: 'Authorization',\n                type: 'header'\n            }\n        ]\n    },\n\n    /**\n     * Initializes a item (fetches all required parameters, etc) before the actual authorization step.\n     *\n     * @param {AuthInterface} auth AuthInterface instance created with request auth\n     * @param {Response} response Response of intermediate request (it any)\n     * @param {AuthHandlerInterface~authInitHookCallback} done Callback function called with error as first argument\n     */\n    init: function (auth, response, done) {\n        done(null);\n    },\n\n    /**\n     * Checks the item, and fetches any parameters that are not already provided.\n     *\n     * @param {AuthInterface} auth AuthInterface instance created with request auth\n     * @param {AuthHandlerInterface~authPreHookCallback} done Callback function called with error, success and request\n     */\n    pre: function (auth, done) {\n        // only check required auth params here\n        done(null, Boolean(auth.get('accessToken') && auth.get('clientToken') && auth.get('clientSecret')));\n    },\n\n    /**\n     * Verifies whether the request was successful after being sent.\n     *\n     * @param {AuthInterface} auth AuthInterface instance created with request auth\n     * @param {Requester} response Response of the request\n     * @param {AuthHandlerInterface~authPostHookCallback} done Callback function called with error and success\n     */\n    post: function (auth, response, done) {\n        done(null, true);\n    },\n\n    /**\n     * Generates the signature, and returns the Authorization header.\n     *\n     * @param {Object} params Auth parameters to use in header calculation\n     * @param {String} params.accessToken Access token provided by service provider\n     * @param {String} params.clientToken Client token provided by service provider\n     * @param {String} params.clientSecret Client secret provided by service provider\n     * @param {String} params.nonce Nonce to include in authorization header\n     * @param {String} params.timestamp Timestamp as defined in protocol specification\n     * @param {String} [params.bodyHash] Base64-encoded SHA-256 hash of request body for POST request\n     * @param {Object[]} params.headers Request headers\n     * @param {String[]} params.headersToSign Ordered list of headers to include in signature\n     * @param {String} params.method Request method\n     * @param {Url} params.url Node's URL object\n     * @returns {String} Authorization header\n     */\n    computeHeader: function (params) {\n        var authHeader = SIGNING_ALGORITHM,\n            signingKey = base64HmacSha256(params.timestamp, params.clientSecret),\n            dataToSign;\n\n        authHeader += `client_token=${params.clientToken};`;\n        authHeader += `access_token=${params.accessToken};`;\n        authHeader += `timestamp=${params.timestamp};`;\n        authHeader += `nonce=${params.nonce};`;\n\n        dataToSign = [\n            params.method,\n\n            // trim to convert 'http:' from Node's URL object to 'http'\n            _.trimEnd(params.url.protocol, COLON),\n            params.baseURL || params.url.host,\n            params.url.path || SLASH,\n            canonicalizeHeaders(params.headersToSign, params.headers),\n            params.bodyHash || EMPTY,\n            authHeader\n        ].join(TAB);\n\n        return authHeader + 'signature=' + base64HmacSha256(dataToSign, signingKey);\n    },\n\n    /**\n     * Signs a request.\n     *\n     * @param {AuthInterface} auth AuthInterface instance created with request auth\n     * @param {Request} request Request to be sent\n     * @param {AuthHandlerInterface~authSignHookCallback} done Callback function\n     */\n    sign: function (auth, request, done) {\n        var params = auth.get([\n                'accessToken',\n                'clientToken',\n                'clientSecret',\n                'baseURL',\n                'nonce',\n                'timestamp',\n                'headersToSign'\n            ]),\n            url = urlEncoder.toNodeUrl(request.url),\n            self = this;\n\n        if (!(params.accessToken && params.clientToken && params.clientSecret)) {\n            return done(); // Nothing to do if required parameters are not present.\n        }\n\n        request.removeHeader(AUTHORIZATION, { ignoreCase: true });\n\n        // Extract host from provided baseURL.\n        params.baseURL = params.baseURL && urlEncoder.toNodeUrl(params.baseURL).host;\n        params.nonce = params.nonce || uuid.v4();\n        params.timestamp = params.timestamp || getTimestamp();\n        params.url = url;\n        params.method = request.method;\n\n        // ensure that headers are case-insensitive as specified in the documentation\n        params.headers = request.getHeaders({ enabled: true, ignoreCase: true });\n\n        if (typeof params.headersToSign === STRING) {\n            params.headersToSign = params.headersToSign.split(',');\n        }\n        else if (!_.isArray(params.headersToSign)) {\n            params.headersToSign = [];\n        }\n\n        // only calculate body hash for POST requests according to specification\n        if (request.method === 'POST') {\n            return computeBodyHash(request.body, 'sha256', 'base64', function (bodyHash) {\n                params.bodyHash = bodyHash;\n\n                request.addHeader({\n                    key: AUTHORIZATION,\n                    value: self.computeHeader(params),\n                    system: true\n                });\n\n                return done();\n            });\n        }\n\n        request.addHeader({\n            key: AUTHORIZATION,\n            value: self.computeHeader(params),\n            system: true\n        });\n\n        return done();\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}