{"ast":null,"code":"var sdk = require('postman-collection'),\n  ItemGroup = sdk.ItemGroup,\n  Item = sdk.Item,\n  DEFAULT_LOOKUP_STRATEGY = 'idOrName',\n  INVALID_LOOKUP_STRATEGY_ERROR = 'runtime~extractRunnableItems: Invalid entrypoint lookupStrategy',\n  /**\n   * Accumulate all items in order if entry point is a collection/folder.\n   * If an item is passed returns an array with that item.\n   *\n   * @param {ItemGroup|Item} node -\n   *\n   * @returns {Array<Item>}\n   *\n   * @todo: Possibly add mapItem to sdk.ItemGroup?\n   */\n  flattenNode = function (node) {\n    var items = [];\n\n    // bail out\n    if (!node) {\n      return items;\n    }\n    if (ItemGroup.isItemGroup(node)) {\n      node.forEachItem(function (item) {\n        items.push(item);\n      });\n    } else if (Item.isItem(node)) {\n      items.push(node);\n    }\n    return items;\n  },\n  /**\n   * Finds an item or item group based on id or name.\n   *\n   * @param {ItemGroup} itemGroup -\n   * @param {?String} match -\n   *\n   * @returns {Item|ItemGroup|undefined}\n   */\n  findItemOrGroup = function (itemGroup, match) {\n    if (!itemGroup || !itemGroup.items) {\n      return;\n    }\n    var matched;\n\n    // lookup match on own children\n    itemGroup.items.each(function (itemOrGroup) {\n      if (itemOrGroup.id === match || itemOrGroup.name === match) {\n        matched = itemOrGroup;\n        return false; // exit the loop\n      }\n    });\n\n    // if there is no match on own children, start lookup on grand children\n    !matched && itemGroup.items.each(function (itemOrGroup) {\n      matched = findItemOrGroup(itemOrGroup, match);\n      if (matched) {\n        return false;\n      } // exit the loop\n    });\n\n    return matched;\n  },\n  /**\n   * Finds items based on multiple ids or names provided.\n   *\n   * @param {ItemGroup} itemGroup - Composite list of Item or ItemGroup.\n   * @param {Object} entrypointSubset - Entry-points reference passed across multiple recursive calls.\n   * @param {Boolean} _continueAccumulation - Flag used to decide whether to accumulate items or not.\n   * @param {Object} _accumulatedItems - Found Items or ItemGroups.\n   * @returns {Object} Found Items or ItemGroups.\n   */\n  findItemsOrGroups = function (itemGroup, entrypointSubset, _continueAccumulation, _accumulatedItems) {\n    !_accumulatedItems && (_accumulatedItems = {\n      members: [],\n      reference: {}\n    });\n    if (!itemGroup || !itemGroup.items) {\n      return _accumulatedItems;\n    }\n    var match;\n    itemGroup.items.each(function (item) {\n      // bail out if all entry-points are found.\n      if (!Object.keys(entrypointSubset).length) {\n        return false;\n      }\n\n      // lookup for item.id in entrypointSubset and if not found, lookup by item.name.\n      if (!(match = entrypointSubset[item.id] && item.id)) {\n        match = entrypointSubset[item.name] && item.name;\n      }\n      if (match) {\n        // only accumulate items which are not previously got tracked from its parent entrypoint.\n        if (_continueAccumulation) {\n          _accumulatedItems.members.push(item);\n          _accumulatedItems.reference[match] = item;\n        }\n\n        // delete looked-up entrypoint.\n        delete entrypointSubset[match];\n      }\n\n      // recursive call to find nested entry-points. To make sure all provided entry-points got tracked.\n      // _continueAccumulation flag will be `false` for children if their parent entrypoint is found.\n      return findItemsOrGroups(item, entrypointSubset, !match, _accumulatedItems);\n    });\n    return _accumulatedItems;\n  },\n  /**\n   * Finds an item or group from a path. The path should be an array of ids from the parent chain.\n   *\n   * @param {Collection} collection -\n   * @param {Object} options -\n   * @param {String} options.execute -\n   * @param {?Array<String>} [options.path] -\n   * @param {Function} callback -\n   */\n  lookupByPath = function (collection, options, callback) {\n    var lookupPath,\n      lastMatch = collection,\n      lookupOptions = options || {},\n      i,\n      ii;\n\n    // path can be empty, if item/group is at the top level\n    lookupPath = lookupOptions.path || [];\n\n    // push execute id to the path\n    options.execute && lookupPath.push(options.execute);\n\n    // go down the lookup path\n    for (i = 0, ii = lookupPath.length; i < ii && lastMatch; i++) {\n      lastMatch = lastMatch.items && lastMatch.items.one(lookupPath[i]);\n    }\n    callback && callback(null, flattenNode(lastMatch), lastMatch);\n  },\n  /**\n   * Finds an item or group on a collection with a matching id or name.\n   *\n   * @param {Collection} collection -\n   * @param {Object} options -\n   * @param {String} [options.execute] -\n   * @param {Function} callback -\n   */\n  lookupByIdOrName = function (collection, options, callback) {\n    var match = options.execute,\n      matched;\n    if (!match) {\n      return callback(null, []);\n    }\n\n    // do a recursive lookup\n    matched = findItemOrGroup(collection, match);\n    callback(null, flattenNode(matched), matched);\n  },\n  /**\n   * Finds items or item groups in a collection with matching list of ids or names.\n   *\n   * @note runnable items follows the order in which the items are defined in the collection\n   *\n   * @param {Collection} collection -\n   * @param {Object} options -\n   * @param {Array<String>} [options.execute] -\n   * @param {Function} callback -\n   */\n  lookupByMultipleIdOrName = function (collection, options, callback) {\n    var entrypoints = options.execute,\n      preserveOrder = options.preserveOrder,\n      entrypointLookup = {},\n      runnableItems = [],\n      items,\n      i,\n      ii;\n    if (!(Array.isArray(entrypoints) && entrypoints.length)) {\n      return callback(null, []);\n    }\n\n    // add temp reference for faster lookup of entry-point name/id.\n    // entry-points with same name/id will be ignored.\n    for (i = 0, ii = entrypoints.length; i < ii; i++) {\n      entrypointLookup[entrypoints[i]] = true;\n    }\n    items = findItemsOrGroups(collection, entrypointLookup, true);\n\n    // Extracting the items and folders by the order in which they appear as folder/request arguments,\n    // only if specified in the entrypoint.preserveOrder\n    if (preserveOrder) {\n      items.members = entrypoints.map(function (ref) {\n        return items.reference[ref];\n      });\n    }\n\n    // at this point of time, we should have traversed all items mentioned in entrypoint and created a linear\n    // subset of items. However, if post that, we still have items remaining in lookup object, that implies that\n    // extra items were present in user input and corresponding items for those do not exist in collection. As such\n    // we need to bail out if any of the given entry-point is not found.\n    if (Object.keys(entrypointLookup).length) {\n      return callback(null, []);\n    }\n\n    // extract runnable items from the searched items.\n    for (i = 0, ii = items.members.length; i < ii; i++) {\n      runnableItems = runnableItems.concat(flattenNode(items.members[i]));\n    }\n    callback(null, runnableItems, collection);\n  },\n  /**\n   * Finds items or item groups in a collection with matching list of ids or names.\n   *\n   * @note runnable items follows the order of entrypoints\n   *\n   * @param {Collection} collection -\n   * @param {Object} options -\n   * @param {Array<String>} [options.execute] -\n   * @param {Function} callback -\n   */\n  lookupByOrder = function (collection, options, callback) {\n    var entrypoints = options.execute,\n      entrypointLookup = {},\n      runnableItems = [],\n      items,\n      i,\n      ii;\n    if (!(Array.isArray(entrypoints) && entrypoints.length)) {\n      return callback(null, []);\n    }\n\n    // add temp reference for faster lookup of entry-point name/id.\n    // entry-points with same name/id will be ignored.\n    for (i = 0, ii = entrypoints.length; i < ii; i++) {\n      entrypointLookup[entrypoints[i]] = true;\n    }\n    items = findItemsOrGroups(collection, entrypointLookup, true);\n\n    // at this point of time, we should have traversed all items mentioned in entrypoint and created a linear\n    // subset of items. However, if post that, we still have items remaining in lookup object, that implies that\n    // extra items were present in user input and corresponding items for those do not exist in collection. As such\n    // we need to bail out if any of the given entry-point is not found.\n    if (Object.keys(entrypointLookup).length) {\n      return callback(null, []);\n    }\n\n    // extract runnable items from the searched items.\n    entrypoints.forEach(function (entrypoint) {\n      runnableItems = runnableItems.concat(flattenNode(items.reference[entrypoint]));\n    });\n    callback(null, runnableItems, collection);\n  },\n  lookupStrategyMap = {\n    path: lookupByPath,\n    idOrName: lookupByIdOrName,\n    followOrder: lookupByOrder,\n    multipleIdOrName: lookupByMultipleIdOrName\n  },\n  /**\n   * Extracts all the items on a collection starting from the entrypoint.\n   *\n   * @param {Collection} collection -\n   * @param {?Object} [entrypoint] -\n   * @param {String} [entrypoint.execute] id of item or group to execute (can be name when used with `idOrName`)\n   * @param {Array<String>} [entrypoint.path] path leading to the item or group selected (only for `path` strategy)\n   * @param {String} [entrypoint.lookupStrategy=idOrName] strategy to use for entrypoint lookup [idOrName, path]\n   * @param {Boolean} [entrypoint.preserveOrder] option to preserve the order of folder/items when specified.\n   * @param {Function} callback -\n   */\n  extractRunnableItems = function (collection, entrypoint, callback) {\n    var lookupFunction, lookupStrategy;\n\n    // if no entrypoint is specified, flatten the entire collection\n    if (!entrypoint) {\n      return callback(null, flattenNode(collection), collection);\n    }\n    lookupStrategy = entrypoint.lookupStrategy || DEFAULT_LOOKUP_STRATEGY;\n\n    // lookup entry using given strategy\n    // eslint-disable-next-line no-cond-assign\n    (lookupFunction = lookupStrategyMap[lookupStrategy]) ? lookupFunction(collection, entrypoint, callback) : callback(new Error(INVALID_LOOKUP_STRATEGY_ERROR)); // eslint-disable-line callback-return\n  };\n\nmodule.exports = {\n  extractRunnableItems\n};","map":{"version":3,"names":["sdk","require","ItemGroup","Item","DEFAULT_LOOKUP_STRATEGY","INVALID_LOOKUP_STRATEGY_ERROR","flattenNode","node","items","isItemGroup","forEachItem","item","push","isItem","findItemOrGroup","itemGroup","match","matched","each","itemOrGroup","id","name","findItemsOrGroups","entrypointSubset","_continueAccumulation","_accumulatedItems","members","reference","Object","keys","length","lookupByPath","collection","options","callback","lookupPath","lastMatch","lookupOptions","i","ii","path","execute","one","lookupByIdOrName","lookupByMultipleIdOrName","entrypoints","preserveOrder","entrypointLookup","runnableItems","Array","isArray","map","ref","concat","lookupByOrder","forEach","entrypoint","lookupStrategyMap","idOrName","followOrder","multipleIdOrName","extractRunnableItems","lookupFunction","lookupStrategy","Error","module","exports"],"sources":["/Users/Qusai.Qishta/node_modules/postman-runtime/lib/runner/extract-runnable-items.js"],"sourcesContent":["var sdk = require('postman-collection'),\n    ItemGroup = sdk.ItemGroup,\n    Item = sdk.Item,\n\n    DEFAULT_LOOKUP_STRATEGY = 'idOrName',\n    INVALID_LOOKUP_STRATEGY_ERROR = 'runtime~extractRunnableItems: Invalid entrypoint lookupStrategy',\n\n    /**\n     * Accumulate all items in order if entry point is a collection/folder.\n     * If an item is passed returns an array with that item.\n     *\n     * @param {ItemGroup|Item} node -\n     *\n     * @returns {Array<Item>}\n     *\n     * @todo: Possibly add mapItem to sdk.ItemGroup?\n     */\n    flattenNode = function (node) {\n        var items = [];\n\n        // bail out\n        if (!node) { return items; }\n\n        if (ItemGroup.isItemGroup(node)) {\n            node.forEachItem(function (item) { items.push(item); });\n        }\n        else if (Item.isItem(node)) {\n            items.push(node);\n        }\n\n        return items;\n    },\n\n    /**\n     * Finds an item or item group based on id or name.\n     *\n     * @param {ItemGroup} itemGroup -\n     * @param {?String} match -\n     *\n     * @returns {Item|ItemGroup|undefined}\n     */\n    findItemOrGroup = function (itemGroup, match) {\n        if (!itemGroup || !itemGroup.items) { return; }\n\n        var matched;\n\n        // lookup match on own children\n        itemGroup.items.each(function (itemOrGroup) {\n            if (itemOrGroup.id === match || itemOrGroup.name === match) {\n                matched = itemOrGroup;\n\n                return false; // exit the loop\n            }\n        });\n\n        // if there is no match on own children, start lookup on grand children\n        !matched && itemGroup.items.each(function (itemOrGroup) {\n            matched = findItemOrGroup(itemOrGroup, match);\n            if (matched) { return false; } // exit the loop\n        });\n\n        return matched;\n    },\n\n    /**\n     * Finds items based on multiple ids or names provided.\n     *\n     * @param {ItemGroup} itemGroup - Composite list of Item or ItemGroup.\n     * @param {Object} entrypointSubset - Entry-points reference passed across multiple recursive calls.\n     * @param {Boolean} _continueAccumulation - Flag used to decide whether to accumulate items or not.\n     * @param {Object} _accumulatedItems - Found Items or ItemGroups.\n     * @returns {Object} Found Items or ItemGroups.\n     */\n    findItemsOrGroups = function (itemGroup, entrypointSubset, _continueAccumulation, _accumulatedItems) {\n        !_accumulatedItems && (_accumulatedItems = { members: [], reference: {} });\n\n        if (!itemGroup || !itemGroup.items) { return _accumulatedItems; }\n\n        var match;\n\n        itemGroup.items.each(function (item) {\n            // bail out if all entry-points are found.\n            if (!Object.keys(entrypointSubset).length) { return false; }\n\n            // lookup for item.id in entrypointSubset and if not found, lookup by item.name.\n            if (!(match = entrypointSubset[item.id] && item.id)) {\n                match = entrypointSubset[item.name] && item.name;\n            }\n\n            if (match) {\n                // only accumulate items which are not previously got tracked from its parent entrypoint.\n                if (_continueAccumulation) {\n                    _accumulatedItems.members.push(item);\n                    _accumulatedItems.reference[match] = item;\n                }\n\n                // delete looked-up entrypoint.\n                delete entrypointSubset[match];\n            }\n\n            // recursive call to find nested entry-points. To make sure all provided entry-points got tracked.\n            // _continueAccumulation flag will be `false` for children if their parent entrypoint is found.\n            return findItemsOrGroups(item, entrypointSubset, !match, _accumulatedItems);\n        });\n\n        return _accumulatedItems;\n    },\n\n    /**\n     * Finds an item or group from a path. The path should be an array of ids from the parent chain.\n     *\n     * @param {Collection} collection -\n     * @param {Object} options -\n     * @param {String} options.execute -\n     * @param {?Array<String>} [options.path] -\n     * @param {Function} callback -\n     */\n    lookupByPath = function (collection, options, callback) {\n        var lookupPath,\n            lastMatch = collection,\n            lookupOptions = options || {},\n            i,\n            ii;\n\n        // path can be empty, if item/group is at the top level\n        lookupPath = lookupOptions.path || [];\n\n        // push execute id to the path\n        options.execute && (lookupPath.push(options.execute));\n\n        // go down the lookup path\n        for (i = 0, ii = lookupPath.length; (i < ii) && lastMatch; i++) {\n            lastMatch = lastMatch.items && lastMatch.items.one(lookupPath[i]);\n        }\n\n        callback && callback(null, flattenNode(lastMatch), lastMatch);\n    },\n\n    /**\n     * Finds an item or group on a collection with a matching id or name.\n     *\n     * @param {Collection} collection -\n     * @param {Object} options -\n     * @param {String} [options.execute] -\n     * @param {Function} callback -\n     */\n    lookupByIdOrName = function (collection, options, callback) {\n        var match = options.execute,\n            matched;\n\n        if (!match) { return callback(null, []); }\n\n        // do a recursive lookup\n        matched = findItemOrGroup(collection, match);\n\n        callback(null, flattenNode(matched), matched);\n    },\n\n    /**\n     * Finds items or item groups in a collection with matching list of ids or names.\n     *\n     * @note runnable items follows the order in which the items are defined in the collection\n     *\n     * @param {Collection} collection -\n     * @param {Object} options -\n     * @param {Array<String>} [options.execute] -\n     * @param {Function} callback -\n     */\n    lookupByMultipleIdOrName = function (collection, options, callback) {\n        var entrypoints = options.execute,\n            preserveOrder = options.preserveOrder,\n            entrypointLookup = {},\n            runnableItems = [],\n            items,\n            i,\n            ii;\n\n        if (!(Array.isArray(entrypoints) && entrypoints.length)) {\n            return callback(null, []);\n        }\n\n        // add temp reference for faster lookup of entry-point name/id.\n        // entry-points with same name/id will be ignored.\n        for (i = 0, ii = entrypoints.length; i < ii; i++) {\n            entrypointLookup[entrypoints[i]] = true;\n        }\n\n        items = findItemsOrGroups(collection, entrypointLookup, true);\n\n        // Extracting the items and folders by the order in which they appear as folder/request arguments,\n        // only if specified in the entrypoint.preserveOrder\n        if (preserveOrder) {\n            items.members = entrypoints.map(function (ref) {\n                return items.reference[ref];\n            });\n        }\n\n        // at this point of time, we should have traversed all items mentioned in entrypoint and created a linear\n        // subset of items. However, if post that, we still have items remaining in lookup object, that implies that\n        // extra items were present in user input and corresponding items for those do not exist in collection. As such\n        // we need to bail out if any of the given entry-point is not found.\n        if (Object.keys(entrypointLookup).length) {\n            return callback(null, []);\n        }\n\n        // extract runnable items from the searched items.\n        for (i = 0, ii = items.members.length; i < ii; i++) {\n            runnableItems = runnableItems.concat(flattenNode(items.members[i]));\n        }\n\n        callback(null, runnableItems, collection);\n    },\n\n    /**\n     * Finds items or item groups in a collection with matching list of ids or names.\n     *\n     * @note runnable items follows the order of entrypoints\n     *\n     * @param {Collection} collection -\n     * @param {Object} options -\n     * @param {Array<String>} [options.execute] -\n     * @param {Function} callback -\n     */\n    lookupByOrder = function (collection, options, callback) {\n        var entrypoints = options.execute,\n            entrypointLookup = {},\n            runnableItems = [],\n            items,\n            i,\n            ii;\n\n        if (!(Array.isArray(entrypoints) && entrypoints.length)) {\n            return callback(null, []);\n        }\n\n        // add temp reference for faster lookup of entry-point name/id.\n        // entry-points with same name/id will be ignored.\n        for (i = 0, ii = entrypoints.length; i < ii; i++) {\n            entrypointLookup[entrypoints[i]] = true;\n        }\n\n        items = findItemsOrGroups(collection, entrypointLookup, true);\n\n        // at this point of time, we should have traversed all items mentioned in entrypoint and created a linear\n        // subset of items. However, if post that, we still have items remaining in lookup object, that implies that\n        // extra items were present in user input and corresponding items for those do not exist in collection. As such\n        // we need to bail out if any of the given entry-point is not found.\n        if (Object.keys(entrypointLookup).length) {\n            return callback(null, []);\n        }\n\n        // extract runnable items from the searched items.\n        entrypoints.forEach(function (entrypoint) {\n            runnableItems = runnableItems.concat(flattenNode(items.reference[entrypoint]));\n        });\n\n        callback(null, runnableItems, collection);\n    },\n\n    lookupStrategyMap = {\n        path: lookupByPath,\n        idOrName: lookupByIdOrName,\n        followOrder: lookupByOrder,\n        multipleIdOrName: lookupByMultipleIdOrName\n    },\n\n    /**\n     * Extracts all the items on a collection starting from the entrypoint.\n     *\n     * @param {Collection} collection -\n     * @param {?Object} [entrypoint] -\n     * @param {String} [entrypoint.execute] id of item or group to execute (can be name when used with `idOrName`)\n     * @param {Array<String>} [entrypoint.path] path leading to the item or group selected (only for `path` strategy)\n     * @param {String} [entrypoint.lookupStrategy=idOrName] strategy to use for entrypoint lookup [idOrName, path]\n     * @param {Boolean} [entrypoint.preserveOrder] option to preserve the order of folder/items when specified.\n     * @param {Function} callback -\n     */\n    extractRunnableItems = function (collection, entrypoint, callback) {\n        var lookupFunction,\n            lookupStrategy;\n\n        // if no entrypoint is specified, flatten the entire collection\n        if (!entrypoint) { return callback(null, flattenNode(collection), collection); }\n\n        lookupStrategy = entrypoint.lookupStrategy || DEFAULT_LOOKUP_STRATEGY;\n\n        // lookup entry using given strategy\n        // eslint-disable-next-line no-cond-assign\n        (lookupFunction = lookupStrategyMap[lookupStrategy]) ?\n            lookupFunction(collection, entrypoint, callback) :\n            callback(new Error(INVALID_LOOKUP_STRATEGY_ERROR)); // eslint-disable-line callback-return\n    };\n\nmodule.exports = {\n    extractRunnableItems\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}