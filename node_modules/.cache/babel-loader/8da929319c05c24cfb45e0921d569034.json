{"ast":null,"code":"var _ = require('../util').lodash,\n  PropertyBase = require('./property-base').PropertyBase,\n  /**\n   * Primitive mutation types.\n   *\n   * @private\n   * @constant\n   * @type {Object}\n   */\n  PRIMITIVE_MUTATIONS = {\n    SET: 'set',\n    UNSET: 'unset'\n  },\n  /**\n   * Detects if the mutation is a primitive mutation type. A primitive mutation is the simplified mutation structure.\n   *\n   * @private\n   * @param {MutationTracker.mutation} mutation -\n   * @returns {Boolean}\n   */\n  isPrimitiveMutation = function (mutation) {\n    return mutation && mutation.length <= 2;\n  },\n  /**\n   * Applies a single mutation on a target.\n   *\n   * @private\n   * @param {*} target -\n   * @param {MutationTracker.mutation} mutation -\n   */\n  applyMutation = function applyMutation(target, mutation) {\n    // only `set` and `unset` instructions are supported\n    // for non primitive mutations, the instruction would have to be extracted from mutation\n    /* istanbul ignore if */\n    if (!isPrimitiveMutation(mutation)) {\n      return;\n    }\n\n    // extract instruction from the mutation\n    var operation = mutation.length > 1 ? PRIMITIVE_MUTATIONS.SET : PRIMITIVE_MUTATIONS.UNSET;\n\n    // now hand over applying mutation to the target\n    target.applyMutation(operation, ...mutation);\n  },\n  MutationTracker;\n\n/**\n * A JSON representation of a mutation on an object. Here objects mean instances of postman-collection classes.\n * This captures the instruction and the parameters of the instruction so that it can be replayed on a different object.\n * Mutations can be any change on an object. For example setting a key or unsetting a key.\n *\n * For example, the mutation to set `name` on an object to 'Bruce Wayne' would look like ['name', 'Bruce Wayne']. Where\n * the first item is the key path and second item is the value. To add a property `punchLine` to the object it would be\n * the same as updating the property i.e. ['punchLine', 'I\\'m Batman']. To remove a property `age` the mutation would\n * look like ['age'].\n *\n * This format of representing changes is derived from\n * {@link http://json-delta.readthedocs.io/en/latest/philosophy.html}.\n *\n * The `set` and `unset` are primitive instructions and can be derived from the mutation without explicitly stating the\n * instruction. For more complex mutation the instruction would have to be explicitly stated.\n *\n * @typedef {Array} MutationTracker.mutation\n */\n\n/**\n * A JSON representation of the MutationTracker.\n *\n * @typedef MutationTracker.definition\n *\n * @property {Array} stream contains the stream mutations tracked\n * @property {Object} compacted contains a compacted version of the mutations\n * @property {Boolean} [autoCompact=false] when set to true, all new mutations would be compacted immediately\n */\n_.inherit(\n/**\n * A MutationTracker allows to record mutations on any of object and store them. This stored mutations can be\n * transported for reporting or to replay on similar objects.\n *\n * @constructor\n * @extends {PropertyBase}\n *\n * @param {MutationTracker.definition} definition serialized mutation tracker\n */\nMutationTracker = function MutationTracker(definition) {\n  // this constructor is intended to inherit and as such the super constructor is required to be executed\n  MutationTracker.super_.call(this, definition);\n  definition = definition || {};\n\n  // initialize options\n  this.autoCompact = Boolean(definition.autoCompact);\n\n  // restore mutations\n  this.stream = Array.isArray(definition.stream) ? definition.stream : [];\n  this.compacted = _.isPlainObject(definition.compacted) ? definition.compacted : {};\n}, PropertyBase);\n_.assign(MutationTracker.prototype, /** @lends MutationTracker.prototype */{\n  /**\n   * Records a new mutation.\n   *\n   * @private\n   * @param {MutationTracker.mutation} mutation -\n   */\n  addMutation(mutation) {\n    // bail out for empty or unsupported mutations\n    if (!(mutation && isPrimitiveMutation(mutation))) {\n      return;\n    }\n\n    // if autoCompact is set, we need to compact while adding\n    if (this.autoCompact) {\n      this.addAndCompact(mutation);\n      return;\n    }\n\n    // otherwise just push to the stream of mutations\n    this.stream.push(mutation);\n  },\n  /**\n   * Records a mutation compacting existing mutations for the same key path.\n   *\n   * @private\n   * @param {MutationTracker.mutation} mutation -\n   */\n  addAndCompact(mutation) {\n    // for `set` and `unset` mutations the key to compact with is the `keyPath`\n    var key = mutation[0];\n\n    // convert `keyPath` to a string\n    key = Array.isArray(key) ? key.join('.') : key;\n    this.compacted[key] = mutation;\n  },\n  /**\n   * Track a mutation.\n   *\n   * @param {String} instruction the type of mutation\n   * @param {...*} payload mutation parameters\n   */\n  track(instruction) {\n    for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      payload[_key - 1] = arguments[_key];\n    }\n    // invalid call\n    if (!(instruction && payload)) {\n      return;\n    }\n\n    // unknown instruction\n    if (!(instruction === PRIMITIVE_MUTATIONS.SET || instruction === PRIMITIVE_MUTATIONS.UNSET)) {\n      return;\n    }\n\n    // for primitive mutations the arguments form the mutation object\n    // if there is more complex mutation, we have to use a processor to create a mutation for the instruction\n    this.addMutation(payload);\n  },\n  /**\n   * Compacts the recorded mutations removing duplicate mutations that apply on the same key path.\n   */\n  compact() {\n    // for each of the mutation, add to compacted list\n    this.stream.forEach(this.addAndCompact.bind(this));\n\n    // reset the `stream`, all the mutations are now recorded in the `compacted` storage\n    this.stream = [];\n  },\n  /**\n   * Returns the number of mutations tracked so far.\n   *\n   * @returns {Number}\n   */\n  count() {\n    // the total count of mutations is the sum of\n    // mutations in the stream\n    var mutationCount = this.stream.length;\n\n    // and the compacted mutations\n    mutationCount += Object.keys(this.compacted).length;\n    return mutationCount;\n  },\n  /**\n   * Applies all the recorded mutations on a target object.\n   *\n   * @param {*} target Target to apply mutations. Must implement `applyMutation`.\n   */\n  applyOn(target) {\n    if (!(target && target.applyMutation)) {\n      return;\n    }\n    var applyIndividualMutation = function applyIndividualMutation(mutation) {\n      applyMutation(target, mutation);\n    };\n\n    // mutations move from `stream` to `compacted`, so we apply the compacted mutations first\n    // to ensure FIFO of mutations\n\n    // apply the compacted mutations first\n    _.forEach(this.compacted, applyIndividualMutation);\n\n    // apply the mutations in the stream\n    _.forEach(this.stream, applyIndividualMutation);\n  }\n});\n_.assign(MutationTracker, /** @lends MutationTracker */{\n  /**\n   * Defines the name of this property for internal use.\n   *\n   * @private\n   * @readOnly\n   * @type {String}\n   */\n  _postman_propertyName: 'MutationTracker',\n  /**\n   * Check whether an object is an instance of {@link MutationTracker}.\n   *\n   * @param {*} obj -\n   * @returns {Boolean}\n   */\n  isMutationTracker: function (obj) {\n    return Boolean(obj) && (obj instanceof MutationTracker || _.inSuperChain(obj.constructor, '_postman_propertyName', MutationTracker._postman_propertyName));\n  }\n});\nmodule.exports = {\n  MutationTracker\n};","map":{"version":3,"names":["_","require","lodash","PropertyBase","PRIMITIVE_MUTATIONS","SET","UNSET","isPrimitiveMutation","mutation","length","applyMutation","target","operation","MutationTracker","inherit","definition","super_","call","autoCompact","Boolean","stream","Array","isArray","compacted","isPlainObject","assign","prototype","addMutation","addAndCompact","push","key","join","track","instruction","payload","compact","forEach","bind","count","mutationCount","Object","keys","applyOn","applyIndividualMutation","_postman_propertyName","isMutationTracker","obj","inSuperChain","constructor","module","exports"],"sources":["/Users/Qusai.Qishta/node_modules/postman-collection/lib/collection/mutation-tracker.js"],"sourcesContent":["var _ = require('../util').lodash,\n    PropertyBase = require('./property-base').PropertyBase,\n\n    /**\n     * Primitive mutation types.\n     *\n     * @private\n     * @constant\n     * @type {Object}\n     */\n    PRIMITIVE_MUTATIONS = {\n        SET: 'set',\n        UNSET: 'unset'\n    },\n\n    /**\n     * Detects if the mutation is a primitive mutation type. A primitive mutation is the simplified mutation structure.\n     *\n     * @private\n     * @param {MutationTracker.mutation} mutation -\n     * @returns {Boolean}\n     */\n    isPrimitiveMutation = function (mutation) {\n        return mutation && mutation.length <= 2;\n    },\n\n    /**\n     * Applies a single mutation on a target.\n     *\n     * @private\n     * @param {*} target -\n     * @param {MutationTracker.mutation} mutation -\n     */\n    applyMutation = function applyMutation (target, mutation) {\n        // only `set` and `unset` instructions are supported\n        // for non primitive mutations, the instruction would have to be extracted from mutation\n        /* istanbul ignore if */\n        if (!isPrimitiveMutation(mutation)) {\n            return;\n        }\n\n        // extract instruction from the mutation\n        var operation = mutation.length > 1 ? PRIMITIVE_MUTATIONS.SET : PRIMITIVE_MUTATIONS.UNSET;\n\n        // now hand over applying mutation to the target\n        target.applyMutation(operation, ...mutation);\n    },\n\n    MutationTracker;\n\n/**\n * A JSON representation of a mutation on an object. Here objects mean instances of postman-collection classes.\n * This captures the instruction and the parameters of the instruction so that it can be replayed on a different object.\n * Mutations can be any change on an object. For example setting a key or unsetting a key.\n *\n * For example, the mutation to set `name` on an object to 'Bruce Wayne' would look like ['name', 'Bruce Wayne']. Where\n * the first item is the key path and second item is the value. To add a property `punchLine` to the object it would be\n * the same as updating the property i.e. ['punchLine', 'I\\'m Batman']. To remove a property `age` the mutation would\n * look like ['age'].\n *\n * This format of representing changes is derived from\n * {@link http://json-delta.readthedocs.io/en/latest/philosophy.html}.\n *\n * The `set` and `unset` are primitive instructions and can be derived from the mutation without explicitly stating the\n * instruction. For more complex mutation the instruction would have to be explicitly stated.\n *\n * @typedef {Array} MutationTracker.mutation\n */\n\n/**\n * A JSON representation of the MutationTracker.\n *\n * @typedef MutationTracker.definition\n *\n * @property {Array} stream contains the stream mutations tracked\n * @property {Object} compacted contains a compacted version of the mutations\n * @property {Boolean} [autoCompact=false] when set to true, all new mutations would be compacted immediately\n */\n_.inherit((\n\n    /**\n     * A MutationTracker allows to record mutations on any of object and store them. This stored mutations can be\n     * transported for reporting or to replay on similar objects.\n     *\n     * @constructor\n     * @extends {PropertyBase}\n     *\n     * @param {MutationTracker.definition} definition serialized mutation tracker\n     */\n    MutationTracker = function MutationTracker (definition) {\n        // this constructor is intended to inherit and as such the super constructor is required to be executed\n        MutationTracker.super_.call(this, definition);\n\n        definition = definition || {};\n\n        // initialize options\n        this.autoCompact = Boolean(definition.autoCompact);\n\n        // restore mutations\n        this.stream = Array.isArray(definition.stream) ? definition.stream : [];\n        this.compacted = _.isPlainObject(definition.compacted) ? definition.compacted : {};\n    }), PropertyBase);\n\n_.assign(MutationTracker.prototype, /** @lends MutationTracker.prototype */ {\n\n    /**\n     * Records a new mutation.\n     *\n     * @private\n     * @param {MutationTracker.mutation} mutation -\n     */\n    addMutation (mutation) {\n        // bail out for empty or unsupported mutations\n        if (!(mutation && isPrimitiveMutation(mutation))) {\n            return;\n        }\n\n        // if autoCompact is set, we need to compact while adding\n        if (this.autoCompact) {\n            this.addAndCompact(mutation);\n\n            return;\n        }\n\n        // otherwise just push to the stream of mutations\n        this.stream.push(mutation);\n    },\n\n    /**\n     * Records a mutation compacting existing mutations for the same key path.\n     *\n     * @private\n     * @param {MutationTracker.mutation} mutation -\n     */\n    addAndCompact (mutation) {\n        // for `set` and `unset` mutations the key to compact with is the `keyPath`\n        var key = mutation[0];\n\n        // convert `keyPath` to a string\n        key = Array.isArray(key) ? key.join('.') : key;\n\n        this.compacted[key] = mutation;\n    },\n\n    /**\n     * Track a mutation.\n     *\n     * @param {String} instruction the type of mutation\n     * @param {...*} payload mutation parameters\n     */\n    track (instruction, ...payload) {\n        // invalid call\n        if (!(instruction && payload)) {\n            return;\n        }\n\n        // unknown instruction\n        if (!(instruction === PRIMITIVE_MUTATIONS.SET || instruction === PRIMITIVE_MUTATIONS.UNSET)) {\n            return;\n        }\n\n        // for primitive mutations the arguments form the mutation object\n        // if there is more complex mutation, we have to use a processor to create a mutation for the instruction\n        this.addMutation(payload);\n    },\n\n    /**\n     * Compacts the recorded mutations removing duplicate mutations that apply on the same key path.\n     */\n    compact () {\n        // for each of the mutation, add to compacted list\n        this.stream.forEach(this.addAndCompact.bind(this));\n\n        // reset the `stream`, all the mutations are now recorded in the `compacted` storage\n        this.stream = [];\n    },\n\n    /**\n     * Returns the number of mutations tracked so far.\n     *\n     * @returns {Number}\n     */\n    count () {\n        // the total count of mutations is the sum of\n        // mutations in the stream\n        var mutationCount = this.stream.length;\n\n        // and the compacted mutations\n        mutationCount += Object.keys(this.compacted).length;\n\n        return mutationCount;\n    },\n\n    /**\n     * Applies all the recorded mutations on a target object.\n     *\n     * @param {*} target Target to apply mutations. Must implement `applyMutation`.\n     */\n    applyOn (target) {\n        if (!(target && target.applyMutation)) {\n            return;\n        }\n\n        var applyIndividualMutation = function applyIndividualMutation (mutation) {\n            applyMutation(target, mutation);\n        };\n\n        // mutations move from `stream` to `compacted`, so we apply the compacted mutations first\n        // to ensure FIFO of mutations\n\n        // apply the compacted mutations first\n        _.forEach(this.compacted, applyIndividualMutation);\n\n        // apply the mutations in the stream\n        _.forEach(this.stream, applyIndividualMutation);\n    }\n});\n\n_.assign(MutationTracker, /** @lends MutationTracker */ {\n    /**\n     * Defines the name of this property for internal use.\n     *\n     * @private\n     * @readOnly\n     * @type {String}\n     */\n    _postman_propertyName: 'MutationTracker',\n\n    /**\n     * Check whether an object is an instance of {@link MutationTracker}.\n     *\n     * @param {*} obj -\n     * @returns {Boolean}\n     */\n    isMutationTracker: function (obj) {\n        return Boolean(obj) && ((obj instanceof MutationTracker) ||\n            _.inSuperChain(obj.constructor, '_postman_propertyName', MutationTracker._postman_propertyName));\n    }\n});\n\nmodule.exports = {\n    MutationTracker\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}