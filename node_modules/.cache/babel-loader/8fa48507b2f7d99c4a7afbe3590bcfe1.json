{"ast":null,"code":"var _ = require('lodash'),\n  fs = require('fs'),\n  async = require('async'),\n  Collection = require('postman-collection').Collection,\n  VariableScope = require('postman-collection').VariableScope,\n  CookieJar = require('tough-cookie').CookieJar,\n  transformer = require('postman-collection-transformer'),\n  liquidJSON = require('liquid-json'),\n  parseCsv = require('csv-parse'),\n  util = require('../util'),\n  config = require('../config'),\n  /**\n   * The message displayed when the specified collection file can't be loaded.\n   *\n   * @const\n   * @type {String}\n   */\n  COLLECTION_LOAD_ERROR_MESSAGE = 'collection could not be loaded',\n  /**\n   * The message displayed when the specified iteration data file can't be loaded.\n   *\n   * @const\n   * @type {String}\n   */\n  ITERATION_DATA_LOAD_ERROR_MESSAGE = 'iteration data could not be loaded',\n  /**\n   * The message displayed when the specified environment or globals file can't be loaded.\n   *\n   * @const\n   * @type {String}\n   */\n  LOAD_ERROR_MESSAGE = 'could not load ',\n  /**\n   * The set of postman collection transformer options, to convert collection v1 to collection v2.\n   *\n   * @const\n   * @type {Object}\n   */\n  COLLECTION_TRANSFORMER_OPTION = {\n    inputVersion: '1.0.0',\n    outputVersion: '2.1.0'\n  },\n  /**\n   * Accepts an object, and extracts the property inside an object which is supposed to contain the required data.\n   * In case of variables, it also extracts them into plain JS objects.\n   *\n   * @param {Object} source - The source wrapper object that may or may not contain inner wrapped properties.\n   * @param {String} type - \"environment\" or \"globals\", etc.\n   * @returns {Object} - The object representation of the current extracted property.\n   */\n  extractModel = function (source, type) {\n    source = source[type] || source; // extract object that holds variable. these usually come from cloud API\n    if (!_.isObject(source)) {\n      return undefined;\n    }\n\n    // ensure we un-box the JSON if it comes from cloud-api or similar sources\n    !source.values && _.isObject(source[type]) && (source = source[type]);\n\n    // we ensure that environment passed as array is converted to plain object. runtime does this too, but we do it\n    // here for consistency of options passed to reporters\n    return source;\n  },\n  /**\n   * Loads the given data of type from a specified external location\n   *\n   * @param {String} type - The type of data to load.\n   * @param {String} location - The location to load from (file path or URL).\n   * @param {Object} options - The set of wrapped options.\n   * @param {function} cb - The callback function whose invocation marks the end of the external load routine.\n   * @returns {*}\n   */\n  externalLoader = function (type, location, options, cb) {\n    return _.isString(location) ? util.fetchJson(type, location, options, function (err, data) {\n      if (err) {\n        return cb(err);\n      }\n      return cb(null, extractModel(data, type));\n    }) : cb(null, extractModel(location, type));\n  },\n  /**\n   * A helper method to process a collection and convert it to a V2 equivalent if necessary, and return it.\n   *\n   * @todo Drop support for the v1 collection format in Newman v5.\n   * Reference: https://github.com/postmanlabs/newman/pull/1660\n   *\n   * @param {Object} collection The input collection, specified as a JSON object.\n   * @param {Function} callback A handler function that consumes an error object and the processed collection.\n   * @returns {*}\n   */\n  processCollection = function (collection, callback) {\n    if (util.isV1Collection(collection)) {\n      // @todo: route this via print module to respect silent flags\n      console.warn('newman: Newman v4 deprecates support for the v1 collection format');\n      console.warn('  Use the Postman Native app to export collections in the v2 format\\n');\n      return transformer.convert(collection, COLLECTION_TRANSFORMER_OPTION, callback);\n    }\n    callback(null, collection);\n  },\n  /**\n   * Helper function that manages the load of environments and globals\n   *\n   * @private\n   * @param {String} type - The type of resource to load: collection, environment, etc.\n   * @param {String|Object} value - The value derived from the CLI or run command.\n   * @param {Object} options - The set of wrapped options.\n   * @param {Function} callback - The function invoked when the scope has been loaded.\n   */\n  loadScopes = function (type, value, options, callback) {\n    var done = function (err, scope) {\n      if (err) {\n        return callback(new Error(LOAD_ERROR_MESSAGE + `${type}\\n  ${err.message || err}`));\n      }\n      if (!_.isObject(scope)) {\n        return done(new Error(LOAD_ERROR_MESSAGE + type));\n      }\n      callback(null, new VariableScope(VariableScope.isVariableScope(scope) ? scope.toJSON() : scope));\n    };\n    if (_.isObject(value)) {\n      return done(null, value);\n    }\n    externalLoader(type, value, options, done);\n  },\n  /**\n   * Custom method to auto parse CSV values\n   *\n   * @private\n   * @param {String} value - CSV field value\n   * @param {Object} context - Context of field value\n   * @param {Boolean} context.quoting - A boolean indicating if the field was surrounded by quotes.\n   * @returns {String|Number|Date}\n   */\n  csvAutoParse = function (value, context) {\n    if (context.quoting) {\n      // avoid parsing quoted values\n      return value;\n    }\n    if (util.isInt(value)) {\n      return parseInt(value, 10);\n    }\n    if (util.isFloat(value)) {\n      return parseFloat(value);\n    }\n    return value;\n  },\n  /**\n   * Custom configuration loaders for the required configuration keys.\n   *\n   * @type {Object}\n   */\n  configLoaders = {\n    /**\n     * The collection file load helper for the current run.\n     *\n     * @param {Object|String} value - The collection, specified as a JSON object, or the path to it's file.\n     * @param {Object} options - The set of wrapped options.\n     * @param {Function} callback - The callback function invoked to mark the end of the collection load routine.\n     * @returns {*}\n     */\n    collection: function (value, options, callback) {\n      /**\n       * The post collection load handler.\n       *\n       * @param {?Error} err - An Error instance / null, passed from the collection loader.\n       * @param {Object} collection - The collection / raw JSON object, passed from the collection loader.\n       * @returns {*}\n       */\n      var done = function (err, collection) {\n        if (err) {\n          return callback(err);\n        }\n\n        // ensure that the collection option is present before starting a run\n        if (!_.isObject(collection)) {\n          return callback(new Error(COLLECTION_LOAD_ERROR_MESSAGE));\n        }\n\n        // ensure that the collection reference is an SDK instance\n        // @todo - should this be handled by config loaders?\n        collection = new Collection(Collection.isCollection(collection) ?\n        // if the option contain an instance of collection, we simply clone it for future use\n        // create a collection in case it is not one. user can send v2 JSON as a source and that will be\n        // converted to a collection\n        collection.toJSON() : collection);\n        callback(null, collection);\n      };\n\n      // if the collection has been specified as an object, convert to V2 if necessary and return the result\n      if (_.isObject(value)) {\n        return processCollection(value, done);\n      }\n      externalLoader('collection', value, options, function (err, data) {\n        if (err) {\n          return done(new Error(COLLECTION_LOAD_ERROR_MESSAGE + (err.help ? `\\n  ${err.help}` : '') + `\\n  ${err.message || err}`));\n        }\n        if (!_.isObject(data)) {\n          return done(new Error(COLLECTION_LOAD_ERROR_MESSAGE));\n        }\n        return processCollection(data, done);\n      });\n    },\n    /**\n     * The environment configuration object, loaded for the current collection run.\n     *\n     * @type {Object}\n     */\n    environment: loadScopes.bind(this, 'environment'),\n    /**\n     * The object of globals, loaded for the collection run.\n     *\n     * @type {Object}\n     */\n    globals: loadScopes.bind(this, 'globals'),\n    /**\n     * Helper function to sanitize folder option.\n     *\n     * @param {String[]|String} value - The list of folders to execute\n     * @param {Object} options - The set of wrapped options.\n     * @param {Function} callback - The callback function invoked to mark the end of the folder load routine.\n     * @returns {*}\n     */\n    folder: function (value, options, callback) {\n      if (!value.length) {\n        return callback(); // avoids empty string or array\n      }\n\n      if (Array.isArray(value) && value.length === 1) {\n        return callback(null, value[0]); // avoids using multipleIdOrName strategy for a single item array\n      }\n\n      callback(null, value);\n    },\n    /**\n     * The iterationData loader module, with support for JSON or CSV data files.\n     *\n     * @param {String|Object[]} location - The path to the iteration data file for the current collection run, or\n     * the array of iteration data objects.\n     * @param {Object} options - The set of wrapped options.\n     * @param {Function} callback - The function invoked to indicate the end of the iteration data loading routine.\n     * @returns {*}\n     */\n    iterationData: function (location, options, callback) {\n      if (_.isArray(location)) {\n        return callback(null, location);\n      }\n      util.fetch(location, function (err, data) {\n        if (err) {\n          return callback(new Error(ITERATION_DATA_LOAD_ERROR_MESSAGE + `\\n  ${err.message || err}`));\n        }\n\n        // Try loading as a JSON, fall-back to CSV.\n        async.waterfall([cb => {\n          try {\n            return cb(null, liquidJSON.parse(data.trim()));\n          } catch (e) {\n            return cb(null, undefined); // e masked to avoid displaying JSON parse errors for CSV files\n          }\n        }, (json, cb) => {\n          if (json) {\n            return cb(null, json);\n          }\n          // Wasn't JSON\n          parseCsv(data, {\n            columns: true,\n            // infer the columns names from the first row\n            escape: '\"',\n            // escape character\n            cast: csvAutoParse,\n            // function to cast values of individual fields\n            trim: true,\n            // ignore whitespace immediately around the delimiter\n            relax: true,\n            // allow using quotes without escaping inside unquoted string\n            relax_column_count: true,\n            // ignore inconsistent columns count\n            bom: true // strip the byte order mark (BOM) from the input string\n          }, cb);\n        }], (err, parsed) => {\n          if (err) {\n            return callback(new Error(ITERATION_DATA_LOAD_ERROR_MESSAGE + `\\n ${err.message || err}`));\n          }\n          callback(null, parsed);\n        });\n      });\n    },\n    sslClientCertList: function (location, options, callback) {\n      if (Array.isArray(location)) {\n        return callback(null, location);\n      }\n      if (typeof location !== 'string') {\n        return callback(new Error('path for ssl client certificates list file must be a string'));\n      }\n      fs.readFile(location, function (err, value) {\n        if (err) {\n          return callback(new Error(`unable to read the ssl client certificates file \"${location}\"`));\n        }\n        try {\n          value = liquidJSON.parse(value.toString(util.detectEncoding(value)).trim());\n        } catch (e) {\n          return callback(new Error(`the file at ${location} does not contain valid JSON data.`));\n        }\n\n        // ensure that `sslClientCertList` is an array\n        if (!Array.isArray(value)) {\n          return callback(new Error('expected ssl client certificates list to be an array.'));\n        }\n        return callback(null, value);\n      });\n    },\n    cookieJar: function (location, options, callback) {\n      if (_.isObject(location) && location.constructor.name === 'CookieJar') {\n        return callback(null, location);\n      }\n      if (typeof location !== 'string') {\n        return callback(new Error('cookieJar must be a path to a JSON file or a CookieJar instance'));\n      }\n      fs.readFile(location, function (err, value) {\n        if (err) {\n          return callback(new Error(`unable to read the cookie jar file \"${location}\"`));\n        }\n        try {\n          value = CookieJar.fromJSON(value.toString());\n        } catch (e) {\n          return callback(new Error(`the file at ${location} does not contain valid JSON data.`));\n        }\n        return callback(null, value);\n      });\n    }\n  };\n\n/**\n * The helper function to load all file based information for the current collection run.\n *\n * @param {Object} options - The set of generic collection run options.\n * @param {Function} callback - The function called to mark the completion of the configuration load routine.\n * @returns {*}\n */\nmodule.exports = function (options, callback) {\n  // set newman version used for collection run\n  options.newmanVersion = util.version;\n\n  // set working directory if not provided\n  options.workingDir = options.workingDir || process.cwd();\n\n  // allow insecure file read by default\n  options.insecureFileRead = Boolean(_.get(options, 'insecureFileRead', true));\n  config.get(options, {\n    loaders: configLoaders,\n    command: 'run'\n  }, function (err, result) {\n    if (err) {\n      return callback(err);\n    }\n    !_.isEmpty(options.globalVar) && _.forEach(options.globalVar, function (variable) {\n      variable && result.globals.set(variable.key, variable.value);\n    });\n    !_.isEmpty(options.envVar) && _.forEach(options.envVar, function (variable) {\n      variable && result.environment.set(variable.key, variable.value);\n    });\n    callback(null, result);\n  });\n};","map":{"version":3,"names":["_","require","fs","async","Collection","VariableScope","CookieJar","transformer","liquidJSON","parseCsv","util","config","COLLECTION_LOAD_ERROR_MESSAGE","ITERATION_DATA_LOAD_ERROR_MESSAGE","LOAD_ERROR_MESSAGE","COLLECTION_TRANSFORMER_OPTION","inputVersion","outputVersion","extractModel","source","type","isObject","undefined","values","externalLoader","location","options","cb","isString","fetchJson","err","data","processCollection","collection","callback","isV1Collection","console","warn","convert","loadScopes","value","done","scope","Error","message","isVariableScope","toJSON","csvAutoParse","context","quoting","isInt","parseInt","isFloat","parseFloat","configLoaders","isCollection","help","environment","bind","globals","folder","length","Array","isArray","iterationData","fetch","waterfall","parse","trim","e","json","columns","escape","cast","relax","relax_column_count","bom","parsed","sslClientCertList","readFile","toString","detectEncoding","cookieJar","constructor","name","fromJSON","module","exports","newmanVersion","version","workingDir","process","cwd","insecureFileRead","Boolean","get","loaders","command","result","isEmpty","globalVar","forEach","variable","set","key","envVar"],"sources":["/Users/Qusai.Qishta/node_modules/newman/lib/run/options.js"],"sourcesContent":["var _ = require('lodash'),\n    fs = require('fs'),\n    async = require('async'),\n    Collection = require('postman-collection').Collection,\n    VariableScope = require('postman-collection').VariableScope,\n    CookieJar = require('tough-cookie').CookieJar,\n    transformer = require('postman-collection-transformer'),\n    liquidJSON = require('liquid-json'),\n    parseCsv = require('csv-parse'),\n    util = require('../util'),\n    config = require('../config'),\n\n    /**\n     * The message displayed when the specified collection file can't be loaded.\n     *\n     * @const\n     * @type {String}\n     */\n    COLLECTION_LOAD_ERROR_MESSAGE = 'collection could not be loaded',\n\n    /**\n     * The message displayed when the specified iteration data file can't be loaded.\n     *\n     * @const\n     * @type {String}\n     */\n    ITERATION_DATA_LOAD_ERROR_MESSAGE = 'iteration data could not be loaded',\n\n    /**\n     * The message displayed when the specified environment or globals file can't be loaded.\n     *\n     * @const\n     * @type {String}\n     */\n    LOAD_ERROR_MESSAGE = 'could not load ',\n\n    /**\n     * The set of postman collection transformer options, to convert collection v1 to collection v2.\n     *\n     * @const\n     * @type {Object}\n     */\n    COLLECTION_TRANSFORMER_OPTION = { inputVersion: '1.0.0', outputVersion: '2.1.0' },\n\n    /**\n     * Accepts an object, and extracts the property inside an object which is supposed to contain the required data.\n     * In case of variables, it also extracts them into plain JS objects.\n     *\n     * @param {Object} source - The source wrapper object that may or may not contain inner wrapped properties.\n     * @param {String} type - \"environment\" or \"globals\", etc.\n     * @returns {Object} - The object representation of the current extracted property.\n     */\n    extractModel = function (source, type) {\n        source = source[type] || source; // extract object that holds variable. these usually come from cloud API\n        if (!_.isObject(source)) {\n            return undefined;\n        }\n\n        // ensure we un-box the JSON if it comes from cloud-api or similar sources\n        !source.values && _.isObject(source[type]) && (source = source[type]);\n\n        // we ensure that environment passed as array is converted to plain object. runtime does this too, but we do it\n        // here for consistency of options passed to reporters\n        return source;\n    },\n\n    /**\n     * Loads the given data of type from a specified external location\n     *\n     * @param {String} type - The type of data to load.\n     * @param {String} location - The location to load from (file path or URL).\n     * @param {Object} options - The set of wrapped options.\n     * @param {function} cb - The callback function whose invocation marks the end of the external load routine.\n     * @returns {*}\n     */\n    externalLoader = function (type, location, options, cb) {\n        return _.isString(location) ? util.fetchJson(type, location, options, function (err, data) {\n            if (err) {\n                return cb(err);\n            }\n\n            return cb(null, extractModel(data, type));\n        }) : cb(null, extractModel(location, type));\n    },\n\n    /**\n     * A helper method to process a collection and convert it to a V2 equivalent if necessary, and return it.\n     *\n     * @todo Drop support for the v1 collection format in Newman v5.\n     * Reference: https://github.com/postmanlabs/newman/pull/1660\n     *\n     * @param {Object} collection The input collection, specified as a JSON object.\n     * @param {Function} callback A handler function that consumes an error object and the processed collection.\n     * @returns {*}\n     */\n    processCollection = function (collection, callback) {\n        if (util.isV1Collection(collection)) {\n            // @todo: route this via print module to respect silent flags\n            console.warn('newman: Newman v4 deprecates support for the v1 collection format');\n            console.warn('  Use the Postman Native app to export collections in the v2 format\\n');\n\n            return transformer.convert(collection, COLLECTION_TRANSFORMER_OPTION, callback);\n        }\n\n        callback(null, collection);\n    },\n\n    /**\n     * Helper function that manages the load of environments and globals\n     *\n     * @private\n     * @param {String} type - The type of resource to load: collection, environment, etc.\n     * @param {String|Object} value - The value derived from the CLI or run command.\n     * @param {Object} options - The set of wrapped options.\n     * @param {Function} callback - The function invoked when the scope has been loaded.\n     */\n    loadScopes = function (type, value, options, callback) {\n        var done = function (err, scope) {\n            if (err) { return callback(new Error(LOAD_ERROR_MESSAGE + `${type}\\n  ${err.message || err}`)); }\n\n            if (!_.isObject(scope)) {\n                return done(new Error(LOAD_ERROR_MESSAGE + type));\n            }\n\n            callback(null, new VariableScope(VariableScope.isVariableScope(scope) ? scope.toJSON() : scope));\n        };\n\n        if (_.isObject(value)) {\n            return done(null, value);\n        }\n\n        externalLoader(type, value, options, done);\n    },\n\n    /**\n     * Custom method to auto parse CSV values\n     *\n     * @private\n     * @param {String} value - CSV field value\n     * @param {Object} context - Context of field value\n     * @param {Boolean} context.quoting - A boolean indicating if the field was surrounded by quotes.\n     * @returns {String|Number|Date}\n     */\n    csvAutoParse = function (value, context) {\n        if (context.quoting) {\n            // avoid parsing quoted values\n            return value;\n        }\n\n        if (util.isInt(value)) {\n            return parseInt(value, 10);\n        }\n\n        if (util.isFloat(value)) {\n            return parseFloat(value);\n        }\n\n        return value;\n    },\n\n    /**\n     * Custom configuration loaders for the required configuration keys.\n     *\n     * @type {Object}\n     */\n    configLoaders = {\n\n        /**\n         * The collection file load helper for the current run.\n         *\n         * @param {Object|String} value - The collection, specified as a JSON object, or the path to it's file.\n         * @param {Object} options - The set of wrapped options.\n         * @param {Function} callback - The callback function invoked to mark the end of the collection load routine.\n         * @returns {*}\n         */\n        collection: function (value, options, callback) {\n            /**\n             * The post collection load handler.\n             *\n             * @param {?Error} err - An Error instance / null, passed from the collection loader.\n             * @param {Object} collection - The collection / raw JSON object, passed from the collection loader.\n             * @returns {*}\n             */\n            var done = function (err, collection) {\n                if (err) {\n                    return callback(err);\n                }\n\n                // ensure that the collection option is present before starting a run\n                if (!_.isObject(collection)) {\n                    return callback(new Error(COLLECTION_LOAD_ERROR_MESSAGE));\n                }\n\n                // ensure that the collection reference is an SDK instance\n                // @todo - should this be handled by config loaders?\n                collection = new Collection(Collection.isCollection(collection) ?\n                    // if the option contain an instance of collection, we simply clone it for future use\n                    // create a collection in case it is not one. user can send v2 JSON as a source and that will be\n                    // converted to a collection\n                    collection.toJSON() : collection);\n\n                callback(null, collection);\n            };\n\n            // if the collection has been specified as an object, convert to V2 if necessary and return the result\n            if (_.isObject(value)) {\n                return processCollection(value, done);\n            }\n\n            externalLoader('collection', value, options, function (err, data) {\n                if (err) {\n                    return done(new Error(COLLECTION_LOAD_ERROR_MESSAGE +\n                        (err.help ? `\\n  ${err.help}` : '') +\n                        `\\n  ${err.message || err}`));\n                }\n                if (!_.isObject(data)) {\n                    return done(new Error(COLLECTION_LOAD_ERROR_MESSAGE));\n                }\n\n                return processCollection(data, done);\n            });\n        },\n\n        /**\n         * The environment configuration object, loaded for the current collection run.\n         *\n         * @type {Object}\n         */\n        environment: loadScopes.bind(this, 'environment'),\n\n        /**\n         * The object of globals, loaded for the collection run.\n         *\n         * @type {Object}\n         */\n        globals: loadScopes.bind(this, 'globals'),\n\n        /**\n         * Helper function to sanitize folder option.\n         *\n         * @param {String[]|String} value - The list of folders to execute\n         * @param {Object} options - The set of wrapped options.\n         * @param {Function} callback - The callback function invoked to mark the end of the folder load routine.\n         * @returns {*}\n         */\n        folder: function (value, options, callback) {\n            if (!value.length) {\n                return callback(); // avoids empty string or array\n            }\n\n            if (Array.isArray(value) && value.length === 1) {\n                return callback(null, value[0]); // avoids using multipleIdOrName strategy for a single item array\n            }\n\n            callback(null, value);\n        },\n\n        /**\n         * The iterationData loader module, with support for JSON or CSV data files.\n         *\n         * @param {String|Object[]} location - The path to the iteration data file for the current collection run, or\n         * the array of iteration data objects.\n         * @param {Object} options - The set of wrapped options.\n         * @param {Function} callback - The function invoked to indicate the end of the iteration data loading routine.\n         * @returns {*}\n         */\n        iterationData: function (location, options, callback) {\n            if (_.isArray(location)) { return callback(null, location); }\n\n            util.fetch(location, function (err, data) {\n                if (err) {\n                    return callback(new Error(ITERATION_DATA_LOAD_ERROR_MESSAGE + `\\n  ${err.message || err}`));\n                }\n\n                // Try loading as a JSON, fall-back to CSV.\n                async.waterfall([\n                    (cb) => {\n                        try {\n                            return cb(null, liquidJSON.parse(data.trim()));\n                        }\n                        catch (e) {\n                            return cb(null, undefined); // e masked to avoid displaying JSON parse errors for CSV files\n                        }\n                    },\n                    (json, cb) => {\n                        if (json) {\n                            return cb(null, json);\n                        }\n                        // Wasn't JSON\n                        parseCsv(data, {\n                            columns: true, // infer the columns names from the first row\n                            escape: '\"', // escape character\n                            cast: csvAutoParse, // function to cast values of individual fields\n                            trim: true, // ignore whitespace immediately around the delimiter\n                            relax: true, // allow using quotes without escaping inside unquoted string\n                            relax_column_count: true, // ignore inconsistent columns count\n                            bom: true // strip the byte order mark (BOM) from the input string\n                        }, cb);\n                    }\n                ], (err, parsed) => {\n                    if (err) {\n                        return callback(new Error(ITERATION_DATA_LOAD_ERROR_MESSAGE + `\\n ${err.message || err}`));\n                    }\n\n                    callback(null, parsed);\n                });\n            });\n        },\n\n        sslClientCertList: function (location, options, callback) {\n            if (Array.isArray(location)) {\n                return callback(null, location);\n            }\n\n            if (typeof location !== 'string') {\n                return callback(new Error('path for ssl client certificates list file must be a string'));\n            }\n\n            fs.readFile(location, function (err, value) {\n                if (err) {\n                    return callback(new Error(`unable to read the ssl client certificates file \"${location}\"`));\n                }\n\n                try {\n                    value = liquidJSON.parse(value.toString(util.detectEncoding(value)).trim());\n                }\n                catch (e) {\n                    return callback(new Error(`the file at ${location} does not contain valid JSON data.`));\n                }\n\n                // ensure that `sslClientCertList` is an array\n                if (!Array.isArray(value)) {\n                    return callback(new Error('expected ssl client certificates list to be an array.'));\n                }\n\n                return callback(null, value);\n            });\n        },\n\n        cookieJar: function (location, options, callback) {\n            if (_.isObject(location) && location.constructor.name === 'CookieJar') {\n                return callback(null, location);\n            }\n\n            if (typeof location !== 'string') {\n                return callback(new Error('cookieJar must be a path to a JSON file or a CookieJar instance'));\n            }\n\n            fs.readFile(location, function (err, value) {\n                if (err) {\n                    return callback(new Error(`unable to read the cookie jar file \"${location}\"`));\n                }\n\n                try {\n                    value = CookieJar.fromJSON(value.toString());\n                }\n                catch (e) {\n                    return callback(new Error(`the file at ${location} does not contain valid JSON data.`));\n                }\n\n                return callback(null, value);\n            });\n        }\n    };\n\n/**\n * The helper function to load all file based information for the current collection run.\n *\n * @param {Object} options - The set of generic collection run options.\n * @param {Function} callback - The function called to mark the completion of the configuration load routine.\n * @returns {*}\n */\nmodule.exports = function (options, callback) {\n    // set newman version used for collection run\n    options.newmanVersion = util.version;\n\n    // set working directory if not provided\n    options.workingDir = options.workingDir || process.cwd();\n\n    // allow insecure file read by default\n    options.insecureFileRead = Boolean(_.get(options, 'insecureFileRead', true));\n\n    config.get(options, { loaders: configLoaders, command: 'run' }, function (err, result) {\n        if (err) { return callback(err); }\n\n        !_.isEmpty(options.globalVar) && _.forEach(options.globalVar, function (variable) {\n            variable && (result.globals.set(variable.key, variable.value));\n        });\n\n        !_.isEmpty(options.envVar) && _.forEach(options.envVar, function (variable) {\n            variable && (result.environment.set(variable.key, variable.value));\n        });\n\n        callback(null, result);\n    });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}