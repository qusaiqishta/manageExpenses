{"ast":null,"code":"var _ = require('lodash'),\n  meetExpectations,\n  backpack;\n\n/**\n * ensure the specified keys are functions in subject\n *\n * @param {Object} subject -\n * @param {Array} expectations -\n * @param {Array=} [defaults] -\n * @returns {Object}\n */\nmeetExpectations = function (subject, expectations, defaults) {\n  // provided that the subject is an object, we meet expectations that the keys in array must be a function\n  // eslint-disable-next-line lodash/prefer-lodash-chain\n  _.isObject(subject) && _.union(defaults, expectations).forEach(function (expect) {\n    !_.isFunction(subject[expect]) && (subject[expect] = _.noop);\n  });\n  return subject;\n};\nmodule.exports = backpack = {\n  /**\n   * Ensures that the given argument is a callable.\n   *\n   * @param {*} arg -\n   * @param {Object=} ctx -\n   * @returns {boolean|*}\n   */\n  ensure(arg, ctx) {\n    return typeof arg === 'function' && (ctx ? arg.bind(ctx) : arg) || undefined;\n  },\n  /**\n   * accept the callback parameter and convert it into a consistent object interface\n   *\n   * @param {Function|Object} cb -\n   * @param {Array} expect -\n   * @returns {Object}\n   *\n   * @todo - write tests\n   */\n  normalise(cb, expect) {\n    if (_.isFunction(cb) && cb.__normalised) {\n      return meetExpectations(cb, expect);\n    }\n    var userback,\n      // this var will be populated and returned\n      // keep a reference of all initial callbacks sent by user\n      callback = _.isFunction(cb) && cb || _.isFunction(cb && cb.done) && cb.done,\n      callbackError = _.isFunction(cb && cb.error) && cb.error,\n      callbackSuccess = _.isFunction(cb && cb.success) && cb.success;\n\n    // create master callback that calls these user provided callbacks\n    userback = _.assign(function (err) {\n      // if common callback is defined, call that\n      callback && callback.apply(this, arguments);\n\n      // for special error and success, call them if they are user defined\n      if (err) {\n        callbackError && callbackError.apply(this, arguments);\n      } else {\n        // remove the extra error param before calling success\n        callbackSuccess && callbackSuccess.apply(this, (Array.prototype.shift.call(arguments), arguments));\n      }\n    }, _.isPlainObject(cb) && cb, {\n      // override error, success and done\n      error: function () {\n        return userback.apply(this, arguments);\n      },\n      success: function () {\n        // inject null to arguments and call the main callback\n        userback.apply(this, (Array.prototype.unshift.call(arguments, null), arguments));\n      },\n      done: function () {\n        return userback.apply(this, arguments);\n      },\n      __normalised: true\n    });\n    return meetExpectations(userback, expect);\n  },\n  /**\n   * Convert a callback into a function that is called multiple times and the callback is actually called when a set\n   * of flags are set to true\n   *\n   * @param {Array} flags -\n   * @param {Function} callback -\n   * @param {Array} args -\n   * @param {Number} ms -\n   * @returns {Function}\n   */\n  multiback(flags, callback, args, ms) {\n    var status = {},\n      sealed;\n\n    // ensure that the callback times out after a while\n    callback = backpack.timeback(callback, ms, null, function () {\n      sealed = true;\n    });\n    return function (err, flag, value) {\n      if (sealed) {\n        return;\n      } // do  not proceed of it is sealed\n      status[flag] = value;\n      if (err) {\n        // on error we directly call the callback and seal subsequent calls\n        sealed = true;\n        status = null;\n        callback.call(status, err);\n        return;\n      }\n\n      // if any flag is not defined, we exit. when all flags hold a value, we know that the end callback has to be\n      // executed.\n      for (var i = 0, ii = flags.length; i < ii; i++) {\n        if (!Object.hasOwnProperty.call(status, flags[i])) {\n          return;\n        }\n      }\n      sealed = true;\n      status = null;\n      callback.apply(status, args);\n    };\n  },\n  /**\n   * Ensures that a callback is executed within a specific time.\n   *\n   * @param {Function} callback -\n   * @param {Number=} [ms] -\n   * @param {Object=} [scope] -\n   * @param {Function=} [when] - function executed right before callback is called with timeout. one can do cleanup\n   * stuff here\n   * @returns {Function}\n   */\n  timeback(callback, ms, scope, when) {\n    ms = Number(ms);\n\n    // if np callback time is specified, just return the callback function and exit. this is because we do need to\n    // track timeout in 0ms\n    if (!ms) {\n      return callback;\n    }\n    var sealed = false,\n      irq = setTimeout(function () {\n        // irq = interrupt request\n        sealed = true;\n        irq = null;\n        when && when.call(scope || this);\n        callback.call(scope || this, new Error('callback timed out'));\n      }, ms);\n    return function () {\n      // if sealed, it means that timeout has elapsed and we accept no future callback\n      if (sealed) {\n        return undefined;\n      }\n\n      // otherwise we clear timeout and allow the callback to be executed. note that we do not seal the function\n      // since we should allow multiple callback calls.\n      irq && (irq = clearTimeout(irq));\n      return callback.apply(scope || this, arguments);\n    };\n  }\n};","map":{"version":3,"names":["_","require","meetExpectations","backpack","subject","expectations","defaults","isObject","union","forEach","expect","isFunction","noop","module","exports","ensure","arg","ctx","bind","undefined","normalise","cb","__normalised","userback","callback","done","callbackError","error","callbackSuccess","success","assign","err","apply","arguments","Array","prototype","shift","call","isPlainObject","unshift","multiback","flags","args","ms","status","sealed","timeback","flag","value","i","ii","length","Object","hasOwnProperty","scope","when","Number","irq","setTimeout","Error","clearTimeout"],"sources":["/Users/Qusai.Qishta/node_modules/postman-runtime/lib/backpack/index.js"],"sourcesContent":["var _ = require('lodash'),\n    meetExpectations,\n    backpack;\n\n/**\n * ensure the specified keys are functions in subject\n *\n * @param {Object} subject -\n * @param {Array} expectations -\n * @param {Array=} [defaults] -\n * @returns {Object}\n */\nmeetExpectations = function (subject, expectations, defaults) {\n    // provided that the subject is an object, we meet expectations that the keys in array must be a function\n    // eslint-disable-next-line lodash/prefer-lodash-chain\n    _.isObject(subject) && _.union(defaults, expectations).forEach(function (expect) {\n        !_.isFunction(subject[expect]) && (subject[expect] = _.noop);\n    });\n\n    return subject;\n};\n\nmodule.exports = backpack = {\n    /**\n     * Ensures that the given argument is a callable.\n     *\n     * @param {*} arg -\n     * @param {Object=} ctx -\n     * @returns {boolean|*}\n     */\n    ensure (arg, ctx) {\n        return (typeof arg === 'function') && (ctx ? arg.bind(ctx) : arg) || undefined;\n    },\n\n    /**\n     * accept the callback parameter and convert it into a consistent object interface\n     *\n     * @param {Function|Object} cb -\n     * @param {Array} expect -\n     * @returns {Object}\n     *\n     * @todo - write tests\n     */\n    normalise (cb, expect) {\n        if (_.isFunction(cb) && cb.__normalised) {\n            return meetExpectations(cb, expect);\n        }\n\n        var userback, // this var will be populated and returned\n            // keep a reference of all initial callbacks sent by user\n            callback = (_.isFunction(cb) && cb) || (_.isFunction(cb && cb.done) && cb.done),\n            callbackError = _.isFunction(cb && cb.error) && cb.error,\n            callbackSuccess = _.isFunction(cb && cb.success) && cb.success;\n\n        // create master callback that calls these user provided callbacks\n        userback = _.assign(function (err) {\n            // if common callback is defined, call that\n            callback && callback.apply(this, arguments);\n\n            // for special error and success, call them if they are user defined\n            if (err) {\n                callbackError && callbackError.apply(this, arguments);\n            }\n            else {\n                // remove the extra error param before calling success\n                callbackSuccess && callbackSuccess.apply(this, (Array.prototype.shift.call(arguments), arguments));\n            }\n        }, _.isPlainObject(cb) && cb, { // override error, success and done\n            error: function () {\n                return userback.apply(this, arguments);\n            },\n            success: function () {\n                // inject null to arguments and call the main callback\n                userback.apply(this, (Array.prototype.unshift.call(arguments, null), arguments));\n            },\n            done: function () {\n                return userback.apply(this, arguments);\n            },\n            __normalised: true\n        });\n\n        return meetExpectations(userback, expect);\n    },\n\n    /**\n     * Convert a callback into a function that is called multiple times and the callback is actually called when a set\n     * of flags are set to true\n     *\n     * @param {Array} flags -\n     * @param {Function} callback -\n     * @param {Array} args -\n     * @param {Number} ms -\n     * @returns {Function}\n     */\n    multiback (flags, callback, args, ms) {\n        var status = {},\n            sealed;\n\n        // ensure that the callback times out after a while\n        callback = backpack.timeback(callback, ms, null, function () {\n            sealed = true;\n        });\n\n        return function (err, flag, value) {\n            if (sealed) { return; } // do  not proceed of it is sealed\n            status[flag] = value;\n\n            if (err) { // on error we directly call the callback and seal subsequent calls\n                sealed = true;\n                status = null;\n                callback.call(status, err);\n\n                return;\n            }\n\n            // if any flag is not defined, we exit. when all flags hold a value, we know that the end callback has to be\n            // executed.\n            for (var i = 0, ii = flags.length; i < ii; i++) {\n                if (!Object.hasOwnProperty.call(status, flags[i])) { return; }\n            }\n\n            sealed = true;\n            status = null;\n            callback.apply(status, args);\n        };\n    },\n\n    /**\n     * Ensures that a callback is executed within a specific time.\n     *\n     * @param {Function} callback -\n     * @param {Number=} [ms] -\n     * @param {Object=} [scope] -\n     * @param {Function=} [when] - function executed right before callback is called with timeout. one can do cleanup\n     * stuff here\n     * @returns {Function}\n     */\n    timeback (callback, ms, scope, when) {\n        ms = Number(ms);\n\n        // if np callback time is specified, just return the callback function and exit. this is because we do need to\n        // track timeout in 0ms\n        if (!ms) {\n            return callback;\n        }\n\n        var sealed = false,\n            irq = setTimeout(function () { // irq = interrupt request\n                sealed = true;\n                irq = null;\n                when && when.call(scope || this);\n                callback.call(scope || this, new Error('callback timed out'));\n            }, ms);\n\n        return function () {\n            // if sealed, it means that timeout has elapsed and we accept no future callback\n            if (sealed) { return undefined; }\n\n            // otherwise we clear timeout and allow the callback to be executed. note that we do not seal the function\n            // since we should allow multiple callback calls.\n            irq && (irq = clearTimeout(irq));\n\n            return callback.apply(scope || this, arguments);\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}