{"ast":null,"code":"var _ = require('lodash'),\n  uuid = require('uuid'),\n  Response = require('postman-collection').Response,\n  visualizer = require('../../visualizer'),\n  /**\n   * List of request properties which can be mutated via pre-request\n   *\n   * @private\n   * @const\n   * @type {String[]}\n   */\n  ALLOWED_REQUEST_MUTATIONS = ['url', 'method', 'headers', 'body'],\n  extractVisualizerData,\n  getResponseJSON;\n\n/**\n * Returns visualizer data from the latest execution result.\n *\n * @param {Array} prereqExecutions - pre-script executions results\n * @param {Array} testExecutions - test-script executions results\n * @returns {Object|undefined} - visualizer data\n */\nextractVisualizerData = function (prereqExecutions, testExecutions) {\n  var visualizerData, i;\n  if (_.isArray(testExecutions)) {\n    // loop through the test executions in reverse order to return data from latest execution\n    for (i = testExecutions.length - 1; i >= 0; i--) {\n      visualizerData = _.get(testExecutions[i], 'result.return.visualizer');\n      if (visualizerData) {\n        return visualizerData;\n      }\n    }\n  }\n  if (_.isArray(prereqExecutions)) {\n    // extract visualizer data from pre-request script results if it is not found earlier\n    for (i = prereqExecutions.length - 1; i >= 0; i--) {\n      visualizerData = _.get(prereqExecutions[i], 'result.return.visualizer');\n      if (visualizerData) {\n        return visualizerData;\n      }\n    }\n  }\n};\n\n/**\n * Convert response into a JSON serializable object.\n * The stream property is converted to base64 string for performance reasons.\n *\n * @param {Object} response - SDK Response instance\n * @returns {Object}\n */\ngetResponseJSON = function (response) {\n  if (!Response.isResponse(response)) {\n    return;\n  }\n  return {\n    id: response.id,\n    code: response.code,\n    status: response.status,\n    header: response.headers && response.headers.toJSON(),\n    stream: response.stream && {\n      type: 'Base64',\n      data: response.stream.toString('base64')\n    },\n    responseTime: response.responseTime\n  };\n};\n\n/**\n * Add options\n * stopOnError:Boolean\n *\n * @type {Object}\n */\nmodule.exports = {\n  init: function (done) {\n    // @todo - code item global timeout and delay here\n    done();\n  },\n  triggers: ['beforeItem', 'item', 'beforePrerequest', 'prerequest', 'beforeTest', 'test'],\n  process: {\n    /**\n     * @param {Function=} callback -\n     * @param {Object} payload -\n     * @param {Function} next -\n     * @todo  validate payload\n     */\n    item(callback, payload, next) {\n      // adjust for polymorphic instructions\n      if (!next && _.isFunction(payload) && !_.isFunction(callback)) {\n        next = payload;\n        payload = callback;\n        callback = null;\n      }\n      var item = payload.item,\n        originalRequest = item.request.clone(),\n        coords = payload.coords,\n        data = _.isObject(payload.data) ? payload.data : {},\n        environment = _.isObject(payload.environment) ? payload.environment : {},\n        globals = _.isObject(payload.globals) ? payload.globals : {},\n        collectionVariables = _.isObject(payload.collectionVariables) ? payload.collectionVariables : {},\n        _variables = _.isObject(payload._variables) ? payload._variables : {},\n        stopOnError = _.has(payload, 'stopOnError') ? payload.stopOnError : this.options.stopOnError,\n        // @todo: this is mostly coded in event extension and we are\n        // still not sure whether that is the right place for it to be.\n        abortOnFailure = this.options.abortOnFailure,\n        stopOnFailure = this.options.stopOnFailure,\n        delay = _.get(this.options, 'delay.item'),\n        ctxTemplate;\n\n      // validate minimum parameters required for the command to work\n      if (!(item && coords)) {\n        return next(new Error('runtime: item execution is missing required parameters'));\n      }\n\n      // store a common uuid in the coords\n      coords.ref = uuid.v4();\n\n      // here we code to queue prerequest script, then make a request and then execute test script\n      this.triggers.beforeItem(null, coords, item);\n      this.queueDelay(function () {\n        // create the context object for scripts to run\n        ctxTemplate = {\n          collectionVariables: collectionVariables,\n          _variables: _variables,\n          globals: globals,\n          environment: environment,\n          data: data,\n          request: item.request\n        };\n\n        // @todo make it less nested by coding Instruction.thenQueue\n        this.queue('event', {\n          name: 'prerequest',\n          item: item,\n          coords: coords,\n          context: ctxTemplate,\n          trackContext: ['globals', 'environment', 'collectionVariables'],\n          stopOnScriptError: stopOnError,\n          stopOnFailure: stopOnFailure\n        }).done(function (prereqExecutions, prereqExecutionError) {\n          // if stop on error is marked and script executions had an error,\n          // do not proceed with more commands, instead we bail out\n          if ((stopOnError || stopOnFailure) && prereqExecutionError) {\n            this.triggers.item(null, coords, item); // @todo - should this trigger receive error?\n\n            return callback && callback.call(this, prereqExecutionError, {\n              prerequest: prereqExecutions\n            });\n          }\n\n          // update allowed request mutation properties with the mutated context\n          // @note from this point forward, make sure this mutated\n          // request instance is used for upcoming commands.\n          ALLOWED_REQUEST_MUTATIONS.forEach(function (property) {\n            if (_.has(ctxTemplate, ['request', property])) {\n              item.request[property] = ctxTemplate.request[property];\n            }\n\n            // update property's parent reference\n            if (item.request[property] && typeof item.request[property].setParent === 'function') {\n              item.request[property].setParent(item.request);\n            }\n          });\n          this.queue('request', {\n            item: item,\n            globals: ctxTemplate.globals,\n            environment: ctxTemplate.environment,\n            collectionVariables: ctxTemplate.collectionVariables,\n            _variables: ctxTemplate._variables,\n            data: ctxTemplate.data,\n            coords: coords,\n            source: 'collection'\n          }).done(function (result, requestError) {\n            !result && (result = {});\n            var request = result.request,\n              response = result.response,\n              cookies = result.cookies;\n            if ((stopOnError || stopOnFailure) && requestError) {\n              this.triggers.item(null, coords, item); // @todo - should this trigger receive error?\n\n              return callback && callback.call(this, requestError, {\n                request\n              });\n            }\n\n            // also the test object requires the updated request object (since auth helpers may modify it)\n            request && (ctxTemplate.request = request);\n\n            // @note convert response instance to plain object.\n            // we want to avoid calling Response.toJSON() which triggers toJSON on Response.stream buffer.\n            // Because that increases the size of stringified object by 3 times.\n            // Also, that increases the total number of tokens (buffer.data) whereas Buffer.toString\n            // generates a single string that is easier to stringify and sent over the UVM bridge.\n            response && (ctxTemplate.response = getResponseJSON(response));\n\n            // set cookies for this transaction\n            cookies && (ctxTemplate.cookies = cookies);\n\n            // the context template also has a test object to store assertions\n            ctxTemplate.tests = {}; // @todo remove\n\n            this.queue('event', {\n              name: 'test',\n              item: item,\n              coords: coords,\n              context: ctxTemplate,\n              trackContext: ['tests', 'globals', 'environment', 'collectionVariables'],\n              stopOnScriptError: stopOnError,\n              abortOnFailure: abortOnFailure,\n              stopOnFailure: stopOnFailure\n            }).done(function (testExecutions, testExecutionError) {\n              var visualizerData = extractVisualizerData(prereqExecutions, testExecutions),\n                visualizerResult;\n              if (visualizerData) {\n                visualizer.processTemplate(visualizerData.template, visualizerData.data, visualizerData.options, function (err, processedTemplate) {\n                  visualizerResult = {\n                    // bubble up the errors while processing template through visualizer result\n                    error: err,\n                    // add processed template and data to visualizer result\n                    processedTemplate: processedTemplate,\n                    data: visualizerData.data\n                  };\n\n                  // trigger an event saying that item has been processed\n                  this.triggers.item(null, coords, item, visualizerResult);\n                }.bind(this));\n              } else {\n                // trigger an event saying that item has been processed\n                // @todo - should this trigger receive error?\n                this.triggers.item(null, coords, item, null);\n              }\n\n              // reset mutated request with original request instance\n              // @note request mutations are not persisted across iterations\n              item.request = originalRequest;\n              callback && callback.call(this, (stopOnError || stopOnFailure) && testExecutionError ? testExecutionError : null, {\n                prerequest: prereqExecutions,\n                request: request,\n                response: response,\n                test: testExecutions\n              });\n            });\n          });\n        });\n      }.bind(this), {\n        time: delay,\n        source: 'item',\n        cursor: coords\n      }, next);\n    }\n  }\n};","map":{"version":3,"names":["_","require","uuid","Response","visualizer","ALLOWED_REQUEST_MUTATIONS","extractVisualizerData","getResponseJSON","prereqExecutions","testExecutions","visualizerData","i","isArray","length","get","response","isResponse","id","code","status","header","headers","toJSON","stream","type","data","toString","responseTime","module","exports","init","done","triggers","process","item","callback","payload","next","isFunction","originalRequest","request","clone","coords","isObject","environment","globals","collectionVariables","_variables","stopOnError","has","options","abortOnFailure","stopOnFailure","delay","ctxTemplate","Error","ref","v4","beforeItem","queueDelay","queue","name","context","trackContext","stopOnScriptError","prereqExecutionError","call","prerequest","forEach","property","setParent","source","result","requestError","cookies","tests","testExecutionError","visualizerResult","processTemplate","template","err","processedTemplate","error","bind","test","time","cursor"],"sources":["/Users/Qusai.Qishta/node_modules/postman-runtime/lib/runner/extensions/item.command.js"],"sourcesContent":["var _ = require('lodash'),\n    uuid = require('uuid'),\n    Response = require('postman-collection').Response,\n    visualizer = require('../../visualizer'),\n\n    /**\n     * List of request properties which can be mutated via pre-request\n     *\n     * @private\n     * @const\n     * @type {String[]}\n     */\n    ALLOWED_REQUEST_MUTATIONS = ['url', 'method', 'headers', 'body'],\n\n    extractVisualizerData,\n    getResponseJSON;\n\n/**\n * Returns visualizer data from the latest execution result.\n *\n * @param {Array} prereqExecutions - pre-script executions results\n * @param {Array} testExecutions - test-script executions results\n * @returns {Object|undefined} - visualizer data\n */\nextractVisualizerData = function (prereqExecutions, testExecutions) {\n    var visualizerData,\n        i;\n\n    if (_.isArray(testExecutions)) {\n        // loop through the test executions in reverse order to return data from latest execution\n        for (i = testExecutions.length - 1; i >= 0; i--) {\n            visualizerData = _.get(testExecutions[i], 'result.return.visualizer');\n\n            if (visualizerData) {\n                return visualizerData;\n            }\n        }\n    }\n\n    if (_.isArray(prereqExecutions)) {\n        // extract visualizer data from pre-request script results if it is not found earlier\n        for (i = prereqExecutions.length - 1; i >= 0; i--) {\n            visualizerData = _.get(prereqExecutions[i], 'result.return.visualizer');\n\n            if (visualizerData) {\n                return visualizerData;\n            }\n        }\n    }\n};\n\n/**\n * Convert response into a JSON serializable object.\n * The stream property is converted to base64 string for performance reasons.\n *\n * @param {Object} response - SDK Response instance\n * @returns {Object}\n */\ngetResponseJSON = function (response) {\n    if (!Response.isResponse(response)) {\n        return;\n    }\n\n    return {\n        id: response.id,\n        code: response.code,\n        status: response.status,\n        header: response.headers && response.headers.toJSON(),\n        stream: response.stream && {\n            type: 'Base64',\n            data: response.stream.toString('base64')\n        },\n        responseTime: response.responseTime\n    };\n};\n\n/**\n * Add options\n * stopOnError:Boolean\n *\n * @type {Object}\n */\nmodule.exports = {\n    init: function (done) {\n        // @todo - code item global timeout and delay here\n        done();\n    },\n\n    triggers: ['beforeItem', 'item', 'beforePrerequest', 'prerequest', 'beforeTest', 'test'],\n\n    process: {\n        /**\n         * @param {Function=} callback -\n         * @param {Object} payload -\n         * @param {Function} next -\n         * @todo  validate payload\n         */\n        item (callback, payload, next) {\n            // adjust for polymorphic instructions\n            if (!next && _.isFunction(payload) && !_.isFunction(callback)) {\n                next = payload;\n                payload = callback;\n                callback = null;\n            }\n\n            var item = payload.item,\n                originalRequest = item.request.clone(),\n                coords = payload.coords,\n                data = _.isObject(payload.data) ? payload.data : {},\n                environment = _.isObject(payload.environment) ? payload.environment : {},\n                globals = _.isObject(payload.globals) ? payload.globals : {},\n                collectionVariables = _.isObject(payload.collectionVariables) ? payload.collectionVariables : {},\n                _variables = _.isObject(payload._variables) ? payload._variables : {},\n                stopOnError = _.has(payload, 'stopOnError') ? payload.stopOnError : this.options.stopOnError,\n\n                // @todo: this is mostly coded in event extension and we are\n                // still not sure whether that is the right place for it to be.\n                abortOnFailure = this.options.abortOnFailure,\n                stopOnFailure = this.options.stopOnFailure,\n                delay = _.get(this.options, 'delay.item'),\n\n                ctxTemplate;\n\n            // validate minimum parameters required for the command to work\n            if (!(item && coords)) {\n                return next(new Error('runtime: item execution is missing required parameters'));\n            }\n\n            // store a common uuid in the coords\n            coords.ref = uuid.v4();\n\n            // here we code to queue prerequest script, then make a request and then execute test script\n            this.triggers.beforeItem(null, coords, item);\n\n            this.queueDelay(function () {\n                // create the context object for scripts to run\n                ctxTemplate = {\n                    collectionVariables: collectionVariables,\n                    _variables: _variables,\n                    globals: globals,\n                    environment: environment,\n                    data: data,\n                    request: item.request\n                };\n\n                // @todo make it less nested by coding Instruction.thenQueue\n                this.queue('event', {\n                    name: 'prerequest',\n                    item: item,\n                    coords: coords,\n                    context: ctxTemplate,\n                    trackContext: ['globals', 'environment', 'collectionVariables'],\n                    stopOnScriptError: stopOnError,\n                    stopOnFailure: stopOnFailure\n                }).done(function (prereqExecutions, prereqExecutionError) {\n                    // if stop on error is marked and script executions had an error,\n                    // do not proceed with more commands, instead we bail out\n                    if ((stopOnError || stopOnFailure) && prereqExecutionError) {\n                        this.triggers.item(null, coords, item); // @todo - should this trigger receive error?\n\n                        return callback && callback.call(this, prereqExecutionError, {\n                            prerequest: prereqExecutions\n                        });\n                    }\n\n                    // update allowed request mutation properties with the mutated context\n                    // @note from this point forward, make sure this mutated\n                    // request instance is used for upcoming commands.\n                    ALLOWED_REQUEST_MUTATIONS.forEach(function (property) {\n                        if (_.has(ctxTemplate, ['request', property])) {\n                            item.request[property] = ctxTemplate.request[property];\n                        }\n\n                        // update property's parent reference\n                        if (item.request[property] && typeof item.request[property].setParent === 'function') {\n                            item.request[property].setParent(item.request);\n                        }\n                    });\n\n                    this.queue('request', {\n                        item: item,\n                        globals: ctxTemplate.globals,\n                        environment: ctxTemplate.environment,\n                        collectionVariables: ctxTemplate.collectionVariables,\n                        _variables: ctxTemplate._variables,\n                        data: ctxTemplate.data,\n                        coords: coords,\n                        source: 'collection'\n                    }).done(function (result, requestError) {\n                        !result && (result = {});\n\n                        var request = result.request,\n                            response = result.response,\n                            cookies = result.cookies;\n\n                        if ((stopOnError || stopOnFailure) && requestError) {\n                            this.triggers.item(null, coords, item); // @todo - should this trigger receive error?\n\n                            return callback && callback.call(this, requestError, {\n                                request\n                            });\n                        }\n\n                        // also the test object requires the updated request object (since auth helpers may modify it)\n                        request && (ctxTemplate.request = request);\n\n                        // @note convert response instance to plain object.\n                        // we want to avoid calling Response.toJSON() which triggers toJSON on Response.stream buffer.\n                        // Because that increases the size of stringified object by 3 times.\n                        // Also, that increases the total number of tokens (buffer.data) whereas Buffer.toString\n                        // generates a single string that is easier to stringify and sent over the UVM bridge.\n                        response && (ctxTemplate.response = getResponseJSON(response));\n\n                        // set cookies for this transaction\n                        cookies && (ctxTemplate.cookies = cookies);\n\n                        // the context template also has a test object to store assertions\n                        ctxTemplate.tests = {}; // @todo remove\n\n                        this.queue('event', {\n                            name: 'test',\n                            item: item,\n                            coords: coords,\n                            context: ctxTemplate,\n                            trackContext: ['tests', 'globals', 'environment', 'collectionVariables'],\n                            stopOnScriptError: stopOnError,\n                            abortOnFailure: abortOnFailure,\n                            stopOnFailure: stopOnFailure\n                        }).done(function (testExecutions, testExecutionError) {\n                            var visualizerData = extractVisualizerData(prereqExecutions, testExecutions),\n                                visualizerResult;\n\n                            if (visualizerData) {\n                                visualizer.processTemplate(visualizerData.template,\n                                    visualizerData.data,\n                                    visualizerData.options,\n                                    function (err, processedTemplate) {\n                                        visualizerResult = {\n                                            // bubble up the errors while processing template through visualizer result\n                                            error: err,\n\n                                            // add processed template and data to visualizer result\n                                            processedTemplate: processedTemplate,\n                                            data: visualizerData.data\n                                        };\n\n                                        // trigger an event saying that item has been processed\n                                        this.triggers.item(null, coords, item, visualizerResult);\n                                    }.bind(this));\n                            }\n                            else {\n                                // trigger an event saying that item has been processed\n                                // @todo - should this trigger receive error?\n                                this.triggers.item(null, coords, item, null);\n                            }\n\n                            // reset mutated request with original request instance\n                            // @note request mutations are not persisted across iterations\n                            item.request = originalRequest;\n\n                            callback && callback.call(this, ((stopOnError || stopOnFailure) && testExecutionError) ?\n                                testExecutionError : null, {\n                                prerequest: prereqExecutions,\n                                request: request,\n                                response: response,\n                                test: testExecutions\n                            });\n                        });\n                    });\n                });\n            }.bind(this), {\n                time: delay,\n                source: 'item',\n                cursor: coords\n            }, next);\n        }\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}