{"ast":null,"code":"/**\n * @fileOverview\n *\n * Implements the NTLM over HTTP specification: [MS-NTHT] https://msdn.microsoft.com/en-us/library/cc237488.aspx\n * Also see [MS-NLMP]: https://msdn.microsoft.com/en-us/library/cc236621.aspx\n *\n * @note NTLM supports a number of different variations, where an actual TCP connection is signed etc. This file\n * does _not_ implement those cases.\n */\n\nvar ntlmUtil = require('httpntlm').ntlm,\n  _ = require('lodash'),\n  EMPTY = '',\n  NTLM = 'NTLM',\n  STATE = 'state',\n  NEGOTIATE = 'negotiate',\n  NTLM_HEADER = 'ntlmHeader',\n  AUTHORIZATION = 'Authorization',\n  WWW_AUTHENTICATE = 'www-authenticate',\n  DISABLE_RETRY_REQUEST = 'disableRetryRequest',\n  NTLM_PARAMETERS = {\n    DOMAIN: 'domain',\n    WORKSTATION: 'workstation',\n    USERNAME: 'username',\n    PASSWORD: 'password'\n  },\n  STATES = {\n    INITIALIZED: 'INITIALIZED',\n    T1_MSG_CREATED: 'T1_MSG_CREATED',\n    T3_MSG_CREATED: 'T3_MSG_CREATED'\n  };\n\n/**\n * Parses the username to separate username and domain. It can handle two formats:\n *   - Down-Level Logon name format `DOMAIN\\USERNAME`\n *   - User Principal Name format `USERNAME@DOMAIN`\n *\n * @private\n * @param {String} username - Username string to parse from\n * @return {Object} - An object with `username` and `domain` fields, which are `strings`.\n */\nfunction parseParametersFromUsername(username) {\n  var dllParams, upnParams;\n  if (!(username && typeof username === 'string')) {\n    return {\n      username: EMPTY,\n      domain: EMPTY\n    };\n  }\n  dllParams = username.split('\\\\');\n  upnParams = username.split('@');\n\n  // username should be either of the two formats, not both\n  if (dllParams.length > 1 && upnParams.length > 1) {\n    return {\n      username: username,\n      domain: EMPTY\n    };\n  }\n\n  // try to parse from \"down level logon\" format\n  if (dllParams.length === 2 && dllParams[0] && dllParams[1]) {\n    return {\n      username: dllParams[1],\n      domain: dllParams[0]\n    };\n  }\n\n  // try to parse from \"user principal name\" format\n  if (upnParams.length === 2 && upnParams[0] && upnParams[1]) {\n    return {\n      username: upnParams[0],\n      domain: upnParams[1]\n    };\n  }\n  return {\n    username: username,\n    domain: EMPTY\n  };\n}\n\n/**\n * Check if `WWW-Authenticate` header has NTLM challenge.\n *\n * @private\n * @param {*} headers - Postman headers instance\n * @returns {Boolean}\n */\nfunction hasNTLMChallenge(headers) {\n  // Case 1: multiple headers\n  // - WWW-Authenticate: NTLM\n  // - WWW-Authenticate: Negotiate\n  if (headers.has(WWW_AUTHENTICATE, NTLM) || headers.has(WWW_AUTHENTICATE, NEGOTIATE)) {\n    return true;\n  }\n\n  // Case 2: single header\n  // - WWW-Authenticate: Negotiate, NTLM\n  return String(headers.get(WWW_AUTHENTICATE)).includes(NTLM);\n}\n\n/**\n * NTLM auth while authenticating requires negotiateMessage (type 1) and authenticateMessage (type 3) to be stored.\n * Also it needs to know which stage is it in (INITIALIZED, T1_MSG_CREATED and T3_MSG_CREATED).\n * After the first successful authentication, it just relies on the TCP connection, no other state is needed.\n *\n * @todo Currenty we don't close the connection. So there is no way to de-authenticate.\n *\n * @implements {AuthHandlerInterface}\n */\nmodule.exports = {\n  /**\n   * @property {AuthHandlerInterface~AuthManifest}\n   */\n  manifest: {\n    info: {\n      name: 'ntlm',\n      version: '1.0.0'\n    },\n    updates: [{\n      property: 'Authorization',\n      type: 'header'\n    }]\n  },\n  /**\n   * Initializes an item (extracts parameters from intermediate requests if any, etc)\n   * before the actual authorization step.\n   *\n   * @param {AuthInterface} auth -\n   * @param {Response} response -\n   * @param {AuthHandlerInterface~authInitHookCallback} done -\n   */\n  init: function (auth, response, done) {\n    done(null);\n  },\n  /**\n   * Verifies whether the request has valid basic auth credentials (which is always).\n   * Sanitizes the auth parameters if needed.\n   *\n   * @param {AuthInterface} auth -\n   * @param {AuthHandlerInterface~authPreHookCallback} done -\n   */\n  pre: function (auth, done) {\n    !auth.get(STATE) && auth.set(STATE, STATES.INITIALIZED);\n    done(null, true);\n  },\n  /**\n   * Verifies whether the basic auth succeeded.\n   *\n   * @param {AuthInterface} auth -\n   * @param {Response} response -\n   * @param {AuthHandlerInterface~authPostHookCallback} done -\n   */\n  post: function (auth, response, done) {\n    if (auth.get(DISABLE_RETRY_REQUEST)) {\n      return done(null, true);\n    }\n    var state = auth.get(STATE),\n      domain = auth.get(NTLM_PARAMETERS.DOMAIN) || EMPTY,\n      workstation = auth.get(NTLM_PARAMETERS.WORKSTATION) || EMPTY,\n      username = auth.get(NTLM_PARAMETERS.USERNAME) || EMPTY,\n      password = auth.get(NTLM_PARAMETERS.PASSWORD) || EMPTY,\n      negotiateMessage,\n      // type 1\n      challengeMessage,\n      // type 2\n      authenticateMessage,\n      // type 3\n      ntlmType2Header,\n      parsedParameters;\n    if (response.code !== 401 && response.code !== 403) {\n      return done(null, true);\n    }\n\n    // we try to extract domain from username if not specified.\n    if (!domain) {\n      parsedParameters = parseParametersFromUsername(username) || {};\n      username = parsedParameters.username;\n      domain = parsedParameters.domain;\n    }\n    if (state === STATES.INITIALIZED) {\n      // Nothing to do if the server does not ask us for auth in the first place.\n      if (!hasNTLMChallenge(response.headers)) {\n        return done(null, true);\n      }\n\n      // Create a type 1 message to send to the server\n      negotiateMessage = ntlmUtil.createType1Message({\n        domain,\n        workstation\n      });\n\n      // Add the type 1 message as the auth header\n      auth.set(NTLM_HEADER, negotiateMessage);\n\n      // Update the state\n      auth.set(STATE, STATES.T1_MSG_CREATED);\n\n      // ask runtime to replay the request\n      return done(null, false);\n    } else if (state === STATES.T1_MSG_CREATED) {\n      // At this point, we can assume that the type 1 message was sent to the server\n\n      // there can be multiple headers present with key `www-authenticate`.\n      // iterate to get the one which has the NTLM hash. if multiple\n      // headers have the NTLM hash, use the first one.\n      ntlmType2Header = response.headers.find(function (header) {\n        return String(header.key).toLowerCase() === WWW_AUTHENTICATE && header.valueOf().startsWith('NTLM ');\n      });\n      if (!ntlmType2Header) {\n        return done(new Error('ntlm: server did not send NTLM type 2 message'));\n      }\n      challengeMessage = ntlmUtil.parseType2Message(ntlmType2Header.valueOf(), _.noop);\n      if (!challengeMessage) {\n        return done(new Error('ntlm: server did not correctly process authentication request'));\n      }\n      authenticateMessage = ntlmUtil.createType3Message(challengeMessage, {\n        domain,\n        workstation,\n        username,\n        password\n      });\n\n      // Now create the type 3 message, and add it to the request\n      auth.set(NTLM_HEADER, authenticateMessage);\n      auth.set(STATE, STATES.T3_MSG_CREATED);\n\n      // ask runtime to replay the request\n      return done(null, false);\n    } else if (state === STATES.T3_MSG_CREATED) {\n      // Means we have tried to authenticate, so we should stop here without worrying about anything\n      return done(null, true);\n    }\n\n    // We are in an undefined state\n    return done(null, true);\n  },\n  /**\n   * Signs a request.\n   *\n   * @param {AuthInterface} auth -\n   * @param {Request} request -\n   * @param {AuthHandlerInterface~authSignHookCallback} done -\n   */\n  sign: function (auth, request, done) {\n    var ntlmHeader = auth.get(NTLM_HEADER);\n    request.removeHeader(AUTHORIZATION, {\n      ignoreCase: true\n    });\n    ntlmHeader && request.addHeader({\n      key: AUTHORIZATION,\n      value: ntlmHeader,\n      system: true\n    });\n    return done();\n  }\n};","map":{"version":3,"names":["ntlmUtil","require","ntlm","_","EMPTY","NTLM","STATE","NEGOTIATE","NTLM_HEADER","AUTHORIZATION","WWW_AUTHENTICATE","DISABLE_RETRY_REQUEST","NTLM_PARAMETERS","DOMAIN","WORKSTATION","USERNAME","PASSWORD","STATES","INITIALIZED","T1_MSG_CREATED","T3_MSG_CREATED","parseParametersFromUsername","username","dllParams","upnParams","domain","split","length","hasNTLMChallenge","headers","has","String","get","includes","module","exports","manifest","info","name","version","updates","property","type","init","auth","response","done","pre","set","post","state","workstation","password","negotiateMessage","challengeMessage","authenticateMessage","ntlmType2Header","parsedParameters","code","createType1Message","find","header","key","toLowerCase","valueOf","startsWith","Error","parseType2Message","noop","createType3Message","sign","request","ntlmHeader","removeHeader","ignoreCase","addHeader","value","system"],"sources":["/Users/Qusai.Qishta/node_modules/postman-runtime/lib/authorizer/ntlm.js"],"sourcesContent":["/**\n * @fileOverview\n *\n * Implements the NTLM over HTTP specification: [MS-NTHT] https://msdn.microsoft.com/en-us/library/cc237488.aspx\n * Also see [MS-NLMP]: https://msdn.microsoft.com/en-us/library/cc236621.aspx\n *\n * @note NTLM supports a number of different variations, where an actual TCP connection is signed etc. This file\n * does _not_ implement those cases.\n */\n\nvar ntlmUtil = require('httpntlm').ntlm,\n    _ = require('lodash'),\n\n    EMPTY = '',\n    NTLM = 'NTLM',\n    STATE = 'state',\n    NEGOTIATE = 'negotiate',\n    NTLM_HEADER = 'ntlmHeader',\n    AUTHORIZATION = 'Authorization',\n    WWW_AUTHENTICATE = 'www-authenticate',\n    DISABLE_RETRY_REQUEST = 'disableRetryRequest',\n    NTLM_PARAMETERS = {\n        DOMAIN: 'domain',\n        WORKSTATION: 'workstation',\n        USERNAME: 'username',\n        PASSWORD: 'password'\n    },\n    STATES = {\n        INITIALIZED: 'INITIALIZED',\n        T1_MSG_CREATED: 'T1_MSG_CREATED',\n        T3_MSG_CREATED: 'T3_MSG_CREATED'\n    };\n\n/**\n * Parses the username to separate username and domain. It can handle two formats:\n *   - Down-Level Logon name format `DOMAIN\\USERNAME`\n *   - User Principal Name format `USERNAME@DOMAIN`\n *\n * @private\n * @param {String} username - Username string to parse from\n * @return {Object} - An object with `username` and `domain` fields, which are `strings`.\n */\nfunction parseParametersFromUsername (username) {\n    var dllParams,\n        upnParams;\n\n    if (!(username && typeof username === 'string')) {\n        return {\n            username: EMPTY,\n            domain: EMPTY\n        };\n    }\n\n    dllParams = username.split('\\\\');\n    upnParams = username.split('@');\n\n    // username should be either of the two formats, not both\n    if (dllParams.length > 1 && upnParams.length > 1) {\n        return {\n            username: username,\n            domain: EMPTY\n        };\n    }\n\n    // try to parse from \"down level logon\" format\n    if (dllParams.length === 2 && dllParams[0] && dllParams[1]) {\n        return {\n            username: dllParams[1],\n            domain: dllParams[0]\n        };\n    }\n\n    // try to parse from \"user principal name\" format\n    if (upnParams.length === 2 && upnParams[0] && upnParams[1]) {\n        return {\n            username: upnParams[0],\n            domain: upnParams[1]\n        };\n    }\n\n    return {\n        username: username,\n        domain: EMPTY\n    };\n}\n\n/**\n * Check if `WWW-Authenticate` header has NTLM challenge.\n *\n * @private\n * @param {*} headers - Postman headers instance\n * @returns {Boolean}\n */\nfunction hasNTLMChallenge (headers) {\n    // Case 1: multiple headers\n    // - WWW-Authenticate: NTLM\n    // - WWW-Authenticate: Negotiate\n    if (headers.has(WWW_AUTHENTICATE, NTLM) || headers.has(WWW_AUTHENTICATE, NEGOTIATE)) {\n        return true;\n    }\n\n    // Case 2: single header\n    // - WWW-Authenticate: Negotiate, NTLM\n    return String(headers.get(WWW_AUTHENTICATE)).includes(NTLM);\n}\n\n/**\n * NTLM auth while authenticating requires negotiateMessage (type 1) and authenticateMessage (type 3) to be stored.\n * Also it needs to know which stage is it in (INITIALIZED, T1_MSG_CREATED and T3_MSG_CREATED).\n * After the first successful authentication, it just relies on the TCP connection, no other state is needed.\n *\n * @todo Currenty we don't close the connection. So there is no way to de-authenticate.\n *\n * @implements {AuthHandlerInterface}\n */\nmodule.exports = {\n    /**\n     * @property {AuthHandlerInterface~AuthManifest}\n     */\n    manifest: {\n        info: {\n            name: 'ntlm',\n            version: '1.0.0'\n        },\n        updates: [\n            {\n                property: 'Authorization',\n                type: 'header'\n            }\n        ]\n    },\n\n    /**\n     * Initializes an item (extracts parameters from intermediate requests if any, etc)\n     * before the actual authorization step.\n     *\n     * @param {AuthInterface} auth -\n     * @param {Response} response -\n     * @param {AuthHandlerInterface~authInitHookCallback} done -\n     */\n    init: function (auth, response, done) {\n        done(null);\n    },\n\n    /**\n     * Verifies whether the request has valid basic auth credentials (which is always).\n     * Sanitizes the auth parameters if needed.\n     *\n     * @param {AuthInterface} auth -\n     * @param {AuthHandlerInterface~authPreHookCallback} done -\n     */\n    pre: function (auth, done) {\n        !auth.get(STATE) && auth.set(STATE, STATES.INITIALIZED);\n\n        done(null, true);\n    },\n\n    /**\n     * Verifies whether the basic auth succeeded.\n     *\n     * @param {AuthInterface} auth -\n     * @param {Response} response -\n     * @param {AuthHandlerInterface~authPostHookCallback} done -\n     */\n    post: function (auth, response, done) {\n        if (auth.get(DISABLE_RETRY_REQUEST)) {\n            return done(null, true);\n        }\n\n        var state = auth.get(STATE),\n            domain = auth.get(NTLM_PARAMETERS.DOMAIN) || EMPTY,\n            workstation = auth.get(NTLM_PARAMETERS.WORKSTATION) || EMPTY,\n            username = auth.get(NTLM_PARAMETERS.USERNAME) || EMPTY,\n            password = auth.get(NTLM_PARAMETERS.PASSWORD) || EMPTY,\n            negotiateMessage, // type 1\n            challengeMessage, // type 2\n            authenticateMessage, // type 3\n            ntlmType2Header,\n            parsedParameters;\n\n        if (response.code !== 401 && response.code !== 403) {\n            return done(null, true);\n        }\n\n        // we try to extract domain from username if not specified.\n        if (!domain) {\n            parsedParameters = parseParametersFromUsername(username) || {};\n\n            username = parsedParameters.username;\n            domain = parsedParameters.domain;\n        }\n\n        if (state === STATES.INITIALIZED) {\n            // Nothing to do if the server does not ask us for auth in the first place.\n            if (!hasNTLMChallenge(response.headers)) {\n                return done(null, true);\n            }\n\n            // Create a type 1 message to send to the server\n            negotiateMessage = ntlmUtil.createType1Message({\n                domain,\n                workstation\n            });\n\n            // Add the type 1 message as the auth header\n            auth.set(NTLM_HEADER, negotiateMessage);\n\n            // Update the state\n            auth.set(STATE, STATES.T1_MSG_CREATED);\n\n            // ask runtime to replay the request\n            return done(null, false);\n        }\n        else if (state === STATES.T1_MSG_CREATED) {\n            // At this point, we can assume that the type 1 message was sent to the server\n\n            // there can be multiple headers present with key `www-authenticate`.\n            // iterate to get the one which has the NTLM hash. if multiple\n            // headers have the NTLM hash, use the first one.\n            ntlmType2Header = response.headers.find(function (header) {\n                return String(header.key).toLowerCase() === WWW_AUTHENTICATE &&\n                    header.valueOf().startsWith('NTLM ');\n            });\n\n            if (!ntlmType2Header) {\n                return done(new Error('ntlm: server did not send NTLM type 2 message'));\n            }\n\n            challengeMessage = ntlmUtil.parseType2Message(ntlmType2Header.valueOf(), _.noop);\n\n            if (!challengeMessage) {\n                return done(new Error('ntlm: server did not correctly process authentication request'));\n            }\n\n            authenticateMessage = ntlmUtil.createType3Message(challengeMessage, {\n                domain,\n                workstation,\n                username,\n                password\n            });\n\n            // Now create the type 3 message, and add it to the request\n            auth.set(NTLM_HEADER, authenticateMessage);\n            auth.set(STATE, STATES.T3_MSG_CREATED);\n\n            // ask runtime to replay the request\n            return done(null, false);\n        }\n        else if (state === STATES.T3_MSG_CREATED) {\n            // Means we have tried to authenticate, so we should stop here without worrying about anything\n            return done(null, true);\n        }\n\n        // We are in an undefined state\n        return done(null, true);\n    },\n\n    /**\n     * Signs a request.\n     *\n     * @param {AuthInterface} auth -\n     * @param {Request} request -\n     * @param {AuthHandlerInterface~authSignHookCallback} done -\n     */\n    sign: function (auth, request, done) {\n        var ntlmHeader = auth.get(NTLM_HEADER);\n\n        request.removeHeader(AUTHORIZATION, { ignoreCase: true });\n        ntlmHeader && request.addHeader({\n            key: AUTHORIZATION,\n            value: ntlmHeader,\n            system: true\n        });\n\n        return done();\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}