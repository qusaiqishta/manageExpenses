{"ast":null,"code":"var _ = require('../util').lodash,\n  dynamicVariables = require('./dynamic-variables'),\n  E = '',\n  SuperString,\n  // constructor\n  Substitutor; // constructor\n\n/**\n * A string-like instance with additional functionalities to track string operations better\n *\n * @constructor\n * @private\n * @param {String} value -\n */\nSuperString = function SuperString(value) {\n  this.value = _.isString(value) ? value : _.isFunction(value.toString) && value.toString() || E;\n\n  /**\n   * The total number of times there was a successful substitution.\n   *\n   * @type {number}\n   */\n  this.substitutions = 0;\n\n  /**\n   * Keeps a track of the number of tokens replaced in the last replace command\n   *\n   * @type {number}\n   */\n  this.replacements = 0;\n};\n_.assign(SuperString.prototype, /** @lends SuperString.prototype */{\n  /**\n   * Equivalent to string replace but performs additional tracking of the number of tokens replaced\n   *\n   * @param {RegExp|String} regex -\n   * @param {Function|String} fn -\n   * @returns {SuperString}\n   */\n  replace(regex, fn) {\n    var replacements = 0; // maintain a count of tokens replaced\n\n    // to ensure we do not perform needless operations in the replacement, we use multiple replacement functions\n    // after validating the parameters\n    this.value = this.value.replace(regex, _.isFunction(fn) ? function () {\n      replacements += 1;\n      return fn.apply(this, arguments);\n    } :\n    // this case is returned when replacer is not a function (ensures we do not need to check it)\n    /* istanbul ignore next */\n    function () {\n      replacements += 1;\n      return fn;\n    });\n    this.replacements = replacements; // store the last replacements\n    replacements && (this.substitutions += 1); // if any replacement is done, count that some substitution was made\n\n    return this;\n  },\n  /**\n   * @returns {String}\n   */\n  toString() {\n    return this.value;\n  },\n  /**\n   * @returns {String}\n   */\n  valueOf() {\n    return this.value;\n  }\n});\n\n/**\n * Perform replacement of tokens in a SuperString with values stored in keys of an array of objects.\n *\n * @constructor\n * @private\n * @param {Array} variables -\n * @param {Object} defaults -\n */\nSubstitutor = function (variables, defaults) {\n  defaults && variables.push(defaults);\n  this.variables = variables;\n};\n_.assign(Substitutor.prototype, /** @lends Substitutor.prototype */{\n  /**\n   * Find a key from the array of variable objects provided to the substitutor\n   *\n   * @param {String} key -\n   * @returns {*}\n   */\n  find(key) {\n    var arr = this.variables,\n      obj,\n      value,\n      i,\n      ii;\n    for (i = 0, ii = arr.length; i < ii; i++) {\n      obj = arr[i];\n      // ensure that the item is an object\n      if (!(obj && _.isObject(obj))) {\n        continue;\n      }\n\n      // in case the object is a postman variable list, we give special attention\n      if (obj.constructor._postman_propertyName === 'VariableList') {\n        value = obj.oneNormalizedVariable(key);\n        if (value && !value.disabled) {\n          return value;\n        }\n      }\n      // else we return the value from the plain object\n      else if (_.has(obj, key)) {\n        return obj[key];\n      }\n    }\n  },\n  /**\n   * @param {String} value -\n   * @returns {String}\n   */\n  parse(value) {\n    // convert the value into a SuperString so that it can return tracking results during replacements\n    value = new SuperString(value);\n\n    // get an instance of a replacer function that would be used to replace ejs like variable replacement\n    // tokens\n    var replacer = Substitutor.replacer(this);\n\n    // replace the value once and keep on doing it until all tokens are replaced or we have reached a limit of\n    // replacements\n    do {\n      value = value.replace(Substitutor.REGEX_EXTRACT_VARS, replacer);\n    } while (value.replacements && value.substitutions < Substitutor.VARS_SUBREPLACE_LIMIT);\n\n    // @todo: uncomment this code, and try to raise a warning in some way.\n    // do a final check that if recursion limits are reached then replace with blank string\n    // if (value.substitutions >= Substitutor.VARS_SUBREPLACE_LIMIT) {\n    //     value = value.replace(Substitutor.REGEX_EXTRACT_VARS, E);\n    // }\n\n    return value;\n  }\n});\n_.assign(Substitutor, /** @lends Substitutor */{\n  /**\n   * Regular expression to be used in {String}.replace for extracting variable substitutions\n   *\n   * @readOnly\n   * @type {RegExp}\n   */\n  REGEX_EXTRACT_VARS: /\\{\\{([^{}]*?)}}/g,\n  /**\n   * Defines the number of times the variable substitution mechanism will repeat until all tokens are resolved\n   *\n   * @type {Number}\n   */\n  VARS_SUBREPLACE_LIMIT: 19,\n  /**\n   * Maintain a list of types that are native\n   *\n   * @readOnly\n   * @enum {String}\n   */\n  NATIVETYPES: {\n    string: true,\n    number: true,\n    boolean: true\n  },\n  /**\n   * Holds the default variables that Postman supports.\n   *\n   * @type {Object}\n   */\n  DEFAULT_VARS: {},\n  /**\n   * Create an instance of a substitutor or reuse one\n   *\n   * @param {Array|Substitutor} variables -\n   * @param {Object=} defaults An object containing default variables to substitute\n   * @returns {Substitutor}\n   */\n  box: function (variables, defaults) {\n    return variables instanceof Substitutor ? variables : new Substitutor(variables, defaults);\n  },\n  /**\n   * Checks whether a variable is instance of substitutor\n   *\n   * @param {*} subject -\n   * @returns {Boolean}\n   */\n  isInstance: function (subject) {\n    return subject instanceof Substitutor;\n  },\n  /**\n   * Get an instance of a function that is useful to be passed to a string replace function for extracting tokens\n   * and replacing by substitutions\n   *\n   * @private\n   * @param {Substitutor} substitutor -\n   * @returns {Function}\n   */\n  replacer: function (substitutor) {\n    return function (match, token) {\n      var r = substitutor.find(token);\n      r && _.isFunction(r) && (r = r());\n      r && _.isFunction(r.toString) && (r = r.toString());\n      return Substitutor.NATIVETYPES[typeof r] ? r : match;\n    };\n  }\n});\n\n// @todo make the default variables of SuperString extensible and do this anywhere else but here\n_.forOwn(dynamicVariables, function (variable, name) {\n  Substitutor.DEFAULT_VARS[name] = variable.generator;\n});\nmodule.exports = {\n  SuperString,\n  Substitutor\n};","map":{"version":3,"names":["_","require","lodash","dynamicVariables","E","SuperString","Substitutor","value","isString","isFunction","toString","substitutions","replacements","assign","prototype","replace","regex","fn","apply","arguments","valueOf","variables","defaults","push","find","key","arr","obj","i","ii","length","isObject","constructor","_postman_propertyName","oneNormalizedVariable","disabled","has","parse","replacer","REGEX_EXTRACT_VARS","VARS_SUBREPLACE_LIMIT","NATIVETYPES","string","number","boolean","DEFAULT_VARS","box","isInstance","subject","substitutor","match","token","r","forOwn","variable","name","generator","module","exports"],"sources":["/Users/Qusai.Qishta/node_modules/postman-collection/lib/superstring/index.js"],"sourcesContent":["var _ = require('../util').lodash,\n    dynamicVariables = require('./dynamic-variables'),\n    E = '',\n\n    SuperString, // constructor\n    Substitutor; // constructor\n\n/**\n * A string-like instance with additional functionalities to track string operations better\n *\n * @constructor\n * @private\n * @param {String} value -\n */\nSuperString = function SuperString (value) {\n    this.value = _.isString(value) ? value : (_.isFunction(value.toString) && value.toString() || E);\n\n    /**\n     * The total number of times there was a successful substitution.\n     *\n     * @type {number}\n     */\n    this.substitutions = 0;\n\n    /**\n     * Keeps a track of the number of tokens replaced in the last replace command\n     *\n     * @type {number}\n     */\n    this.replacements = 0;\n};\n\n_.assign(SuperString.prototype, /** @lends SuperString.prototype */ {\n    /**\n     * Equivalent to string replace but performs additional tracking of the number of tokens replaced\n     *\n     * @param {RegExp|String} regex -\n     * @param {Function|String} fn -\n     * @returns {SuperString}\n     */\n    replace (regex, fn) {\n        var replacements = 0; // maintain a count of tokens replaced\n\n        // to ensure we do not perform needless operations in the replacement, we use multiple replacement functions\n        // after validating the parameters\n        this.value = (this.value.replace(regex, _.isFunction(fn) ?\n            function () {\n                replacements += 1;\n\n                return fn.apply(this, arguments);\n            } :\n            // this case is returned when replacer is not a function (ensures we do not need to check it)\n            /* istanbul ignore next */\n            function () {\n                replacements += 1;\n\n                return fn;\n            })\n        );\n\n        this.replacements = replacements; // store the last replacements\n        replacements && (this.substitutions += 1); // if any replacement is done, count that some substitution was made\n\n        return this;\n    },\n\n    /**\n     * @returns {String}\n     */\n    toString () {\n        return this.value;\n    },\n\n    /**\n     * @returns {String}\n     */\n    valueOf () {\n        return this.value;\n    }\n});\n\n/**\n * Perform replacement of tokens in a SuperString with values stored in keys of an array of objects.\n *\n * @constructor\n * @private\n * @param {Array} variables -\n * @param {Object} defaults -\n */\nSubstitutor = function (variables, defaults) {\n    defaults && variables.push(defaults);\n    this.variables = variables;\n};\n\n_.assign(Substitutor.prototype, /** @lends Substitutor.prototype */ {\n    /**\n     * Find a key from the array of variable objects provided to the substitutor\n     *\n     * @param {String} key -\n     * @returns {*}\n     */\n    find (key) {\n        var arr = this.variables,\n            obj,\n            value,\n            i,\n            ii;\n\n        for (i = 0, ii = arr.length; i < ii; i++) {\n            obj = arr[i];\n            // ensure that the item is an object\n            if (!(obj && _.isObject(obj))) {\n                continue;\n            }\n\n            // in case the object is a postman variable list, we give special attention\n            if (obj.constructor._postman_propertyName === 'VariableList') {\n                value = obj.oneNormalizedVariable(key);\n\n                if (value && !value.disabled) {\n                    return value;\n                }\n            }\n            // else we return the value from the plain object\n            else if (_.has(obj, key)) {\n                return obj[key];\n            }\n        }\n    },\n\n    /**\n     * @param {String} value -\n     * @returns {String}\n     */\n    parse (value) {\n        // convert the value into a SuperString so that it can return tracking results during replacements\n        value = new SuperString(value);\n\n        // get an instance of a replacer function that would be used to replace ejs like variable replacement\n        // tokens\n        var replacer = Substitutor.replacer(this);\n\n        // replace the value once and keep on doing it until all tokens are replaced or we have reached a limit of\n        // replacements\n        do {\n            value = value.replace(Substitutor.REGEX_EXTRACT_VARS, replacer);\n        } while (value.replacements && (value.substitutions < Substitutor.VARS_SUBREPLACE_LIMIT));\n\n        // @todo: uncomment this code, and try to raise a warning in some way.\n        // do a final check that if recursion limits are reached then replace with blank string\n        // if (value.substitutions >= Substitutor.VARS_SUBREPLACE_LIMIT) {\n        //     value = value.replace(Substitutor.REGEX_EXTRACT_VARS, E);\n        // }\n\n        return value;\n    }\n});\n\n_.assign(Substitutor, /** @lends Substitutor */ {\n    /**\n     * Regular expression to be used in {String}.replace for extracting variable substitutions\n     *\n     * @readOnly\n     * @type {RegExp}\n     */\n    REGEX_EXTRACT_VARS: /\\{\\{([^{}]*?)}}/g,\n\n    /**\n     * Defines the number of times the variable substitution mechanism will repeat until all tokens are resolved\n     *\n     * @type {Number}\n     */\n    VARS_SUBREPLACE_LIMIT: 19,\n\n    /**\n     * Maintain a list of types that are native\n     *\n     * @readOnly\n     * @enum {String}\n     */\n    NATIVETYPES: {\n        string: true,\n        number: true,\n        boolean: true\n    },\n\n    /**\n     * Holds the default variables that Postman supports.\n     *\n     * @type {Object}\n     */\n    DEFAULT_VARS: {},\n\n    /**\n     * Create an instance of a substitutor or reuse one\n     *\n     * @param {Array|Substitutor} variables -\n     * @param {Object=} defaults An object containing default variables to substitute\n     * @returns {Substitutor}\n     */\n    box: function (variables, defaults) {\n        return (variables instanceof Substitutor) ? variables : new Substitutor(variables, defaults);\n    },\n\n    /**\n     * Checks whether a variable is instance of substitutor\n     *\n     * @param {*} subject -\n     * @returns {Boolean}\n     */\n    isInstance: function (subject) {\n        return (subject instanceof Substitutor);\n    },\n\n    /**\n     * Get an instance of a function that is useful to be passed to a string replace function for extracting tokens\n     * and replacing by substitutions\n     *\n     * @private\n     * @param {Substitutor} substitutor -\n     * @returns {Function}\n     */\n    replacer: function (substitutor) {\n        return function (match, token) {\n            var r = substitutor.find(token);\n\n            r && _.isFunction(r) && (r = r());\n            r && _.isFunction(r.toString) && (r = r.toString());\n\n            return Substitutor.NATIVETYPES[(typeof r)] ? r : match;\n        };\n    }\n});\n\n// @todo make the default variables of SuperString extensible and do this anywhere else but here\n_.forOwn(dynamicVariables, function (variable, name) {\n    Substitutor.DEFAULT_VARS[name] = variable.generator;\n});\n\nmodule.exports = {\n    SuperString,\n    Substitutor\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}