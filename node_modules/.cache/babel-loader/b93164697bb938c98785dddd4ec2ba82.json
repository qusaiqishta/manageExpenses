{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.SourceLocation = SourceLocation;\nexports.id = id;\nexports.stripFlags = stripFlags;\nexports.stripComment = stripComment;\nexports.preparePath = preparePath;\nexports.prepareMustache = prepareMustache;\nexports.prepareRawBlock = prepareRawBlock;\nexports.prepareBlock = prepareBlock;\nexports.prepareProgram = prepareProgram;\nexports.preparePartialBlock = preparePartialBlock;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\nvar _exception = require('../exception');\nvar _exception2 = _interopRequireDefault(_exception);\nfunction validateClose(open, close) {\n  close = close.path ? close.path.original : close;\n  if (open.path.original !== close) {\n    var errorNode = {\n      loc: open.path.loc\n    };\n    throw new _exception2['default'](open.path.original + \" doesn't match \" + close, errorNode);\n  }\n}\nfunction SourceLocation(source, locInfo) {\n  this.source = source;\n  this.start = {\n    line: locInfo.first_line,\n    column: locInfo.first_column\n  };\n  this.end = {\n    line: locInfo.last_line,\n    column: locInfo.last_column\n  };\n}\nfunction id(token) {\n  if (/^\\[.*\\]$/.test(token)) {\n    return token.substring(1, token.length - 1);\n  } else {\n    return token;\n  }\n}\nfunction stripFlags(open, close) {\n  return {\n    open: open.charAt(2) === '~',\n    close: close.charAt(close.length - 3) === '~'\n  };\n}\nfunction stripComment(comment) {\n  return comment.replace(/^\\{\\{~?!-?-?/, '').replace(/-?-?~?\\}\\}$/, '');\n}\nfunction preparePath(data, parts, loc) {\n  loc = this.locInfo(loc);\n  var original = data ? '@' : '',\n    dig = [],\n    depth = 0;\n  for (var i = 0, l = parts.length; i < l; i++) {\n    var part = parts[i].part,\n      // If we have [] syntax then we do not treat path references as operators,\n      // i.e. foo.[this] resolves to approximately context.foo['this']\n      isLiteral = parts[i].original !== part;\n    original += (parts[i].separator || '') + part;\n    if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {\n      if (dig.length > 0) {\n        throw new _exception2['default']('Invalid path: ' + original, {\n          loc: loc\n        });\n      } else if (part === '..') {\n        depth++;\n      }\n    } else {\n      dig.push(part);\n    }\n  }\n  return {\n    type: 'PathExpression',\n    data: data,\n    depth: depth,\n    parts: dig,\n    original: original,\n    loc: loc\n  };\n}\nfunction prepareMustache(path, params, hash, open, strip, locInfo) {\n  // Must use charAt to support IE pre-10\n  var escapeFlag = open.charAt(3) || open.charAt(2),\n    escaped = escapeFlag !== '{' && escapeFlag !== '&';\n  var decorator = /\\*/.test(open);\n  return {\n    type: decorator ? 'Decorator' : 'MustacheStatement',\n    path: path,\n    params: params,\n    hash: hash,\n    escaped: escaped,\n    strip: strip,\n    loc: this.locInfo(locInfo)\n  };\n}\nfunction prepareRawBlock(openRawBlock, contents, close, locInfo) {\n  validateClose(openRawBlock, close);\n  locInfo = this.locInfo(locInfo);\n  var program = {\n    type: 'Program',\n    body: contents,\n    strip: {},\n    loc: locInfo\n  };\n  return {\n    type: 'BlockStatement',\n    path: openRawBlock.path,\n    params: openRawBlock.params,\n    hash: openRawBlock.hash,\n    program: program,\n    openStrip: {},\n    inverseStrip: {},\n    closeStrip: {},\n    loc: locInfo\n  };\n}\nfunction prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {\n  if (close && close.path) {\n    validateClose(openBlock, close);\n  }\n  var decorator = /\\*/.test(openBlock.open);\n  program.blockParams = openBlock.blockParams;\n  var inverse = undefined,\n    inverseStrip = undefined;\n  if (inverseAndProgram) {\n    if (decorator) {\n      throw new _exception2['default']('Unexpected inverse block on decorator', inverseAndProgram);\n    }\n    if (inverseAndProgram.chain) {\n      inverseAndProgram.program.body[0].closeStrip = close.strip;\n    }\n    inverseStrip = inverseAndProgram.strip;\n    inverse = inverseAndProgram.program;\n  }\n  if (inverted) {\n    inverted = inverse;\n    inverse = program;\n    program = inverted;\n  }\n  return {\n    type: decorator ? 'DecoratorBlock' : 'BlockStatement',\n    path: openBlock.path,\n    params: openBlock.params,\n    hash: openBlock.hash,\n    program: program,\n    inverse: inverse,\n    openStrip: openBlock.strip,\n    inverseStrip: inverseStrip,\n    closeStrip: close && close.strip,\n    loc: this.locInfo(locInfo)\n  };\n}\nfunction prepareProgram(statements, loc) {\n  if (!loc && statements.length) {\n    var firstLoc = statements[0].loc,\n      lastLoc = statements[statements.length - 1].loc;\n\n    /* istanbul ignore else */\n    if (firstLoc && lastLoc) {\n      loc = {\n        source: firstLoc.source,\n        start: {\n          line: firstLoc.start.line,\n          column: firstLoc.start.column\n        },\n        end: {\n          line: lastLoc.end.line,\n          column: lastLoc.end.column\n        }\n      };\n    }\n  }\n  return {\n    type: 'Program',\n    body: statements,\n    strip: {},\n    loc: loc\n  };\n}\nfunction preparePartialBlock(open, program, close, locInfo) {\n  validateClose(open, close);\n  return {\n    type: 'PartialBlockStatement',\n    name: open.path,\n    params: open.params,\n    hash: open.hash,\n    program: program,\n    openStrip: open.strip,\n    closeStrip: close && close.strip,\n    loc: this.locInfo(locInfo)\n  };\n}","map":{"version":3,"mappings":"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","names":["validateClose","open","close","path","original","errorNode","loc","SourceLocation","source","locInfo","start","line","first_line","column","first_column","end","last_line","last_column","id","token","test","substring","length","stripFlags","charAt","stripComment","comment","replace","preparePath","data","parts","dig","depth","i","l","part","isLiteral","separator","push","type","prepareMustache","params","hash","strip","escapeFlag","escaped","decorator","prepareRawBlock","openRawBlock","contents","program","body","openStrip","inverseStrip","closeStrip","prepareBlock","openBlock","inverseAndProgram","inverted","blockParams","inverse","chain","prepareProgram","statements","firstLoc","lastLoc","preparePartialBlock","name"],"sources":["../../../../lib/handlebars/compiler/helpers.js"],"sourcesContent":["import Exception from '../exception';\n\nfunction validateClose(open, close) {\n  close = close.path ? close.path.original : close;\n\n  if (open.path.original !== close) {\n    let errorNode = { loc: open.path.loc };\n\n    throw new Exception(\n      open.path.original + \" doesn't match \" + close,\n      errorNode\n    );\n  }\n}\n\nexport function SourceLocation(source, locInfo) {\n  this.source = source;\n  this.start = {\n    line: locInfo.first_line,\n    column: locInfo.first_column\n  };\n  this.end = {\n    line: locInfo.last_line,\n    column: locInfo.last_column\n  };\n}\n\nexport function id(token) {\n  if (/^\\[.*\\]$/.test(token)) {\n    return token.substring(1, token.length - 1);\n  } else {\n    return token;\n  }\n}\n\nexport function stripFlags(open, close) {\n  return {\n    open: open.charAt(2) === '~',\n    close: close.charAt(close.length - 3) === '~'\n  };\n}\n\nexport function stripComment(comment) {\n  return comment.replace(/^\\{\\{~?!-?-?/, '').replace(/-?-?~?\\}\\}$/, '');\n}\n\nexport function preparePath(data, parts, loc) {\n  loc = this.locInfo(loc);\n\n  let original = data ? '@' : '',\n    dig = [],\n    depth = 0;\n\n  for (let i = 0, l = parts.length; i < l; i++) {\n    let part = parts[i].part,\n      // If we have [] syntax then we do not treat path references as operators,\n      // i.e. foo.[this] resolves to approximately context.foo['this']\n      isLiteral = parts[i].original !== part;\n    original += (parts[i].separator || '') + part;\n\n    if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {\n      if (dig.length > 0) {\n        throw new Exception('Invalid path: ' + original, { loc });\n      } else if (part === '..') {\n        depth++;\n      }\n    } else {\n      dig.push(part);\n    }\n  }\n\n  return {\n    type: 'PathExpression',\n    data,\n    depth,\n    parts: dig,\n    original,\n    loc\n  };\n}\n\nexport function prepareMustache(path, params, hash, open, strip, locInfo) {\n  // Must use charAt to support IE pre-10\n  let escapeFlag = open.charAt(3) || open.charAt(2),\n    escaped = escapeFlag !== '{' && escapeFlag !== '&';\n\n  let decorator = /\\*/.test(open);\n  return {\n    type: decorator ? 'Decorator' : 'MustacheStatement',\n    path,\n    params,\n    hash,\n    escaped,\n    strip,\n    loc: this.locInfo(locInfo)\n  };\n}\n\nexport function prepareRawBlock(openRawBlock, contents, close, locInfo) {\n  validateClose(openRawBlock, close);\n\n  locInfo = this.locInfo(locInfo);\n  let program = {\n    type: 'Program',\n    body: contents,\n    strip: {},\n    loc: locInfo\n  };\n\n  return {\n    type: 'BlockStatement',\n    path: openRawBlock.path,\n    params: openRawBlock.params,\n    hash: openRawBlock.hash,\n    program,\n    openStrip: {},\n    inverseStrip: {},\n    closeStrip: {},\n    loc: locInfo\n  };\n}\n\nexport function prepareBlock(\n  openBlock,\n  program,\n  inverseAndProgram,\n  close,\n  inverted,\n  locInfo\n) {\n  if (close && close.path) {\n    validateClose(openBlock, close);\n  }\n\n  let decorator = /\\*/.test(openBlock.open);\n\n  program.blockParams = openBlock.blockParams;\n\n  let inverse, inverseStrip;\n\n  if (inverseAndProgram) {\n    if (decorator) {\n      throw new Exception(\n        'Unexpected inverse block on decorator',\n        inverseAndProgram\n      );\n    }\n\n    if (inverseAndProgram.chain) {\n      inverseAndProgram.program.body[0].closeStrip = close.strip;\n    }\n\n    inverseStrip = inverseAndProgram.strip;\n    inverse = inverseAndProgram.program;\n  }\n\n  if (inverted) {\n    inverted = inverse;\n    inverse = program;\n    program = inverted;\n  }\n\n  return {\n    type: decorator ? 'DecoratorBlock' : 'BlockStatement',\n    path: openBlock.path,\n    params: openBlock.params,\n    hash: openBlock.hash,\n    program,\n    inverse,\n    openStrip: openBlock.strip,\n    inverseStrip,\n    closeStrip: close && close.strip,\n    loc: this.locInfo(locInfo)\n  };\n}\n\nexport function prepareProgram(statements, loc) {\n  if (!loc && statements.length) {\n    const firstLoc = statements[0].loc,\n      lastLoc = statements[statements.length - 1].loc;\n\n    /* istanbul ignore else */\n    if (firstLoc && lastLoc) {\n      loc = {\n        source: firstLoc.source,\n        start: {\n          line: firstLoc.start.line,\n          column: firstLoc.start.column\n        },\n        end: {\n          line: lastLoc.end.line,\n          column: lastLoc.end.column\n        }\n      };\n    }\n  }\n\n  return {\n    type: 'Program',\n    body: statements,\n    strip: {},\n    loc: loc\n  };\n}\n\nexport function preparePartialBlock(open, program, close, locInfo) {\n  validateClose(open, close);\n\n  return {\n    type: 'PartialBlockStatement',\n    name: open.path,\n    params: open.params,\n    hash: open.hash,\n    program,\n    openStrip: open.strip,\n    closeStrip: close && close.strip,\n    loc: this.locInfo(locInfo)\n  };\n}\n"]},"metadata":{},"sourceType":"script"}