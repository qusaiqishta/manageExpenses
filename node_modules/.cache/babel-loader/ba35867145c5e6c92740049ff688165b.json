{"ast":null,"code":"const utils = require('./utils');\nclass Cell {\n  /**\n   * A representation of a cell within the table.\n   * Implementations must have `init` and `draw` methods,\n   * as well as `colSpan`, `rowSpan`, `desiredHeight` and `desiredWidth` properties.\n   * @param options\n   * @constructor\n   */\n  constructor(options) {\n    this.setOptions(options);\n\n    /**\n     * Each cell will have it's `x` and `y` values set by the `layout-manager` prior to\n     * `init` being called;\n     * @type {Number}\n     */\n    this.x = null;\n    this.y = null;\n  }\n  setOptions(options) {\n    if (['boolean', 'number', 'string'].indexOf(typeof options) !== -1) {\n      options = {\n        content: '' + options\n      };\n    }\n    options = options || {};\n    this.options = options;\n    let content = options.content;\n    if (['boolean', 'number', 'string'].indexOf(typeof content) !== -1) {\n      this.content = String(content);\n    } else if (!content) {\n      this.content = '';\n    } else {\n      throw new Error('Content needs to be a primitive, got: ' + typeof content);\n    }\n    this.colSpan = options.colSpan || 1;\n    this.rowSpan = options.rowSpan || 1;\n  }\n  mergeTableOptions(tableOptions, cells) {\n    this.cells = cells;\n    let optionsChars = this.options.chars || {};\n    let tableChars = tableOptions.chars;\n    let chars = this.chars = {};\n    CHAR_NAMES.forEach(function (name) {\n      setOption(optionsChars, tableChars, name, chars);\n    });\n    this.truncate = this.options.truncate || tableOptions.truncate;\n    let style = this.options.style = this.options.style || {};\n    let tableStyle = tableOptions.style;\n    setOption(style, tableStyle, 'padding-left', this);\n    setOption(style, tableStyle, 'padding-right', this);\n    this.head = style.head || tableStyle.head;\n    this.border = style.border || tableStyle.border;\n    let fixedWidth = tableOptions.colWidths[this.x];\n    if (tableOptions.wordWrap && fixedWidth) {\n      fixedWidth -= this.paddingLeft + this.paddingRight;\n      if (this.colSpan) {\n        let i = 1;\n        while (i < this.colSpan) {\n          fixedWidth += tableOptions.colWidths[this.x + i];\n          i++;\n        }\n      }\n      this.lines = utils.colorizeLines(utils.wordWrap(fixedWidth, this.content));\n    } else {\n      this.lines = utils.colorizeLines(this.content.split('\\n'));\n    }\n    this.desiredWidth = utils.strlen(this.content) + this.paddingLeft + this.paddingRight;\n    this.desiredHeight = this.lines.length;\n  }\n\n  /**\n   * Initializes the Cells data structure.\n   *\n   * @param tableOptions - A fully populated set of tableOptions.\n   * In addition to the standard default values, tableOptions must have fully populated the\n   * `colWidths` and `rowWidths` arrays. Those arrays must have lengths equal to the number\n   * of columns or rows (respectively) in this table, and each array item must be a Number.\n   *\n   */\n  init(tableOptions) {\n    let x = this.x;\n    let y = this.y;\n    this.widths = tableOptions.colWidths.slice(x, x + this.colSpan);\n    this.heights = tableOptions.rowHeights.slice(y, y + this.rowSpan);\n    this.width = this.widths.reduce(sumPlusOne, -1);\n    this.height = this.heights.reduce(sumPlusOne, -1);\n    this.hAlign = this.options.hAlign || tableOptions.colAligns[x];\n    this.vAlign = this.options.vAlign || tableOptions.rowAligns[y];\n    this.drawRight = x + this.colSpan == tableOptions.colWidths.length;\n  }\n\n  /**\n   * Draws the given line of the cell.\n   * This default implementation defers to methods `drawTop`, `drawBottom`, `drawLine` and `drawEmpty`.\n   * @param lineNum - can be `top`, `bottom` or a numerical line number.\n   * @param spanningCell - will be a number if being called from a RowSpanCell, and will represent how\n   * many rows below it's being called from. Otherwise it's undefined.\n   * @returns {String} The representation of this line.\n   */\n  draw(lineNum, spanningCell) {\n    if (lineNum == 'top') return this.drawTop(this.drawRight);\n    if (lineNum == 'bottom') return this.drawBottom(this.drawRight);\n    let padLen = Math.max(this.height - this.lines.length, 0);\n    let padTop;\n    switch (this.vAlign) {\n      case 'center':\n        padTop = Math.ceil(padLen / 2);\n        break;\n      case 'bottom':\n        padTop = padLen;\n        break;\n      default:\n        padTop = 0;\n    }\n    if (lineNum < padTop || lineNum >= padTop + this.lines.length) {\n      return this.drawEmpty(this.drawRight, spanningCell);\n    }\n    let forceTruncation = this.lines.length > this.height && lineNum + 1 >= this.height;\n    return this.drawLine(lineNum - padTop, this.drawRight, forceTruncation, spanningCell);\n  }\n\n  /**\n   * Renders the top line of the cell.\n   * @param drawRight - true if this method should render the right edge of the cell.\n   * @returns {String}\n   */\n  drawTop(drawRight) {\n    let content = [];\n    if (this.cells) {\n      //TODO: cells should always exist - some tests don't fill it in though\n      this.widths.forEach(function (width, index) {\n        content.push(this._topLeftChar(index));\n        content.push(utils.repeat(this.chars[this.y == 0 ? 'top' : 'mid'], width));\n      }, this);\n    } else {\n      content.push(this._topLeftChar(0));\n      content.push(utils.repeat(this.chars[this.y == 0 ? 'top' : 'mid'], this.width));\n    }\n    if (drawRight) {\n      content.push(this.chars[this.y == 0 ? 'topRight' : 'rightMid']);\n    }\n    return this.wrapWithStyleColors('border', content.join(''));\n  }\n  _topLeftChar(offset) {\n    let x = this.x + offset;\n    let leftChar;\n    if (this.y == 0) {\n      leftChar = x == 0 ? 'topLeft' : offset == 0 ? 'topMid' : 'top';\n    } else {\n      if (x == 0) {\n        leftChar = 'leftMid';\n      } else {\n        leftChar = offset == 0 ? 'midMid' : 'bottomMid';\n        if (this.cells) {\n          //TODO: cells should always exist - some tests don't fill it in though\n          let spanAbove = this.cells[this.y - 1][x] instanceof Cell.ColSpanCell;\n          if (spanAbove) {\n            leftChar = offset == 0 ? 'topMid' : 'mid';\n          }\n          if (offset == 0) {\n            let i = 1;\n            while (this.cells[this.y][x - i] instanceof Cell.ColSpanCell) {\n              i++;\n            }\n            if (this.cells[this.y][x - i] instanceof Cell.RowSpanCell) {\n              leftChar = 'leftMid';\n            }\n          }\n        }\n      }\n    }\n    return this.chars[leftChar];\n  }\n  wrapWithStyleColors(styleProperty, content) {\n    if (this[styleProperty] && this[styleProperty].length) {\n      try {\n        let colors = require('colors/safe');\n        for (let i = this[styleProperty].length - 1; i >= 0; i--) {\n          colors = colors[this[styleProperty][i]];\n        }\n        return colors(content);\n      } catch (e) {\n        return content;\n      }\n    } else {\n      return content;\n    }\n  }\n\n  /**\n   * Renders a line of text.\n   * @param lineNum - Which line of text to render. This is not necessarily the line within the cell.\n   * There may be top-padding above the first line of text.\n   * @param drawRight - true if this method should render the right edge of the cell.\n   * @param forceTruncationSymbol - `true` if the rendered text should end with the truncation symbol even\n   * if the text fits. This is used when the cell is vertically truncated. If `false` the text should\n   * only include the truncation symbol if the text will not fit horizontally within the cell width.\n   * @param spanningCell - a number of if being called from a RowSpanCell. (how many rows below). otherwise undefined.\n   * @returns {String}\n   */\n  drawLine(lineNum, drawRight, forceTruncationSymbol, spanningCell) {\n    let left = this.chars[this.x == 0 ? 'left' : 'middle'];\n    if (this.x && spanningCell && this.cells) {\n      let cellLeft = this.cells[this.y + spanningCell][this.x - 1];\n      while (cellLeft instanceof ColSpanCell) {\n        cellLeft = this.cells[cellLeft.y][cellLeft.x - 1];\n      }\n      if (!(cellLeft instanceof RowSpanCell)) {\n        left = this.chars['rightMid'];\n      }\n    }\n    let leftPadding = utils.repeat(' ', this.paddingLeft);\n    let right = drawRight ? this.chars['right'] : '';\n    let rightPadding = utils.repeat(' ', this.paddingRight);\n    let line = this.lines[lineNum];\n    let len = this.width - (this.paddingLeft + this.paddingRight);\n    if (forceTruncationSymbol) line += this.truncate || '…';\n    let content = utils.truncate(line, len, this.truncate);\n    content = utils.pad(content, len, ' ', this.hAlign);\n    content = leftPadding + content + rightPadding;\n    return this.stylizeLine(left, content, right);\n  }\n  stylizeLine(left, content, right) {\n    left = this.wrapWithStyleColors('border', left);\n    right = this.wrapWithStyleColors('border', right);\n    if (this.y === 0) {\n      content = this.wrapWithStyleColors('head', content);\n    }\n    return left + content + right;\n  }\n\n  /**\n   * Renders the bottom line of the cell.\n   * @param drawRight - true if this method should render the right edge of the cell.\n   * @returns {String}\n   */\n  drawBottom(drawRight) {\n    let left = this.chars[this.x == 0 ? 'bottomLeft' : 'bottomMid'];\n    let content = utils.repeat(this.chars.bottom, this.width);\n    let right = drawRight ? this.chars['bottomRight'] : '';\n    return this.wrapWithStyleColors('border', left + content + right);\n  }\n\n  /**\n   * Renders a blank line of text within the cell. Used for top and/or bottom padding.\n   * @param drawRight - true if this method should render the right edge of the cell.\n   * @param spanningCell - a number of if being called from a RowSpanCell. (how many rows below). otherwise undefined.\n   * @returns {String}\n   */\n  drawEmpty(drawRight, spanningCell) {\n    let left = this.chars[this.x == 0 ? 'left' : 'middle'];\n    if (this.x && spanningCell && this.cells) {\n      let cellLeft = this.cells[this.y + spanningCell][this.x - 1];\n      while (cellLeft instanceof ColSpanCell) {\n        cellLeft = this.cells[cellLeft.y][cellLeft.x - 1];\n      }\n      if (!(cellLeft instanceof RowSpanCell)) {\n        left = this.chars['rightMid'];\n      }\n    }\n    let right = drawRight ? this.chars['right'] : '';\n    let content = utils.repeat(' ', this.width);\n    return this.stylizeLine(left, content, right);\n  }\n}\nclass ColSpanCell {\n  /**\n   * A Cell that doesn't do anything. It just draws empty lines.\n   * Used as a placeholder in column spanning.\n   * @constructor\n   */\n  constructor() {}\n  draw() {\n    return '';\n  }\n  init() {}\n  mergeTableOptions() {}\n}\nclass RowSpanCell {\n  /**\n   * A placeholder Cell for a Cell that spans multiple rows.\n   * It delegates rendering to the original cell, but adds the appropriate offset.\n   * @param originalCell\n   * @constructor\n   */\n  constructor(originalCell) {\n    this.originalCell = originalCell;\n  }\n  init(tableOptions) {\n    let y = this.y;\n    let originalY = this.originalCell.y;\n    this.cellOffset = y - originalY;\n    this.offset = findDimension(tableOptions.rowHeights, originalY, this.cellOffset);\n  }\n  draw(lineNum) {\n    if (lineNum == 'top') {\n      return this.originalCell.draw(this.offset, this.cellOffset);\n    }\n    if (lineNum == 'bottom') {\n      return this.originalCell.draw('bottom');\n    }\n    return this.originalCell.draw(this.offset + 1 + lineNum);\n  }\n  mergeTableOptions() {}\n}\n\n// HELPER FUNCTIONS\nfunction setOption(objA, objB, nameB, targetObj) {\n  let nameA = nameB.split('-');\n  if (nameA.length > 1) {\n    nameA[1] = nameA[1].charAt(0).toUpperCase() + nameA[1].substr(1);\n    nameA = nameA.join('');\n    targetObj[nameA] = objA[nameA] || objA[nameB] || objB[nameA] || objB[nameB];\n  } else {\n    targetObj[nameB] = objA[nameB] || objB[nameB];\n  }\n}\nfunction findDimension(dimensionTable, startingIndex, span) {\n  let ret = dimensionTable[startingIndex];\n  for (let i = 1; i < span; i++) {\n    ret += 1 + dimensionTable[startingIndex + i];\n  }\n  return ret;\n}\nfunction sumPlusOne(a, b) {\n  return a + b + 1;\n}\nlet CHAR_NAMES = ['top', 'top-mid', 'top-left', 'top-right', 'bottom', 'bottom-mid', 'bottom-left', 'bottom-right', 'left', 'left-mid', 'mid', 'mid-mid', 'right', 'right-mid', 'middle'];\nmodule.exports = Cell;\nmodule.exports.ColSpanCell = ColSpanCell;\nmodule.exports.RowSpanCell = RowSpanCell;","map":{"version":3,"names":["utils","require","Cell","constructor","options","setOptions","x","y","indexOf","content","String","Error","colSpan","rowSpan","mergeTableOptions","tableOptions","cells","optionsChars","chars","tableChars","CHAR_NAMES","forEach","name","setOption","truncate","style","tableStyle","head","border","fixedWidth","colWidths","wordWrap","paddingLeft","paddingRight","i","lines","colorizeLines","split","desiredWidth","strlen","desiredHeight","length","init","widths","slice","heights","rowHeights","width","reduce","sumPlusOne","height","hAlign","colAligns","vAlign","rowAligns","drawRight","draw","lineNum","spanningCell","drawTop","drawBottom","padLen","Math","max","padTop","ceil","drawEmpty","forceTruncation","drawLine","index","push","_topLeftChar","repeat","wrapWithStyleColors","join","offset","leftChar","spanAbove","ColSpanCell","RowSpanCell","styleProperty","colors","e","forceTruncationSymbol","left","cellLeft","leftPadding","right","rightPadding","line","len","pad","stylizeLine","bottom","originalCell","originalY","cellOffset","findDimension","objA","objB","nameB","targetObj","nameA","charAt","toUpperCase","substr","dimensionTable","startingIndex","span","ret","a","b","module","exports"],"sources":["/Users/Qusai.Qishta/node_modules/cli-table3/src/cell.js"],"sourcesContent":["const utils = require('./utils');\n\nclass Cell {\n  /**\n   * A representation of a cell within the table.\n   * Implementations must have `init` and `draw` methods,\n   * as well as `colSpan`, `rowSpan`, `desiredHeight` and `desiredWidth` properties.\n   * @param options\n   * @constructor\n   */\n  constructor(options) {\n    this.setOptions(options);\n\n    /**\n     * Each cell will have it's `x` and `y` values set by the `layout-manager` prior to\n     * `init` being called;\n     * @type {Number}\n     */\n    this.x = null;\n    this.y = null;\n  }\n\n  setOptions(options) {\n    if (['boolean', 'number', 'string'].indexOf(typeof options) !== -1) {\n      options = { content: '' + options };\n    }\n    options = options || {};\n    this.options = options;\n    let content = options.content;\n    if (['boolean', 'number', 'string'].indexOf(typeof content) !== -1) {\n      this.content = String(content);\n    } else if (!content) {\n      this.content = '';\n    } else {\n      throw new Error('Content needs to be a primitive, got: ' + typeof content);\n    }\n    this.colSpan = options.colSpan || 1;\n    this.rowSpan = options.rowSpan || 1;\n  }\n\n  mergeTableOptions(tableOptions, cells) {\n    this.cells = cells;\n\n    let optionsChars = this.options.chars || {};\n    let tableChars = tableOptions.chars;\n    let chars = (this.chars = {});\n    CHAR_NAMES.forEach(function (name) {\n      setOption(optionsChars, tableChars, name, chars);\n    });\n\n    this.truncate = this.options.truncate || tableOptions.truncate;\n\n    let style = (this.options.style = this.options.style || {});\n    let tableStyle = tableOptions.style;\n    setOption(style, tableStyle, 'padding-left', this);\n    setOption(style, tableStyle, 'padding-right', this);\n    this.head = style.head || tableStyle.head;\n    this.border = style.border || tableStyle.border;\n\n    let fixedWidth = tableOptions.colWidths[this.x];\n    if (tableOptions.wordWrap && fixedWidth) {\n      fixedWidth -= this.paddingLeft + this.paddingRight;\n      if (this.colSpan) {\n        let i = 1;\n        while (i < this.colSpan) {\n          fixedWidth += tableOptions.colWidths[this.x + i];\n          i++;\n        }\n      }\n      this.lines = utils.colorizeLines(utils.wordWrap(fixedWidth, this.content));\n    } else {\n      this.lines = utils.colorizeLines(this.content.split('\\n'));\n    }\n\n    this.desiredWidth = utils.strlen(this.content) + this.paddingLeft + this.paddingRight;\n    this.desiredHeight = this.lines.length;\n  }\n\n  /**\n   * Initializes the Cells data structure.\n   *\n   * @param tableOptions - A fully populated set of tableOptions.\n   * In addition to the standard default values, tableOptions must have fully populated the\n   * `colWidths` and `rowWidths` arrays. Those arrays must have lengths equal to the number\n   * of columns or rows (respectively) in this table, and each array item must be a Number.\n   *\n   */\n  init(tableOptions) {\n    let x = this.x;\n    let y = this.y;\n    this.widths = tableOptions.colWidths.slice(x, x + this.colSpan);\n    this.heights = tableOptions.rowHeights.slice(y, y + this.rowSpan);\n    this.width = this.widths.reduce(sumPlusOne, -1);\n    this.height = this.heights.reduce(sumPlusOne, -1);\n\n    this.hAlign = this.options.hAlign || tableOptions.colAligns[x];\n    this.vAlign = this.options.vAlign || tableOptions.rowAligns[y];\n\n    this.drawRight = x + this.colSpan == tableOptions.colWidths.length;\n  }\n\n  /**\n   * Draws the given line of the cell.\n   * This default implementation defers to methods `drawTop`, `drawBottom`, `drawLine` and `drawEmpty`.\n   * @param lineNum - can be `top`, `bottom` or a numerical line number.\n   * @param spanningCell - will be a number if being called from a RowSpanCell, and will represent how\n   * many rows below it's being called from. Otherwise it's undefined.\n   * @returns {String} The representation of this line.\n   */\n  draw(lineNum, spanningCell) {\n    if (lineNum == 'top') return this.drawTop(this.drawRight);\n    if (lineNum == 'bottom') return this.drawBottom(this.drawRight);\n    let padLen = Math.max(this.height - this.lines.length, 0);\n    let padTop;\n    switch (this.vAlign) {\n      case 'center':\n        padTop = Math.ceil(padLen / 2);\n        break;\n      case 'bottom':\n        padTop = padLen;\n        break;\n      default:\n        padTop = 0;\n    }\n    if (lineNum < padTop || lineNum >= padTop + this.lines.length) {\n      return this.drawEmpty(this.drawRight, spanningCell);\n    }\n    let forceTruncation = this.lines.length > this.height && lineNum + 1 >= this.height;\n    return this.drawLine(lineNum - padTop, this.drawRight, forceTruncation, spanningCell);\n  }\n\n  /**\n   * Renders the top line of the cell.\n   * @param drawRight - true if this method should render the right edge of the cell.\n   * @returns {String}\n   */\n  drawTop(drawRight) {\n    let content = [];\n    if (this.cells) {\n      //TODO: cells should always exist - some tests don't fill it in though\n      this.widths.forEach(function (width, index) {\n        content.push(this._topLeftChar(index));\n        content.push(utils.repeat(this.chars[this.y == 0 ? 'top' : 'mid'], width));\n      }, this);\n    } else {\n      content.push(this._topLeftChar(0));\n      content.push(utils.repeat(this.chars[this.y == 0 ? 'top' : 'mid'], this.width));\n    }\n    if (drawRight) {\n      content.push(this.chars[this.y == 0 ? 'topRight' : 'rightMid']);\n    }\n    return this.wrapWithStyleColors('border', content.join(''));\n  }\n\n  _topLeftChar(offset) {\n    let x = this.x + offset;\n    let leftChar;\n    if (this.y == 0) {\n      leftChar = x == 0 ? 'topLeft' : offset == 0 ? 'topMid' : 'top';\n    } else {\n      if (x == 0) {\n        leftChar = 'leftMid';\n      } else {\n        leftChar = offset == 0 ? 'midMid' : 'bottomMid';\n        if (this.cells) {\n          //TODO: cells should always exist - some tests don't fill it in though\n          let spanAbove = this.cells[this.y - 1][x] instanceof Cell.ColSpanCell;\n          if (spanAbove) {\n            leftChar = offset == 0 ? 'topMid' : 'mid';\n          }\n          if (offset == 0) {\n            let i = 1;\n            while (this.cells[this.y][x - i] instanceof Cell.ColSpanCell) {\n              i++;\n            }\n            if (this.cells[this.y][x - i] instanceof Cell.RowSpanCell) {\n              leftChar = 'leftMid';\n            }\n          }\n        }\n      }\n    }\n    return this.chars[leftChar];\n  }\n\n  wrapWithStyleColors(styleProperty, content) {\n    if (this[styleProperty] && this[styleProperty].length) {\n      try {\n        let colors = require('colors/safe');\n        for (let i = this[styleProperty].length - 1; i >= 0; i--) {\n          colors = colors[this[styleProperty][i]];\n        }\n        return colors(content);\n      } catch (e) {\n        return content;\n      }\n    } else {\n      return content;\n    }\n  }\n\n  /**\n   * Renders a line of text.\n   * @param lineNum - Which line of text to render. This is not necessarily the line within the cell.\n   * There may be top-padding above the first line of text.\n   * @param drawRight - true if this method should render the right edge of the cell.\n   * @param forceTruncationSymbol - `true` if the rendered text should end with the truncation symbol even\n   * if the text fits. This is used when the cell is vertically truncated. If `false` the text should\n   * only include the truncation symbol if the text will not fit horizontally within the cell width.\n   * @param spanningCell - a number of if being called from a RowSpanCell. (how many rows below). otherwise undefined.\n   * @returns {String}\n   */\n  drawLine(lineNum, drawRight, forceTruncationSymbol, spanningCell) {\n    let left = this.chars[this.x == 0 ? 'left' : 'middle'];\n    if (this.x && spanningCell && this.cells) {\n      let cellLeft = this.cells[this.y + spanningCell][this.x - 1];\n      while (cellLeft instanceof ColSpanCell) {\n        cellLeft = this.cells[cellLeft.y][cellLeft.x - 1];\n      }\n      if (!(cellLeft instanceof RowSpanCell)) {\n        left = this.chars['rightMid'];\n      }\n    }\n    let leftPadding = utils.repeat(' ', this.paddingLeft);\n    let right = drawRight ? this.chars['right'] : '';\n    let rightPadding = utils.repeat(' ', this.paddingRight);\n    let line = this.lines[lineNum];\n    let len = this.width - (this.paddingLeft + this.paddingRight);\n    if (forceTruncationSymbol) line += this.truncate || '…';\n    let content = utils.truncate(line, len, this.truncate);\n    content = utils.pad(content, len, ' ', this.hAlign);\n    content = leftPadding + content + rightPadding;\n    return this.stylizeLine(left, content, right);\n  }\n\n  stylizeLine(left, content, right) {\n    left = this.wrapWithStyleColors('border', left);\n    right = this.wrapWithStyleColors('border', right);\n    if (this.y === 0) {\n      content = this.wrapWithStyleColors('head', content);\n    }\n    return left + content + right;\n  }\n\n  /**\n   * Renders the bottom line of the cell.\n   * @param drawRight - true if this method should render the right edge of the cell.\n   * @returns {String}\n   */\n  drawBottom(drawRight) {\n    let left = this.chars[this.x == 0 ? 'bottomLeft' : 'bottomMid'];\n    let content = utils.repeat(this.chars.bottom, this.width);\n    let right = drawRight ? this.chars['bottomRight'] : '';\n    return this.wrapWithStyleColors('border', left + content + right);\n  }\n\n  /**\n   * Renders a blank line of text within the cell. Used for top and/or bottom padding.\n   * @param drawRight - true if this method should render the right edge of the cell.\n   * @param spanningCell - a number of if being called from a RowSpanCell. (how many rows below). otherwise undefined.\n   * @returns {String}\n   */\n  drawEmpty(drawRight, spanningCell) {\n    let left = this.chars[this.x == 0 ? 'left' : 'middle'];\n    if (this.x && spanningCell && this.cells) {\n      let cellLeft = this.cells[this.y + spanningCell][this.x - 1];\n      while (cellLeft instanceof ColSpanCell) {\n        cellLeft = this.cells[cellLeft.y][cellLeft.x - 1];\n      }\n      if (!(cellLeft instanceof RowSpanCell)) {\n        left = this.chars['rightMid'];\n      }\n    }\n    let right = drawRight ? this.chars['right'] : '';\n    let content = utils.repeat(' ', this.width);\n    return this.stylizeLine(left, content, right);\n  }\n}\n\nclass ColSpanCell {\n  /**\n   * A Cell that doesn't do anything. It just draws empty lines.\n   * Used as a placeholder in column spanning.\n   * @constructor\n   */\n  constructor() {}\n\n  draw() {\n    return '';\n  }\n\n  init() {}\n\n  mergeTableOptions() {}\n}\n\nclass RowSpanCell {\n  /**\n   * A placeholder Cell for a Cell that spans multiple rows.\n   * It delegates rendering to the original cell, but adds the appropriate offset.\n   * @param originalCell\n   * @constructor\n   */\n  constructor(originalCell) {\n    this.originalCell = originalCell;\n  }\n\n  init(tableOptions) {\n    let y = this.y;\n    let originalY = this.originalCell.y;\n    this.cellOffset = y - originalY;\n    this.offset = findDimension(tableOptions.rowHeights, originalY, this.cellOffset);\n  }\n\n  draw(lineNum) {\n    if (lineNum == 'top') {\n      return this.originalCell.draw(this.offset, this.cellOffset);\n    }\n    if (lineNum == 'bottom') {\n      return this.originalCell.draw('bottom');\n    }\n    return this.originalCell.draw(this.offset + 1 + lineNum);\n  }\n\n  mergeTableOptions() {}\n}\n\n// HELPER FUNCTIONS\nfunction setOption(objA, objB, nameB, targetObj) {\n  let nameA = nameB.split('-');\n  if (nameA.length > 1) {\n    nameA[1] = nameA[1].charAt(0).toUpperCase() + nameA[1].substr(1);\n    nameA = nameA.join('');\n    targetObj[nameA] = objA[nameA] || objA[nameB] || objB[nameA] || objB[nameB];\n  } else {\n    targetObj[nameB] = objA[nameB] || objB[nameB];\n  }\n}\n\nfunction findDimension(dimensionTable, startingIndex, span) {\n  let ret = dimensionTable[startingIndex];\n  for (let i = 1; i < span; i++) {\n    ret += 1 + dimensionTable[startingIndex + i];\n  }\n  return ret;\n}\n\nfunction sumPlusOne(a, b) {\n  return a + b + 1;\n}\n\nlet CHAR_NAMES = [\n  'top',\n  'top-mid',\n  'top-left',\n  'top-right',\n  'bottom',\n  'bottom-mid',\n  'bottom-left',\n  'bottom-right',\n  'left',\n  'left-mid',\n  'mid',\n  'mid-mid',\n  'right',\n  'right-mid',\n  'middle',\n];\nmodule.exports = Cell;\nmodule.exports.ColSpanCell = ColSpanCell;\nmodule.exports.RowSpanCell = RowSpanCell;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}