{"ast":null,"code":"var _ = require('lodash'),\n  asyncEach = require('async/each'),\n  sdk = require('postman-collection'),\n  runtime = require('postman-runtime'),\n  request = require('postman-request'),\n  EventEmitter = require('eventemitter3'),\n  SecureFS = require('./secure-fs'),\n  RunSummary = require('./summary'),\n  getOptions = require('./options'),\n  exportFile = require('./export-file'),\n  util = require('../util'),\n  /**\n   * This object describes the various events raised by Newman, and what each event argument contains.\n   * Error and cursor are present in all events.\n   *\n   * @type {Object}\n   */\n  runtimeEvents = {\n    beforeIteration: [],\n    beforeItem: ['item'],\n    beforePrerequest: ['events', 'item'],\n    prerequest: ['executions', 'item'],\n    beforeRequest: ['request', 'item'],\n    request: ['response', 'request', 'item', 'cookies', 'history'],\n    beforeTest: ['events', 'item'],\n    test: ['executions', 'item'],\n    item: ['item'],\n    iteration: [],\n    beforeScript: ['script', 'event', 'item'],\n    script: ['execution', 'script', 'event', 'item']\n  },\n  /**\n   * load all the default reporters here. if you have new reporter, add it to this list\n   * we know someone, who does not like dynamic requires\n   *\n   * @type {Object}\n   */\n  defaultReporters = {\n    cli: require('../reporters/cli'),\n    json: require('../reporters/json'),\n    junit: require('../reporters/junit'),\n    progress: require('../reporters/progress'),\n    emojitrain: require('../reporters/emojitrain')\n  },\n  /**\n   * The object of known reporters and their install instruction in case the reporter is not loaded.\n   * Pad message with two spaces since its a follow-up message for reporter warning.\n   *\n   * @private\n   * @type {Object}\n   */\n  knownReporterErrorMessages = {\n    html: '  run `npm install newman-reporter-html`\\n',\n    teamcity: '  run `npm install newman-reporter-teamcity`\\n'\n  },\n  /**\n   * Multiple ids or names entrypoint lookup strategy.\n   *\n   * @private\n   * @type {String}\n   */\n  MULTIENTRY_LOOKUP_STRATEGY = 'multipleIdOrName';\n\n/**\n * Runs the collection, with all the provided options, returning an EventEmitter.\n *\n * @param {Object} options - The set of wrapped options, passed by the CLI parser.\n * @param {Collection|Object|String} options.collection - A JSON / Collection / String representing the collection.\n * @param {Object|String} options.environment - An environment JSON / file path for the current collection run.\n * @param {Object|String} options.globals - A globals JSON / file path for the current collection run.\n * @param {String} options.workingDir - Path of working directory that contains files needed for the collection run.\n * @param {String} options.insecureFileRead - If true, allow reading files outside of working directory.\n * @param {Object|String} options.iterationData - An iterationData JSON / file path for the current collection run.\n * @param {Object|String} options.reporters - A set of reporter names and their associated options for the current run.\n * @param {Object|String} options.cookieJar - A tough-cookie cookieJar / file path for the current collection run.\n * @param {String} options.exportGlobals - The relative path to export the globals file from the current run to.\n * @param {String} options.exportEnvironment - The relative path to export the environment file from the current run to.\n * @param {String} options.exportCollection - The relative path to export the collection from the current run to.\n * @param {String} options.exportCookieJar - The relative path to export the cookie jar from the current run to.\n * @param {Function} callback - The callback function invoked to mark the end of the collection run.\n * @returns {EventEmitter} - An EventEmitter instance with done and error event attachments.\n */\nmodule.exports = function (options, callback) {\n  // validate all options. it is to be noted that `options` parameter is option and is polymorphic\n  !callback && _.isFunction(options) && (callback = options, options = {});\n  !_.isFunction(callback) && (callback = _.noop);\n  var emitter = new EventEmitter(),\n    // @todo: create a new inherited constructor\n    runner = new runtime.Runner(),\n    stopOnFailure,\n    entrypoint;\n\n  // get the configuration from various sources\n  getOptions(options, function (err, options) {\n    if (err) {\n      return callback(err);\n    }\n\n    // ensure that the collection option is present before starting a run\n    if (!_.isObject(options.collection)) {\n      return callback(new Error('expecting a collection to run'));\n    }\n\n    // use client certificate list to allow different ssl certificates for\n    // different URLs\n    var sslClientCertList = options.sslClientCertList || [],\n      // allow providing custom cookieJar\n      cookieJar = options.cookieJar || request.jar();\n\n    // if sslClientCert option is set, put it at the end of the list to\n    // match all URLs that didn't match in the list\n    if (options.sslClientCert) {\n      sslClientCertList.push({\n        name: 'client-cert',\n        matches: [sdk.UrlMatchPattern.MATCH_ALL_URLS],\n        key: {\n          src: options.sslClientKey\n        },\n        cert: {\n          src: options.sslClientCert\n        },\n        passphrase: options.sslClientPassphrase\n      });\n    }\n\n    // iterates over the bail array and sets each item as an obj key with a value of boolean true\n    // [item1, item2] => {item1: true, item2: true}\n    if (_.isArray(options.bail)) {\n      options.bail = _.transform(options.bail, function (result, value) {\n        result[value] = true;\n      }, {});\n    }\n\n    // sets entrypoint to execute if options.folder is specified.\n    if (options.folder) {\n      entrypoint = {\n        execute: options.folder\n      };\n\n      // uses `multipleIdOrName` lookupStrategy in case of multiple folders.\n      _.isArray(entrypoint.execute) && (entrypoint.lookupStrategy = MULTIENTRY_LOOKUP_STRATEGY);\n    }\n\n    // sets stopOnFailure to true in case bail is used without any modifiers or with failure\n    // --bail => stopOnFailure = true\n    // --bail failure => stopOnFailure = true\n    typeof options.bail !== 'undefined' && (options.bail === true || _.isObject(options.bail) && options.bail.failure) ? stopOnFailure = true : stopOnFailure = false;\n\n    // store summary object and other relevant information inside the emitter\n    emitter.summary = new RunSummary(emitter, options);\n\n    // to store the exported content from reporters\n    emitter.exports = [];\n\n    // expose the runner object for reporter and programmatic use\n    emitter.runner = runner;\n\n    // now start the run!\n    runner.run(options.collection, {\n      stopOnFailure: stopOnFailure,\n      // LOL, you just got trolled ¯\\_(ツ)_/¯\n      abortOnFailure: options.abortOnFailure,\n      // used in integration tests, to be considered for a future release\n      abortOnError: _.get(options, 'bail.folder'),\n      iterationCount: options.iterationCount,\n      environment: options.environment,\n      globals: options.globals,\n      entrypoint: entrypoint,\n      data: options.iterationData,\n      delay: {\n        item: options.delayRequest\n      },\n      timeout: {\n        global: options.timeout || 0,\n        request: options.timeoutRequest || 0,\n        script: options.timeoutScript || 0\n      },\n      fileResolver: new SecureFS(options.workingDir, options.insecureFileRead),\n      requester: {\n        useWhatWGUrlParser: true,\n        cookieJar: cookieJar,\n        followRedirects: _.has(options, 'ignoreRedirects') ? !options.ignoreRedirects : undefined,\n        strictSSL: _.has(options, 'insecure') ? !options.insecure : undefined,\n        timings: Boolean(options.verbose),\n        extendedRootCA: options.sslExtraCaCerts,\n        agents: _.isObject(options.requestAgents) ? options.requestAgents : undefined\n      },\n      certificates: sslClientCertList.length && new sdk.CertificateList({}, sslClientCertList)\n    }, function (err, run) {\n      if (err) {\n        return callback(err);\n      }\n      var callbacks = {},\n        // ensure that the reporter option type polymorphism is handled\n        reporters = _.isString(options.reporters) ? [options.reporters] : options.reporters,\n        // keep a track of start assertion indices of legacy assertions\n        legacyAssertionIndices = {};\n\n      // emit events for all the callbacks triggered by the runtime\n      _.forEach(runtimeEvents, function (definition, eventName) {\n        // intercept each runtime.* callback and expose a global object based event\n        callbacks[eventName] = function (err, cursor) {\n          var args = arguments,\n            obj = {\n              cursor\n            };\n\n          // convert the arguments into an object by taking the key name reference from the definition\n          // object\n          _.forEach(definition, function (key, index) {\n            obj[key] = args[index + 2]; // first two are err, cursor\n          });\n\n          args = [eventName, err, obj];\n          emitter.emit.apply(emitter, args); // eslint-disable-line prefer-spread\n        };\n      });\n\n      // add non generic callback handling\n      _.assignIn(callbacks, {\n        /**\n         * Emits event for start of the run. It injects/exposes additional objects useful for\n         * programmatic usage and reporters\n         *\n         * @param {?Error} err - An Error instance / null object.\n         * @param {Object} cursor - The run cursor instance.\n         * @returns {*}\n         */\n        start(err, cursor) {\n          emitter.emit('start', err, {\n            cursor,\n            run\n          });\n        },\n        /**\n         * Bubbles up console messages.\n         *\n         * @param {Object} cursor - The run cursor instance.\n         * @param {String} level - The level of console logging [error, silent, etc].\n         * @returns {*}\n         */\n        console(cursor, level) {\n          emitter.emit('console', null, {\n            cursor: cursor,\n            level: level,\n            messages: _.slice(arguments, 2)\n          });\n        },\n        /**\n         * The exception handler for the current run instance.\n         *\n         * @todo Fix bug of arg order in runtime.\n         * @param {Object} cursor - The run cursor.\n         * @param {?Error} err - An Error instance / null object.\n         * @returns {*}\n         */\n        exception(cursor, err) {\n          emitter.emit('exception', null, {\n            cursor: cursor,\n            error: err\n          });\n        },\n        assertion(cursor, assertions) {\n          _.forEach(assertions, function (assertion) {\n            var errorName = _.get(assertion, 'error.name', 'AssertionError');\n            !assertion && (assertion = {});\n\n            // store the legacy assertion index\n            assertion.index && (legacyAssertionIndices[cursor.ref] = assertion.index);\n            emitter.emit('assertion', assertion.passed ? null : {\n              name: errorName,\n              index: assertion.index,\n              test: assertion.name,\n              message: _.get(assertion, 'error.message', assertion.name || ''),\n              stack: errorName + ': ' + _.get(assertion, 'error.message', '') + '\\n' + '   at Object.eval sandbox-script.js:' + (assertion.index + 1) + ':' + ((cursor && cursor.position || 0) + 1) + ')'\n            }, {\n              cursor: cursor,\n              assertion: assertion.name,\n              skipped: assertion.skipped,\n              error: assertion.error,\n              item: run.resolveCursor(cursor)\n            });\n          });\n        },\n        /**\n         * Custom callback to override the `done` event to fire the end callback.\n         *\n         * @todo Do some memory cleanup here?\n         * @param {?Error} err - An error instance / null passed from the done event handler.\n         * @param {Object} cursor - The run instance cursor.\n         * @returns {*}\n         */\n        done(err, cursor) {\n          // in case runtime faced an error during run, we do not process any other event and emit `done`.\n          // we do it this way since, an error in `done` callback would have anyway skipped any intermediate\n          // events or callbacks\n          if (err) {\n            emitter.emit('done', err, emitter.summary);\n            callback(err, emitter.summary);\n            return;\n          }\n\n          // we emit a `beforeDone` event so that reporters and other such addons can do computation before\n          // the run is marked as done\n          emitter.emit('beforeDone', null, {\n            cursor: cursor,\n            summary: emitter.summary\n          });\n          _.forEach(['environment', 'globals', 'collection', 'cookie-jar'], function (item) {\n            // fetch the path name from options if one is provided\n            var path = _.get(options, _.camelCase(`export-${item}`));\n\n            // if the options have an export path, then add the item to export queue\n            path && emitter.exports.push({\n              name: item,\n              default: `newman-${item}.json`,\n              path: path,\n              content: item === 'cookie-jar' ? cookieJar.toJSON() : _(emitter.summary[item].toJSON()).defaults({\n                name: item\n              }).merge({\n                _postman_variable_scope: item,\n                _postman_exported_at: new Date().toISOString(),\n                _postman_exported_using: util.userAgent\n              }).value()\n            });\n          });\n          asyncEach(emitter.exports, exportFile, function (err) {\n            // we now trigger actual done event which we had overridden\n            emitter.emit('done', err, emitter.summary);\n            callback(err, emitter.summary);\n          });\n        }\n      });\n      emitter.on('script', function (err, o) {\n        // bubble special script name based events\n        o && o.event && emitter.emit(o.event.listen + 'Script', err, o);\n      });\n      emitter.on('beforeScript', function (err, o) {\n        // bubble special script name based events\n        o && o.event && emitter.emit(_.camelCase('before-' + o.event.listen + 'Script'), err, o);\n      });\n\n      // initialise all the reporters\n      !emitter.reporters && (emitter.reporters = {});\n      _.isArray(reporters) && _.forEach(reporters, function (reporterName) {\n        // disallow duplicate reporter initialisation\n        if (_.has(emitter.reporters, reporterName)) {\n          return;\n        }\n        var Reporter;\n        try {\n          // check if the reporter is an external reporter\n          Reporter = require(function (name) {\n            // ensure scoped packages are loaded\n            var prefix = '',\n              scope = name.charAt(0) === '@' && name.substr(0, name.indexOf('/') + 1);\n            if (scope) {\n              prefix = scope;\n              name = name.substr(scope.length);\n            }\n            return prefix + 'newman-reporter-' + name;\n          }(reporterName));\n        }\n        // @todo - maybe have a debug mode and log error there\n        catch (error) {\n          if (!defaultReporters[reporterName]) {\n            // @todo: route this via print module to respect silent flags\n            console.warn(`newman: could not find \"${reporterName}\" reporter`);\n            console.warn('  ensure that the reporter is installed in the same directory as newman');\n\n            // print install instruction in case a known reporter is missing\n            if (knownReporterErrorMessages[reporterName]) {\n              console.warn(knownReporterErrorMessages[reporterName]);\n            } else {\n              console.warn('  please install reporter using npm\\n');\n            }\n          }\n        }\n\n        // load local reporter if its not an external reporter\n        !Reporter && (Reporter = defaultReporters[reporterName]);\n        try {\n          // we could have checked _.isFunction(Reporter), here, but we do not do that so that the nature of\n          // reporter error can be bubbled up\n          Reporter && (emitter.reporters[reporterName] = new Reporter(emitter, _.get(options, ['reporter', reporterName], {}), options));\n        } catch (error) {\n          // if the reporter errored out during initialisation, we should not stop the run simply log\n          // the error stack trace for debugging\n          console.warn(`newman: could not load \"${reporterName}\" reporter`);\n          if (!defaultReporters[reporterName]) {\n            // @todo: route this via print module to respect silent flags\n            console.warn(`  this seems to be a problem in the \"${reporterName}\" reporter.\\n`);\n          }\n          console.warn(error);\n        }\n      });\n\n      // raise warning when more than one dominant reporters are used\n      (function (reporters) {\n        // find all reporters whose `dominant` key is set to true\n        var conflicts = _.keys(_.transform(reporters, function (conflicts, reporter, name) {\n          reporter.dominant && (conflicts[name] = true);\n        }));\n        conflicts.length > 1 &&\n        // if more than one dominant, raise a warning\n        console.warn(`newman: ${conflicts.join(', ')} reporters might not work well together.`);\n      })(emitter.reporters);\n\n      // we ensure that everything is async to comply with event paradigm and start the run\n      setImmediate(function () {\n        run.start(callbacks);\n      });\n    });\n  });\n  return emitter;\n};","map":{"version":3,"names":["_","require","asyncEach","sdk","runtime","request","EventEmitter","SecureFS","RunSummary","getOptions","exportFile","util","runtimeEvents","beforeIteration","beforeItem","beforePrerequest","prerequest","beforeRequest","beforeTest","test","item","iteration","beforeScript","script","defaultReporters","cli","json","junit","progress","emojitrain","knownReporterErrorMessages","html","teamcity","MULTIENTRY_LOOKUP_STRATEGY","module","exports","options","callback","isFunction","noop","emitter","runner","Runner","stopOnFailure","entrypoint","err","isObject","collection","Error","sslClientCertList","cookieJar","jar","sslClientCert","push","name","matches","UrlMatchPattern","MATCH_ALL_URLS","key","src","sslClientKey","cert","passphrase","sslClientPassphrase","isArray","bail","transform","result","value","folder","execute","lookupStrategy","failure","summary","run","abortOnFailure","abortOnError","get","iterationCount","environment","globals","data","iterationData","delay","delayRequest","timeout","global","timeoutRequest","timeoutScript","fileResolver","workingDir","insecureFileRead","requester","useWhatWGUrlParser","followRedirects","has","ignoreRedirects","undefined","strictSSL","insecure","timings","Boolean","verbose","extendedRootCA","sslExtraCaCerts","agents","requestAgents","certificates","length","CertificateList","callbacks","reporters","isString","legacyAssertionIndices","forEach","definition","eventName","cursor","args","arguments","obj","index","emit","apply","assignIn","start","console","level","messages","slice","exception","error","assertion","assertions","errorName","ref","passed","message","stack","position","skipped","resolveCursor","done","path","camelCase","default","content","toJSON","defaults","merge","_postman_variable_scope","_postman_exported_at","Date","toISOString","_postman_exported_using","userAgent","on","o","event","listen","reporterName","Reporter","prefix","scope","charAt","substr","indexOf","warn","conflicts","keys","reporter","dominant","join","setImmediate"],"sources":["/Users/Qusai.Qishta/node_modules/newman/lib/run/index.js"],"sourcesContent":["var _ = require('lodash'),\n    asyncEach = require('async/each'),\n    sdk = require('postman-collection'),\n    runtime = require('postman-runtime'),\n    request = require('postman-request'),\n    EventEmitter = require('eventemitter3'),\n    SecureFS = require('./secure-fs'),\n    RunSummary = require('./summary'),\n    getOptions = require('./options'),\n    exportFile = require('./export-file'),\n    util = require('../util'),\n\n    /**\n     * This object describes the various events raised by Newman, and what each event argument contains.\n     * Error and cursor are present in all events.\n     *\n     * @type {Object}\n     */\n    runtimeEvents = {\n        beforeIteration: [],\n        beforeItem: ['item'],\n        beforePrerequest: ['events', 'item'],\n        prerequest: ['executions', 'item'],\n        beforeRequest: ['request', 'item'],\n        request: ['response', 'request', 'item', 'cookies', 'history'],\n        beforeTest: ['events', 'item'],\n        test: ['executions', 'item'],\n        item: ['item'],\n        iteration: [],\n        beforeScript: ['script', 'event', 'item'],\n        script: ['execution', 'script', 'event', 'item']\n    },\n\n    /**\n     * load all the default reporters here. if you have new reporter, add it to this list\n     * we know someone, who does not like dynamic requires\n     *\n     * @type {Object}\n     */\n    defaultReporters = {\n        cli: require('../reporters/cli'),\n        json: require('../reporters/json'),\n        junit: require('../reporters/junit'),\n        progress: require('../reporters/progress'),\n        emojitrain: require('../reporters/emojitrain')\n    },\n\n    /**\n     * The object of known reporters and their install instruction in case the reporter is not loaded.\n     * Pad message with two spaces since its a follow-up message for reporter warning.\n     *\n     * @private\n     * @type {Object}\n     */\n    knownReporterErrorMessages = {\n        html: '  run `npm install newman-reporter-html`\\n',\n        teamcity: '  run `npm install newman-reporter-teamcity`\\n'\n    },\n\n    /**\n     * Multiple ids or names entrypoint lookup strategy.\n     *\n     * @private\n     * @type {String}\n     */\n    MULTIENTRY_LOOKUP_STRATEGY = 'multipleIdOrName';\n\n/**\n * Runs the collection, with all the provided options, returning an EventEmitter.\n *\n * @param {Object} options - The set of wrapped options, passed by the CLI parser.\n * @param {Collection|Object|String} options.collection - A JSON / Collection / String representing the collection.\n * @param {Object|String} options.environment - An environment JSON / file path for the current collection run.\n * @param {Object|String} options.globals - A globals JSON / file path for the current collection run.\n * @param {String} options.workingDir - Path of working directory that contains files needed for the collection run.\n * @param {String} options.insecureFileRead - If true, allow reading files outside of working directory.\n * @param {Object|String} options.iterationData - An iterationData JSON / file path for the current collection run.\n * @param {Object|String} options.reporters - A set of reporter names and their associated options for the current run.\n * @param {Object|String} options.cookieJar - A tough-cookie cookieJar / file path for the current collection run.\n * @param {String} options.exportGlobals - The relative path to export the globals file from the current run to.\n * @param {String} options.exportEnvironment - The relative path to export the environment file from the current run to.\n * @param {String} options.exportCollection - The relative path to export the collection from the current run to.\n * @param {String} options.exportCookieJar - The relative path to export the cookie jar from the current run to.\n * @param {Function} callback - The callback function invoked to mark the end of the collection run.\n * @returns {EventEmitter} - An EventEmitter instance with done and error event attachments.\n */\nmodule.exports = function (options, callback) {\n    // validate all options. it is to be noted that `options` parameter is option and is polymorphic\n    (!callback && _.isFunction(options)) && (\n        (callback = options),\n        (options = {})\n    );\n    !_.isFunction(callback) && (callback = _.noop);\n\n    var emitter = new EventEmitter(), // @todo: create a new inherited constructor\n        runner = new runtime.Runner(),\n        stopOnFailure,\n        entrypoint;\n\n    // get the configuration from various sources\n    getOptions(options, function (err, options) {\n        if (err) {\n            return callback(err);\n        }\n\n        // ensure that the collection option is present before starting a run\n        if (!_.isObject(options.collection)) {\n            return callback(new Error('expecting a collection to run'));\n        }\n\n        // use client certificate list to allow different ssl certificates for\n        // different URLs\n        var sslClientCertList = options.sslClientCertList || [],\n            // allow providing custom cookieJar\n            cookieJar = options.cookieJar || request.jar();\n\n        // if sslClientCert option is set, put it at the end of the list to\n        // match all URLs that didn't match in the list\n        if (options.sslClientCert) {\n            sslClientCertList.push({\n                name: 'client-cert',\n                matches: [sdk.UrlMatchPattern.MATCH_ALL_URLS],\n                key: { src: options.sslClientKey },\n                cert: { src: options.sslClientCert },\n                passphrase: options.sslClientPassphrase\n            });\n        }\n\n        // iterates over the bail array and sets each item as an obj key with a value of boolean true\n        // [item1, item2] => {item1: true, item2: true}\n        if (_.isArray(options.bail)) {\n            options.bail = _.transform(options.bail, function (result, value) {\n                result[value] = true;\n            }, {});\n        }\n\n        // sets entrypoint to execute if options.folder is specified.\n        if (options.folder) {\n            entrypoint = { execute: options.folder };\n\n            // uses `multipleIdOrName` lookupStrategy in case of multiple folders.\n            _.isArray(entrypoint.execute) && (entrypoint.lookupStrategy = MULTIENTRY_LOOKUP_STRATEGY);\n        }\n\n        // sets stopOnFailure to true in case bail is used without any modifiers or with failure\n        // --bail => stopOnFailure = true\n        // --bail failure => stopOnFailure = true\n        (typeof options.bail !== 'undefined' &&\n            (options.bail === true || (_.isObject(options.bail) && options.bail.failure))) ?\n            stopOnFailure = true : stopOnFailure = false;\n\n        // store summary object and other relevant information inside the emitter\n        emitter.summary = new RunSummary(emitter, options);\n\n        // to store the exported content from reporters\n        emitter.exports = [];\n\n        // expose the runner object for reporter and programmatic use\n        emitter.runner = runner;\n\n        // now start the run!\n        runner.run(options.collection, {\n            stopOnFailure: stopOnFailure, // LOL, you just got trolled ¯\\_(ツ)_/¯\n            abortOnFailure: options.abortOnFailure, // used in integration tests, to be considered for a future release\n            abortOnError: _.get(options, 'bail.folder'),\n            iterationCount: options.iterationCount,\n            environment: options.environment,\n            globals: options.globals,\n            entrypoint: entrypoint,\n            data: options.iterationData,\n            delay: {\n                item: options.delayRequest\n            },\n            timeout: {\n                global: options.timeout || 0,\n                request: options.timeoutRequest || 0,\n                script: options.timeoutScript || 0\n            },\n            fileResolver: new SecureFS(options.workingDir, options.insecureFileRead),\n            requester: {\n                useWhatWGUrlParser: true,\n                cookieJar: cookieJar,\n                followRedirects: _.has(options, 'ignoreRedirects') ? !options.ignoreRedirects : undefined,\n                strictSSL: _.has(options, 'insecure') ? !options.insecure : undefined,\n                timings: Boolean(options.verbose),\n                extendedRootCA: options.sslExtraCaCerts,\n                agents: _.isObject(options.requestAgents) ? options.requestAgents : undefined\n            },\n            certificates: sslClientCertList.length && new sdk.CertificateList({}, sslClientCertList)\n        }, function (err, run) {\n            if (err) { return callback(err); }\n\n            var callbacks = {},\n                // ensure that the reporter option type polymorphism is handled\n                reporters = _.isString(options.reporters) ? [options.reporters] : options.reporters,\n                // keep a track of start assertion indices of legacy assertions\n                legacyAssertionIndices = {};\n\n            // emit events for all the callbacks triggered by the runtime\n            _.forEach(runtimeEvents, function (definition, eventName) {\n                // intercept each runtime.* callback and expose a global object based event\n                callbacks[eventName] = function (err, cursor) {\n                    var args = arguments,\n                        obj = { cursor };\n\n                    // convert the arguments into an object by taking the key name reference from the definition\n                    // object\n                    _.forEach(definition, function (key, index) {\n                        obj[key] = args[index + 2]; // first two are err, cursor\n                    });\n\n                    args = [eventName, err, obj];\n                    emitter.emit.apply(emitter, args); // eslint-disable-line prefer-spread\n                };\n            });\n\n            // add non generic callback handling\n            _.assignIn(callbacks, {\n\n                /**\n                 * Emits event for start of the run. It injects/exposes additional objects useful for\n                 * programmatic usage and reporters\n                 *\n                 * @param {?Error} err - An Error instance / null object.\n                 * @param {Object} cursor - The run cursor instance.\n                 * @returns {*}\n                 */\n                start (err, cursor) {\n                    emitter.emit('start', err, {\n                        cursor,\n                        run\n                    });\n                },\n\n                /**\n                 * Bubbles up console messages.\n                 *\n                 * @param {Object} cursor - The run cursor instance.\n                 * @param {String} level - The level of console logging [error, silent, etc].\n                 * @returns {*}\n                 */\n                console (cursor, level) {\n                    emitter.emit('console', null, {\n                        cursor: cursor,\n                        level: level,\n                        messages: _.slice(arguments, 2)\n                    });\n                },\n\n                /**\n                 * The exception handler for the current run instance.\n                 *\n                 * @todo Fix bug of arg order in runtime.\n                 * @param {Object} cursor - The run cursor.\n                 * @param {?Error} err - An Error instance / null object.\n                 * @returns {*}\n                 */\n                exception (cursor, err) {\n                    emitter.emit('exception', null, {\n                        cursor: cursor,\n                        error: err\n                    });\n                },\n\n                assertion (cursor, assertions) {\n                    _.forEach(assertions, function (assertion) {\n                        var errorName = _.get(assertion, 'error.name', 'AssertionError');\n\n                        !assertion && (assertion = {});\n\n                        // store the legacy assertion index\n                        assertion.index && (legacyAssertionIndices[cursor.ref] = assertion.index);\n\n                        emitter.emit('assertion', (assertion.passed ? null : {\n                            name: errorName,\n                            index: assertion.index,\n                            test: assertion.name,\n                            message: _.get(assertion, 'error.message', assertion.name || ''),\n\n                            stack: errorName + ': ' + _.get(assertion, 'error.message', '') + '\\n' +\n                                '   at Object.eval sandbox-script.js:' + (assertion.index + 1) + ':' +\n                                ((cursor && cursor.position || 0) + 1) + ')'\n                        }), {\n                            cursor: cursor,\n                            assertion: assertion.name,\n                            skipped: assertion.skipped,\n                            error: assertion.error,\n                            item: run.resolveCursor(cursor)\n                        });\n                    });\n                },\n\n                /**\n                 * Custom callback to override the `done` event to fire the end callback.\n                 *\n                 * @todo Do some memory cleanup here?\n                 * @param {?Error} err - An error instance / null passed from the done event handler.\n                 * @param {Object} cursor - The run instance cursor.\n                 * @returns {*}\n                 */\n                done (err, cursor) {\n                    // in case runtime faced an error during run, we do not process any other event and emit `done`.\n                    // we do it this way since, an error in `done` callback would have anyway skipped any intermediate\n                    // events or callbacks\n                    if (err) {\n                        emitter.emit('done', err, emitter.summary);\n                        callback(err, emitter.summary);\n\n                        return;\n                    }\n\n                    // we emit a `beforeDone` event so that reporters and other such addons can do computation before\n                    // the run is marked as done\n                    emitter.emit('beforeDone', null, {\n                        cursor: cursor,\n                        summary: emitter.summary\n                    });\n\n                    _.forEach(['environment', 'globals', 'collection', 'cookie-jar'], function (item) {\n                        // fetch the path name from options if one is provided\n                        var path = _.get(options, _.camelCase(`export-${item}`));\n\n                        // if the options have an export path, then add the item to export queue\n                        path && emitter.exports.push({\n                            name: item,\n                            default: `newman-${item}.json`,\n                            path: path,\n                            content: item === 'cookie-jar' ?\n                                cookieJar.toJSON() :\n                                _(emitter.summary[item].toJSON())\n                                    .defaults({\n                                        name: item\n                                    })\n                                    .merge({\n                                        _postman_variable_scope: item,\n                                        _postman_exported_at: (new Date()).toISOString(),\n                                        _postman_exported_using: util.userAgent\n                                    })\n                                    .value()\n                        });\n                    });\n\n                    asyncEach(emitter.exports, exportFile, function (err) {\n                        // we now trigger actual done event which we had overridden\n                        emitter.emit('done', err, emitter.summary);\n                        callback(err, emitter.summary);\n                    });\n                }\n            });\n\n            emitter.on('script', function (err, o) {\n                // bubble special script name based events\n                o && o.event && emitter.emit(o.event.listen + 'Script', err, o);\n            });\n\n            emitter.on('beforeScript', function (err, o) {\n                // bubble special script name based events\n                o && o.event && emitter.emit(_.camelCase('before-' + o.event.listen + 'Script'), err, o);\n            });\n\n            // initialise all the reporters\n            !emitter.reporters && (emitter.reporters = {});\n            _.isArray(reporters) && _.forEach(reporters, function (reporterName) {\n                // disallow duplicate reporter initialisation\n                if (_.has(emitter.reporters, reporterName)) { return; }\n\n                var Reporter;\n\n                try {\n                    // check if the reporter is an external reporter\n                    Reporter = require((function (name) { // ensure scoped packages are loaded\n                        var prefix = '',\n                            scope = (name.charAt(0) === '@') && name.substr(0, name.indexOf('/') + 1);\n\n                        if (scope) {\n                            prefix = scope;\n                            name = name.substr(scope.length);\n                        }\n\n                        return prefix + 'newman-reporter-' + name;\n                    }(reporterName)));\n                }\n                // @todo - maybe have a debug mode and log error there\n                catch (error) {\n                    if (!defaultReporters[reporterName]) {\n                        // @todo: route this via print module to respect silent flags\n                        console.warn(`newman: could not find \"${reporterName}\" reporter`);\n                        console.warn('  ensure that the reporter is installed in the same directory as newman');\n\n                        // print install instruction in case a known reporter is missing\n                        if (knownReporterErrorMessages[reporterName]) {\n                            console.warn(knownReporterErrorMessages[reporterName]);\n                        }\n                        else {\n                            console.warn('  please install reporter using npm\\n');\n                        }\n                    }\n                }\n\n                // load local reporter if its not an external reporter\n                !Reporter && (Reporter = defaultReporters[reporterName]);\n\n                try {\n                    // we could have checked _.isFunction(Reporter), here, but we do not do that so that the nature of\n                    // reporter error can be bubbled up\n                    Reporter && (emitter.reporters[reporterName] = new Reporter(emitter,\n                        _.get(options, ['reporter', reporterName], {}), options));\n                }\n                catch (error) {\n                    // if the reporter errored out during initialisation, we should not stop the run simply log\n                    // the error stack trace for debugging\n                    console.warn(`newman: could not load \"${reporterName}\" reporter`);\n\n                    if (!defaultReporters[reporterName]) {\n                        // @todo: route this via print module to respect silent flags\n                        console.warn(`  this seems to be a problem in the \"${reporterName}\" reporter.\\n`);\n                    }\n                    console.warn(error);\n                }\n            });\n\n            // raise warning when more than one dominant reporters are used\n            (function (reporters) {\n                // find all reporters whose `dominant` key is set to true\n                var conflicts = _.keys(_.transform(reporters, function (conflicts, reporter, name) {\n                    reporter.dominant && (conflicts[name] = true);\n                }));\n\n                (conflicts.length > 1) && // if more than one dominant, raise a warning\n                    console.warn(`newman: ${conflicts.join(', ')} reporters might not work well together.`);\n            }(emitter.reporters));\n\n            // we ensure that everything is async to comply with event paradigm and start the run\n            setImmediate(function () {\n                run.start(callbacks);\n            });\n        });\n    });\n\n    return emitter;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}