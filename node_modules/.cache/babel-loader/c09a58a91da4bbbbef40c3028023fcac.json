{"ast":null,"code":"const EventEmitter = require('events'),\n  bridge = require('./bridge'),\n  {\n    isFunction,\n    isObject\n  } = require('./utils'),\n  /**\n   * The time to wait for UVM boot to finish. In milliseconds.\n   *\n   * @private\n   * @type {Number}\n   */\n  DEFAULT_BOOT_TIMEOUT = 30 * 1000,\n  /**\n   * The time to wait for UVM dispatch process to finish. In milliseconds.\n   *\n   * @private\n   * @type {Number}\n   */\n  DEFAULT_DISPATCH_TIMEOUT = 30 * 1000,\n  E = '',\n  ERROR_EVENT = 'error',\n  DISPATCH_QUEUE_EVENT = 'dispatchQueued';\n\n/**\n * Configuration options for  UniversalVM connection.\n *\n * @typedef UniversalVM.connectOptions\n *\n * @property {Boolean} [bootCode] Code to be executed inside a VM on boot\n * @property {Boolean} [_sandbox] Custom sandbox instance\n * @property {Boolean} [debug] Inject global console object in Node.js VM\n * @property {Boolean} [bootTimeout=30 * 1000] The time (in milliseconds) to wait for UVM boot to finish\n * @property {Boolean} [dispatchTimeout=30 * 1000] The time (in milliseconds) to wait for UVM dispatch process to finish\n */\n\n/**\n * Universal Virtual Machine for Node and Browser.\n */\nclass UniversalVM extends EventEmitter {\n  constructor() {\n    super();\n\n    /**\n     * Boolean representing the bridge connectivity state.\n     *\n     * @private\n     * @type {Boolean}\n     */\n    this._bridgeConnected = false;\n\n    /**\n     * Stores the pending dispatch events until the context is ready for use.\n     * Useful when not using the asynchronous construction.\n     *\n     * @private\n     * @type {Array}\n     */\n    this._dispatchQueue = [];\n  }\n\n  /**\n   * Creates a new instance of UniversalVM.\n   * This is merely an alias of the construction creation without needing to\n   * write the `new` keyword and creating explicit connection.\n   *\n   * @param {UniversalVM.connectOptions} [options] Options to configure the UVM\n   * @param {Function(error, context)} callback Callback function\n   * @returns {Object} UVM event emitter instance\n   *\n   * @example\n   * const uvm = require('uvm');\n   *\n   * uvm.spawn({\n   *     bootCode: `\n   *         bridge.on('loopback', function (data) {\n   *             bridge.dispatch('loopback', 'pong');\n   *         });\n   *     `\n   * }, (err, context) => {\n   *     context.on('loopback', function (data) {\n   *         console.log(data); // pong\n   *     });\n   *\n   *     context.dispatch('loopback', 'ping');\n   * });\n   */\n  static spawn(options, callback) {\n    const uvm = new UniversalVM(options, callback);\n\n    // connect with the bridge\n    uvm.connect(options, callback);\n\n    // return event emitter for chaining\n    return uvm;\n  }\n\n  /**\n   * Establish connection with the communication bridge.\n   *\n   * @param {UniversalVM.connectOptions} [options] Options to configure the UVM\n   * @param {Function(error, context)} callback Callback function\n   */\n  connect(options, callback) {\n    // set defaults for parameters\n    !isObject(options) && (options = {});\n\n    /**\n     * Wrap the callback for unified result and reduce chance of bug.\n     * We also abandon all dispatch replay.\n     *\n     * @private\n     * @param  {Error=} [err] -\n     */\n    const done = err => {\n      if (err) {\n        // on error during bridging, we simply abandon all dispatch replay\n        this._dispatchQueue.length = 0;\n        try {\n          this.emit(ERROR_EVENT, err);\n        }\n        // nothing to do if listeners fail, we need to move on and execute callback!\n        catch (e) {} // eslint-disable-line no-empty\n      }\n\n      isFunction(callback) && callback.call(this, err, this);\n    };\n\n    // bail out if bridge is connected\n    if (this._bridgeConnected) {\n      return done();\n    }\n\n    // start connection with the communication bridge\n    this._bridgeConnected = true;\n\n    // we bridge this event emitter with the context (bridge usually creates the context as well)\n    bridge(this, Object.assign({\n      // eslint-disable-line prefer-object-spread\n      bootCode: E,\n      bootTimeout: DEFAULT_BOOT_TIMEOUT,\n      dispatchTimeout: DEFAULT_DISPATCH_TIMEOUT\n    }, options), err => {\n      if (err) {\n        return done(err);\n      }\n      let args;\n      try {\n        // we dispatch all pending messages provided nothing had errors\n        while (args = this._dispatchQueue.shift()) {\n          this.dispatch(...args);\n        }\n      }\n      // since there us no further work after dispatching events, we re-use the err parameter.\n      // at this point err variable is falsy since truthy case is already handled before\n      catch (e) {\n        /* istanbul ignore next */err = e;\n      }\n      done(err);\n    });\n  }\n\n  /**\n   * Emit an event on the other end of bridge.\n   * The parameters are same as `emit` function of the event emitter.\n   */\n  dispatch() {\n    try {\n      this._dispatch(...arguments);\n    } catch (e) {\n      /* istanbul ignore next */this.emit(ERROR_EVENT, e);\n    }\n  }\n\n  /**\n   * Disconnect the bridge and release memory.\n   */\n  disconnect() {\n    // reset the bridge connection state\n    this._bridgeConnected = false;\n    try {\n      this._disconnect(...arguments);\n    } catch (e) {\n      this.emit(ERROR_EVENT, e);\n    }\n  }\n\n  /**\n   * Stub dispatch handler to queue dispatched messages until bridge is ready.\n   *\n   * @private\n   * @param {String} name -\n   */\n  _dispatch(name) {\n    this._dispatchQueue.push(arguments);\n    this.emit(DISPATCH_QUEUE_EVENT, name);\n  }\n\n  /**\n   * The bridge should be ready to disconnect when this is called. If not,\n   * then this prototype stub would throw an error\n   *\n   * @private\n   * @throws {Error} If bridge is not ready and this function is called\n   */\n  _disconnect() {\n    // eslint-disable-line class-methods-use-this\n    throw new Error('uvm: cannot disconnect, communication bridge is broken');\n  }\n}\nmodule.exports = UniversalVM;","map":{"version":3,"names":["EventEmitter","require","bridge","isFunction","isObject","DEFAULT_BOOT_TIMEOUT","DEFAULT_DISPATCH_TIMEOUT","E","ERROR_EVENT","DISPATCH_QUEUE_EVENT","UniversalVM","constructor","_bridgeConnected","_dispatchQueue","spawn","options","callback","uvm","connect","done","err","length","emit","e","call","Object","assign","bootCode","bootTimeout","dispatchTimeout","args","shift","dispatch","_dispatch","arguments","disconnect","_disconnect","name","push","Error","module","exports"],"sources":["/Users/Qusai.Qishta/node_modules/uvm/lib/index.js"],"sourcesContent":["const EventEmitter = require('events'),\n\n    bridge = require('./bridge'),\n    { isFunction, isObject } = require('./utils'),\n\n    /**\n     * The time to wait for UVM boot to finish. In milliseconds.\n     *\n     * @private\n     * @type {Number}\n     */\n    DEFAULT_BOOT_TIMEOUT = 30 * 1000,\n\n    /**\n     * The time to wait for UVM dispatch process to finish. In milliseconds.\n     *\n     * @private\n     * @type {Number}\n     */\n    DEFAULT_DISPATCH_TIMEOUT = 30 * 1000,\n\n    E = '',\n    ERROR_EVENT = 'error',\n    DISPATCH_QUEUE_EVENT = 'dispatchQueued';\n\n/**\n * Configuration options for  UniversalVM connection.\n *\n * @typedef UniversalVM.connectOptions\n *\n * @property {Boolean} [bootCode] Code to be executed inside a VM on boot\n * @property {Boolean} [_sandbox] Custom sandbox instance\n * @property {Boolean} [debug] Inject global console object in Node.js VM\n * @property {Boolean} [bootTimeout=30 * 1000] The time (in milliseconds) to wait for UVM boot to finish\n * @property {Boolean} [dispatchTimeout=30 * 1000] The time (in milliseconds) to wait for UVM dispatch process to finish\n */\n\n/**\n * Universal Virtual Machine for Node and Browser.\n */\nclass UniversalVM extends EventEmitter {\n    constructor () {\n        super();\n\n        /**\n         * Boolean representing the bridge connectivity state.\n         *\n         * @private\n         * @type {Boolean}\n         */\n        this._bridgeConnected = false;\n\n        /**\n         * Stores the pending dispatch events until the context is ready for use.\n         * Useful when not using the asynchronous construction.\n         *\n         * @private\n         * @type {Array}\n         */\n        this._dispatchQueue = [];\n    }\n\n    /**\n     * Creates a new instance of UniversalVM.\n     * This is merely an alias of the construction creation without needing to\n     * write the `new` keyword and creating explicit connection.\n     *\n     * @param {UniversalVM.connectOptions} [options] Options to configure the UVM\n     * @param {Function(error, context)} callback Callback function\n     * @returns {Object} UVM event emitter instance\n     *\n     * @example\n     * const uvm = require('uvm');\n     *\n     * uvm.spawn({\n     *     bootCode: `\n     *         bridge.on('loopback', function (data) {\n     *             bridge.dispatch('loopback', 'pong');\n     *         });\n     *     `\n     * }, (err, context) => {\n     *     context.on('loopback', function (data) {\n     *         console.log(data); // pong\n     *     });\n     *\n     *     context.dispatch('loopback', 'ping');\n     * });\n     */\n    static spawn (options, callback) {\n        const uvm = new UniversalVM(options, callback);\n\n        // connect with the bridge\n        uvm.connect(options, callback);\n\n        // return event emitter for chaining\n        return uvm;\n    }\n\n    /**\n     * Establish connection with the communication bridge.\n     *\n     * @param {UniversalVM.connectOptions} [options] Options to configure the UVM\n     * @param {Function(error, context)} callback Callback function\n     */\n    connect (options, callback) {\n        // set defaults for parameters\n        !isObject(options) && (options = {});\n\n        /**\n         * Wrap the callback for unified result and reduce chance of bug.\n         * We also abandon all dispatch replay.\n         *\n         * @private\n         * @param  {Error=} [err] -\n         */\n        const done = (err) => {\n            if (err) {\n                // on error during bridging, we simply abandon all dispatch replay\n                this._dispatchQueue.length = 0;\n\n                try { this.emit(ERROR_EVENT, err); }\n                // nothing to do if listeners fail, we need to move on and execute callback!\n                catch (e) { } // eslint-disable-line no-empty\n            }\n\n            isFunction(callback) && callback.call(this, err, this);\n        };\n\n        // bail out if bridge is connected\n        if (this._bridgeConnected) {\n            return done();\n        }\n\n        // start connection with the communication bridge\n        this._bridgeConnected = true;\n\n        // we bridge this event emitter with the context (bridge usually creates the context as well)\n        bridge(this, Object.assign({ // eslint-disable-line prefer-object-spread\n            bootCode: E,\n            bootTimeout: DEFAULT_BOOT_TIMEOUT,\n            dispatchTimeout: DEFAULT_DISPATCH_TIMEOUT\n        }, options), (err) => {\n            if (err) {\n                return done(err);\n            }\n\n            let args;\n\n            try {\n                // we dispatch all pending messages provided nothing had errors\n                while ((args = this._dispatchQueue.shift())) {\n                    this.dispatch(...args);\n                }\n            }\n            // since there us no further work after dispatching events, we re-use the err parameter.\n            // at this point err variable is falsy since truthy case is already handled before\n            catch (e) { /* istanbul ignore next */ err = e; }\n\n            done(err);\n        });\n    }\n\n    /**\n     * Emit an event on the other end of bridge.\n     * The parameters are same as `emit` function of the event emitter.\n     */\n    dispatch () {\n        try { this._dispatch(...arguments); }\n        catch (e) { /* istanbul ignore next */ this.emit(ERROR_EVENT, e); }\n    }\n\n    /**\n     * Disconnect the bridge and release memory.\n     */\n    disconnect () {\n        // reset the bridge connection state\n        this._bridgeConnected = false;\n\n        try { this._disconnect(...arguments); }\n        catch (e) { this.emit(ERROR_EVENT, e); }\n    }\n\n    /**\n     * Stub dispatch handler to queue dispatched messages until bridge is ready.\n     *\n     * @private\n     * @param {String} name -\n     */\n    _dispatch (name) {\n        this._dispatchQueue.push(arguments);\n        this.emit(DISPATCH_QUEUE_EVENT, name);\n    }\n\n    /**\n     * The bridge should be ready to disconnect when this is called. If not,\n     * then this prototype stub would throw an error\n     *\n     * @private\n     * @throws {Error} If bridge is not ready and this function is called\n     */\n    _disconnect () { // eslint-disable-line class-methods-use-this\n        throw new Error('uvm: cannot disconnect, communication bridge is broken');\n    }\n}\n\nmodule.exports = UniversalVM;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}