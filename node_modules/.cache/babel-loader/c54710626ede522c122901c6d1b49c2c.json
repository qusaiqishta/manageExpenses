{"ast":null,"code":"var _ = require('../util').lodash,\n  Property = require('./property').Property,\n  PropertyBase = require('./property-base').PropertyBase,\n  Url = require('./url').Url,\n  UrlMatchPatternList = require('../url-pattern/url-match-pattern-list').UrlMatchPatternList,\n  STRING = 'string',\n  HTTPS = 'https',\n  Certificate;\n\n/**\n * The following is the object representation accepted as param for the Certificate constructor.\n * Also the type of the object returned when {@link Property#toJSON} or {@link Property#toObjectResolved} is called on a\n * Certificate instance.\n *\n * @typedef Certificate.definition\n * @property {String} [name] A name for the certificate\n * @property {Array} [matches] A list of match patterns\n * @property {{ src: (String) }} [key] Object with path on the file system for private key file, as src\n * @property {{ src: (String) }} [cert] Object with path on the file system for certificate file, as src\n * @property {String} [passphrase] The passphrase for the certificate key\n *\n * @example <caption>JSON definition of an example certificate object</caption>\n * {\n *     \"name\": \"My certificate for example.com\",\n *     \"matches\": [\"https://example.com/*\"],\n *     \"key\": { \"src\": \"/path/to/key\" },\n *     \"cert\": { \"src\": \"/User/path/to/certificate\" },\n *     \"passphrase\": \"iampassphrase\"\n * }\n */\n_.inherit(\n/**\n * A Certificate definition that represents the ssl certificate\n * to be used for an url.\n * Properties can then use the `.toObjectResolved` function to procure an object representation of the property with\n * all the variable references replaced by corresponding values.\n *\n * @constructor\n * @extends {Property}\n *\n * @param {Certificate.definition=} [options] Object with matches, key, cert and passphrase\n *\n * @example <caption> Create a new Certificate</caption>\n *\n * var Certificate = require('postman-collection').Certificate,\n *    certificate = new Certificate({\n *     name: 'Certificate for example.com',\n *     matches: ['example.com'],\n *     key: { src: '/User/path/to/certificate/key' },\n *     cert: { src: '/User/path/to/certificate' },\n *     passphrase: 'iampassphrase'\n * });\n */\nCertificate = function Certificate(options) {\n  // this constructor is intended to inherit and as such the super constructor is required to be executed\n  Certificate.super_.apply(this, arguments);\n  this.update(options);\n}, Property);\n_.assign(Certificate.prototype, /** @lends Certificate.prototype */{\n  /**\n   * Ensure all object have id\n   *\n   * @private\n   */\n  _postman_propertyRequiresId: true,\n  /**\n   * Updates the certificate with the given properties.\n   *\n   * @param {Certificate.definition=} [options] Object with matches, key, cert and passphrase\n   */\n  update: function (options) {\n    // return early if options is empty or invalid\n    if (!_.isObject(options)) {\n      return;\n    }\n    _.mergeDefined(this, /** @lends Certificate.prototype */{\n      /**\n       * Unique identifier\n       *\n       * @type {String}\n       */\n      id: options.id,\n      /**\n       * Name for user reference\n       *\n       * @type {String}\n       */\n      name: options.name,\n      /**\n       * List of match pattern\n       *\n       * @type {UrlMatchPatternList}\n       */\n      matches: options.matches && new UrlMatchPatternList({}, options.matches),\n      /**\n       * Private Key\n       *\n       * @type {{ src: (string) }}\n       */\n      key: _.isObject(options.key) ? options.key : {\n        src: options.key\n      },\n      /**\n       * Certificate\n       *\n       * @type {{ src: (string) }}\n       */\n      cert: _.isObject(options.cert) ? options.cert : {\n        src: options.cert\n      },\n      /**\n       * PFX or PKCS12 Certificate\n       *\n       * @type {{ src: (string) }}\n       */\n      pfx: _.isObject(options.pfx) ? options.pfx : {\n        src: options.pfx\n      },\n      /**\n       * passphrase\n       *\n       * @type {Object}\n       */\n      passphrase: options.passphrase\n    });\n  },\n  /**\n   * Checks if the certificate can be applied to a given url\n   *\n   * @param {String|Url} url The url string for which the certificate is checked for match.\n   */\n  canApplyTo: function (url) {\n    if (_.isEmpty(url)) {\n      return false;\n    }\n\n    // convert url strings to Url\n    typeof url === STRING && (url = new Url(url));\n\n    // this ensures we don't proceed any further for any protocol\n    // that is not https\n    if (url.protocol !== HTTPS) {\n      return false;\n    }\n\n    // test the input url against allowed matches\n    return this.matches.test(url);\n  },\n  /**\n   * Allows the serialization of a {@link Certificate}\n   *\n   * This is overridden, in order to ensure that certificate contents are not accidentally serialized,\n   * which can be a security risk.\n   */\n  toJSON: function () {\n    var obj = PropertyBase.toJSON(this);\n    _.unset(obj, 'key.value');\n    _.unset(obj, 'cert.value');\n    _.unset(obj, 'pfx.value');\n    return obj;\n  }\n});\n_.assign(Certificate, /** @lends Certificate */{\n  /**\n   * Defines the name of this property for internal use\n   *\n   * @private\n   * @readOnly\n   * @type {String}\n   */\n  _postman_propertyName: 'Certificate',\n  /**\n   * Specify the key to be used while indexing this object\n   *\n   * @private\n   * @readOnly\n   * @type {String}\n   */\n  _postman_propertyIndexKey: 'id',\n  /**\n   * Checks if the given object is a Certificate\n   *\n   * @param {*} obj -\n   * @returns {Boolean}\n   */\n  isCertificate: function (obj) {\n    return Boolean(obj) && (obj instanceof Certificate || _.inSuperChain(obj.constructor, '_postman_propertyName', Certificate._postman_propertyName));\n  }\n});\nmodule.exports = {\n  Certificate\n};","map":{"version":3,"names":["_","require","lodash","Property","PropertyBase","Url","UrlMatchPatternList","STRING","HTTPS","Certificate","inherit","options","super_","apply","arguments","update","assign","prototype","_postman_propertyRequiresId","isObject","mergeDefined","id","name","matches","key","src","cert","pfx","passphrase","canApplyTo","url","isEmpty","protocol","test","toJSON","obj","unset","_postman_propertyName","_postman_propertyIndexKey","isCertificate","Boolean","inSuperChain","constructor","module","exports"],"sources":["/Users/Qusai.Qishta/node_modules/postman-collection/lib/collection/certificate.js"],"sourcesContent":["var _ = require('../util').lodash,\n    Property = require('./property').Property,\n    PropertyBase = require('./property-base').PropertyBase,\n    Url = require('./url').Url,\n    UrlMatchPatternList = require('../url-pattern/url-match-pattern-list').UrlMatchPatternList,\n\n    STRING = 'string',\n    HTTPS = 'https',\n\n    Certificate;\n\n/**\n * The following is the object representation accepted as param for the Certificate constructor.\n * Also the type of the object returned when {@link Property#toJSON} or {@link Property#toObjectResolved} is called on a\n * Certificate instance.\n *\n * @typedef Certificate.definition\n * @property {String} [name] A name for the certificate\n * @property {Array} [matches] A list of match patterns\n * @property {{ src: (String) }} [key] Object with path on the file system for private key file, as src\n * @property {{ src: (String) }} [cert] Object with path on the file system for certificate file, as src\n * @property {String} [passphrase] The passphrase for the certificate key\n *\n * @example <caption>JSON definition of an example certificate object</caption>\n * {\n *     \"name\": \"My certificate for example.com\",\n *     \"matches\": [\"https://example.com/*\"],\n *     \"key\": { \"src\": \"/path/to/key\" },\n *     \"cert\": { \"src\": \"/User/path/to/certificate\" },\n *     \"passphrase\": \"iampassphrase\"\n * }\n */\n_.inherit((\n\n    /**\n     * A Certificate definition that represents the ssl certificate\n     * to be used for an url.\n     * Properties can then use the `.toObjectResolved` function to procure an object representation of the property with\n     * all the variable references replaced by corresponding values.\n     *\n     * @constructor\n     * @extends {Property}\n     *\n     * @param {Certificate.definition=} [options] Object with matches, key, cert and passphrase\n     *\n     * @example <caption> Create a new Certificate</caption>\n     *\n     * var Certificate = require('postman-collection').Certificate,\n     *    certificate = new Certificate({\n     *     name: 'Certificate for example.com',\n     *     matches: ['example.com'],\n     *     key: { src: '/User/path/to/certificate/key' },\n     *     cert: { src: '/User/path/to/certificate' },\n     *     passphrase: 'iampassphrase'\n     * });\n     */\n    Certificate = function Certificate (options) {\n        // this constructor is intended to inherit and as such the super constructor is required to be executed\n        Certificate.super_.apply(this, arguments);\n\n        this.update(options);\n    }), Property);\n\n_.assign(Certificate.prototype, /** @lends Certificate.prototype */ {\n    /**\n     * Ensure all object have id\n     *\n     * @private\n     */\n    _postman_propertyRequiresId: true,\n\n    /**\n     * Updates the certificate with the given properties.\n     *\n     * @param {Certificate.definition=} [options] Object with matches, key, cert and passphrase\n     */\n    update: function (options) {\n        // return early if options is empty or invalid\n        if (!_.isObject(options)) {\n            return;\n        }\n\n        _.mergeDefined(this, /** @lends Certificate.prototype */ {\n            /**\n             * Unique identifier\n             *\n             * @type {String}\n             */\n            id: options.id,\n\n            /**\n             * Name for user reference\n             *\n             * @type {String}\n             */\n            name: options.name,\n\n            /**\n             * List of match pattern\n             *\n             * @type {UrlMatchPatternList}\n             */\n            matches: options.matches && new UrlMatchPatternList({}, options.matches),\n\n            /**\n             * Private Key\n             *\n             * @type {{ src: (string) }}\n             */\n            key: _.isObject(options.key) ? options.key : { src: options.key },\n\n            /**\n             * Certificate\n             *\n             * @type {{ src: (string) }}\n             */\n            cert: _.isObject(options.cert) ? options.cert : { src: options.cert },\n\n            /**\n             * PFX or PKCS12 Certificate\n             *\n             * @type {{ src: (string) }}\n             */\n            pfx: _.isObject(options.pfx) ? options.pfx : { src: options.pfx },\n\n            /**\n             * passphrase\n             *\n             * @type {Object}\n             */\n            passphrase: options.passphrase\n        });\n    },\n\n    /**\n     * Checks if the certificate can be applied to a given url\n     *\n     * @param {String|Url} url The url string for which the certificate is checked for match.\n     */\n    canApplyTo: function (url) {\n        if (_.isEmpty(url)) {\n            return false;\n        }\n\n        // convert url strings to Url\n        (typeof url === STRING) && (url = new Url(url));\n\n        // this ensures we don't proceed any further for any protocol\n        // that is not https\n        if (url.protocol !== HTTPS) {\n            return false;\n        }\n\n        // test the input url against allowed matches\n        return this.matches.test(url);\n    },\n\n    /**\n     * Allows the serialization of a {@link Certificate}\n     *\n     * This is overridden, in order to ensure that certificate contents are not accidentally serialized,\n     * which can be a security risk.\n     */\n    toJSON: function () {\n        var obj = PropertyBase.toJSON(this);\n\n        _.unset(obj, 'key.value');\n        _.unset(obj, 'cert.value');\n        _.unset(obj, 'pfx.value');\n\n        return obj;\n    }\n});\n\n_.assign(Certificate, /** @lends Certificate */ {\n    /**\n     * Defines the name of this property for internal use\n     *\n     * @private\n     * @readOnly\n     * @type {String}\n     */\n    _postman_propertyName: 'Certificate',\n\n    /**\n     * Specify the key to be used while indexing this object\n     *\n     * @private\n     * @readOnly\n     * @type {String}\n     */\n    _postman_propertyIndexKey: 'id',\n\n    /**\n     * Checks if the given object is a Certificate\n     *\n     * @param {*} obj -\n     * @returns {Boolean}\n     */\n    isCertificate: function (obj) {\n        return Boolean(obj) && ((obj instanceof Certificate) ||\n            _.inSuperChain(obj.constructor, '_postman_propertyName', Certificate._postman_propertyName));\n    }\n});\n\nmodule.exports = {\n    Certificate\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}