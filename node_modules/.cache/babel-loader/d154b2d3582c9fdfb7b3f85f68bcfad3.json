{"ast":null,"code":"var util = require('../util'),\n  _ = util.lodash,\n  httpReasons = require('http-reasons'),\n  LJSON = require('liquid-json'),\n  Property = require('./property').Property,\n  PropertyBase = require('./property-base').PropertyBase,\n  Request = require('./request').Request,\n  CookieList = require('./cookie-list').CookieList,\n  HeaderList = require('./header-list').HeaderList,\n  contentInfo = require('../content-info').contentInfo,\n  /**\n   * @private\n   * @const\n   * @type {string}\n   */\n  E = '',\n  /**\n   * @private\n   * @const\n   * @type {String}\n   */\n  HEADER = 'header',\n  /**\n   * @private\n   * @const\n   * @type {String}\n   */\n  BODY = 'body',\n  /**\n   * @private\n   * @const\n   * @type {String}\n   */\n  GZIP = 'gzip',\n  /**\n   * @private\n   * @const\n   * @type {String}\n   */\n  CONTENT_ENCODING = 'Content-Encoding',\n  /**\n   * @private\n   * @const\n   * @type {String}\n   */\n  CONTENT_LENGTH = 'Content-Length',\n  /**\n   * @private\n   * @const\n   * @type {string}\n   */\n  BASE64 = 'base64',\n  /**\n   * @private\n   * @const\n   * @type {string}\n   */\n  STREAM_TYPE_BUFFER = 'Buffer',\n  /**\n   * @private\n   * @const\n   * @type {string}\n   */\n  STREAM_TYPE_BASE64 = 'Base64',\n  /**\n   * @private\n   * @const\n   * @type {string}\n   */\n  FUNCTION = 'function',\n  /**\n   * @private\n   * @const\n   * @type {string}\n   */\n  STRING = 'string',\n  /**\n   * @private\n   * @const\n   * @type {String}\n   */\n  HTTP_X_X = 'HTTP/X.X',\n  /**\n   * @private\n   * @const\n   * @type {String}\n   */\n  SP = ' ',\n  /**\n   * @private\n   * @const\n   * @type {String}\n   */\n  CRLF = '\\r\\n',\n  /**\n   * @private\n   * @const\n   * @type {RegExp}\n   */\n  REGEX_JSONP_LEFT = /^[^{(].*\\(/,\n  /**\n   * @private\n   * @const\n   * @type {RegExp}\n   */\n  REGEX_JSONP_RIGHT = /\\)[^}].*$|\\)$/,\n  /**\n   * Remove JSON padded string to pure JSON\n   *\n   * @private\n   * @param {String} str -\n   * @returns {String}\n   */\n  stripJSONP = function (str) {\n    return str.replace(REGEX_JSONP_LEFT, E).replace(REGEX_JSONP_RIGHT, E);\n  },\n  /**\n   * @private\n   * @type {Boolean}\n   */\n  supportsBuffer = typeof Buffer !== undefined && _.isFunction(Buffer.byteLength),\n  /**\n   * Normalizes an input Buffer, Buffer.toJSON() or base64 string into a Buffer or ArrayBuffer.\n   *\n   * @private\n   * @param {Buffer|Object} stream - An instance of Buffer, Buffer.toJSON(), or Base64 string\n   * @returns {Buffer|ArrayBuffer|undefined}\n   */\n  normalizeStream = function (stream) {\n    if (!stream) {\n      return;\n    }\n\n    // create buffer from buffer's JSON representation\n    if (stream.type === STREAM_TYPE_BUFFER && _.isArray(stream.data)) {\n      // @todo Add tests for Browser environments, where ArrayBuffer is returned instead of Buffer\n      return typeof Buffer === FUNCTION ? Buffer.from(stream.data) : new Uint8Array(stream.data).buffer;\n    }\n\n    // create buffer from base64 string\n    if (stream.type === STREAM_TYPE_BASE64 && typeof stream.data === STRING) {\n      return Buffer.from(stream.data, BASE64);\n    }\n\n    // probably it's already of type buffer\n    return stream;\n  },\n  Response; // constructor\n\n/**\n * @typedef Response.definition\n * @property {Number} code - define the response code\n * @property {String=} [reason] - optionally, if the response has a non-standard response code reason, provide it here\n * @property {Array<Header.definition>} [header]\n * @property {Array<Cookie.definition>} [cookie]\n * @property {String} [body]\n * @property {Buffer|ArrayBuffer} [stream]\n * @property {Number} responseTime\n *\n * @todo pluralise `header`, `cookie`\n */\n_.inherit(\n/**\n * Response holds data related to the request body. By default, it provides a nice wrapper for url-encoded,\n * form-data, and raw types of request bodies.\n *\n * @constructor\n * @extends {Property}\n *\n * @param {Response.definition} options -\n */\nResponse = function PostmanResponse(options) {\n  // this constructor is intended to inherit and as such the super constructor is required to be executed\n  Response.super_.apply(this, arguments);\n  this.update(options || {});\n}, Property);\n_.assign(Response.prototype, /** @lends Response.prototype */{\n  update(options) {\n    // options.stream accepts Buffer, Buffer.toJSON() or base64 string\n    // @todo this temporarily doubles the memory footprint (options.stream + generated buffer).\n    var stream = normalizeStream(options.stream);\n    _.mergeDefined(this._details = _.clone(httpReasons.lookup(options.code)), {\n      name: _.choose(options.reason, options.status),\n      code: options.code,\n      standardName: this._details.name\n    });\n    _.mergeDefined(this, /** @lends Response.prototype */{\n      /**\n       * @type {Request}\n       */\n      originalRequest: options.originalRequest ? new Request(options.originalRequest) : undefined,\n      /**\n       * @type {String}\n       */\n      status: this._details.name,\n      /**\n       * @type {Number}\n       */\n      code: options.code,\n      /**\n       * @type {HeaderList}\n       */\n      headers: new HeaderList(this, options.header),\n      /**\n       * @type {String}\n       */\n      body: options.body,\n      /**\n       * @private\n       *\n       * @type {Buffer|UInt8Array}\n       */\n      stream: options.body && _.isObject(options.body) ? options.body : stream,\n      /**\n       * @type {CookieList}\n       */\n      cookies: new CookieList(this, options.cookie),\n      /**\n       * Time taken for the request to complete.\n       *\n       * @type {Number}\n       */\n      responseTime: options.responseTime,\n      /**\n       * @private\n       * @type {Number}\n       */\n      responseSize: stream && stream.byteLength\n    });\n  }\n});\n_.assign(Response.prototype, /** @lends Response.prototype */{\n  /**\n   * Defines that this property requires an ID field\n   *\n   * @private\n   * @readOnly\n   */\n  _postman_propertyRequiresId: true,\n  /**\n   * Convert this response into a JSON serializable object. The _details meta property is omitted.\n   *\n   * @returns {Object}\n   *\n   * @todo consider switching to a different response buffer (stream) representation as Buffer.toJSON\n   *       appears to cause multiple performance issues.\n   */\n  toJSON: function () {\n    // @todo benchmark PropertyBase.toJSON, response Buffer.toJSON or _.cloneElement might\n    // be the bottleneck.\n    var response = PropertyBase.toJSON(this);\n    response._details && delete response._details;\n    return response;\n  },\n  /**\n   * Get the http response reason phrase based on the current response code.\n   *\n   * @returns {String|undefined}\n   */\n  reason: function () {\n    return this.status || httpReasons.lookup(this.code).name;\n  },\n  /**\n   * Creates a JSON representation of the current response details, and returns it.\n   *\n   * @returns {Object} A set of response details, including the custom server reason.\n   * @private\n   */\n  details: function () {\n    if (!this._details || this._details.code !== this.code) {\n      this._details = _.clone(httpReasons.lookup(this.code));\n      this._details.code = this.code;\n      this._details.standardName = this._details.name;\n    }\n    return _.clone(this._details);\n  },\n  /**\n   * Get the response body as a string/text.\n   *\n   * @returns {String|undefined}\n   */\n  text: function () {\n    return this.stream ? util.bufferOrArrayBufferToString(this.stream, this.contentInfo().charset) : this.body;\n  },\n  /**\n   * Get the response body as a JavaScript object. Note that it throws an error if the response is not a valid JSON\n   *\n   * @param {Function=} [reviver] -\n   * @param {Boolean} [strict=false] Specify whether JSON parsing will be strict. This will fail on comments and BOM\n   * @example\n   * // assuming that the response is stored in a collection instance `myCollection`\n   * var response = myCollection.items.one('some request').responses.idx(0),\n   *     jsonBody;\n   * try {\n   *     jsonBody = response.json();\n   * }\n   * catch (e) {\n   *     console.log(\"There was an error parsing JSON \", e);\n   * }\n   * // log the root-level keys in the response JSON.\n   * console.log('All keys in json response: ' + Object.keys(json));\n   *\n   * @returns {Object}\n   */\n  json: function (reviver, strict) {\n    return LJSON.parse(this.text(), reviver, strict);\n  },\n  /**\n   * Get the JSON from response body that reuturns JSONP response.\n   *\n   * @param {Function=} [reviver] -\n   * @param {Boolean} [strict=false] Specify whether JSON parsing will be strict. This will fail on comments and BOM\n   *\n   * @throws {JSONError} when response body is empty\n   */\n  jsonp: function (reviver, strict) {\n    return LJSON.parse(stripJSONP(this.text() || /* istanbul ignore next */E), reviver, strict);\n  },\n  /**\n   * Extracts mime type, format, charset, extension and filename of the response content\n   * A fallback of default filename is given, if filename is not present in content-disposition header\n   *\n   * @returns {Response.ResponseContentInfo} - contentInfo for the response\n   */\n  contentInfo: function () {\n    return contentInfo(this);\n  },\n  /**\n   * @private\n   * @deprecated discontinued in v4.0\n   */\n  mime: function () {\n    throw new Error('`Response#mime` has been discontinued, use `Response#contentInfo` instead.');\n  },\n  /**\n   * Converts the response to a dataURI that can be used for storage or serialisation. The data URI is formed using\n   * the following syntax `data:<content-type>;baseg4, <base64-encoded-body>`.\n   *\n   * @returns {String}\n   * @todo write unit tests\n   */\n  dataURI: function () {\n    const {\n      contentType\n    } = this.contentInfo();\n\n    // if there is no mime detected, there is no accurate way to render this thing\n    /* istanbul ignore if */\n    if (!contentType) {\n      return E;\n    }\n\n    // we create the body string first from stream and then fallback to body\n    return `data:${contentType};base64, ` + (!_.isNil(this.stream) && util.bufferOrArrayBufferToBase64(this.stream) || !_.isNil(this.body) && util.btoa(this.body) || E);\n  },\n  /**\n   * Get the response size by computing the same from content length header or using the actual response body.\n   *\n   * @returns {Number}\n   * @todo write unit tests\n   */\n  size: function () {\n    var sizeInfo = {\n        body: 0,\n        header: 0,\n        total: 0\n      },\n      contentEncoding = this.headers.get(CONTENT_ENCODING),\n      contentLength = this.headers.get(CONTENT_LENGTH),\n      isCompressed = false,\n      byteLength;\n\n    // if server sent encoded data, we should first try deriving length from headers\n    if (_.isString(contentEncoding)) {\n      // desensitise case of content encoding\n      contentEncoding = contentEncoding.toLowerCase();\n      // eslint-disable-next-line lodash/prefer-includes\n      isCompressed = contentEncoding.indexOf('gzip') > -1 || contentEncoding.indexOf('deflate') > -1;\n    }\n\n    // if 'Content-Length' header is present and encoding is of type gzip/deflate, we take body as declared by\n    // server. else we need to compute the same.\n    if (contentLength && isCompressed && util.isNumeric(contentLength)) {\n      sizeInfo.body = _.parseInt(contentLength, 10);\n    }\n    // if there is a stream defined which looks like buffer, use it's data and move on\n    else if (this.stream) {\n      byteLength = this.stream.byteLength;\n      sizeInfo.body = util.isNumeric(byteLength) ? byteLength : /* istanbul ignore next */\n      0;\n    }\n    // otherwise, if body is defined, we try get the true length of the body\n    else if (!_.isNil(this.body)) {\n      sizeInfo.body = supportsBuffer ? Buffer.byteLength(this.body.toString()) : /* istanbul ignore next */\n      this.body.toString().length;\n    }\n\n    // size of header is added\n    // https://tools.ietf.org/html/rfc7230#section-3\n    // HTTP-message   = start-line (request-line / status-line)\n    //                  *( header-field CRLF )\n    //                  CRLF\n    //                  [ message-body ]\n    // status-line = HTTP-version SP status-code SP reason-phrase CRLF\n    sizeInfo.header = (HTTP_X_X + SP + this.code + SP + this.reason() + CRLF + CRLF).length + this.headers.contentSize();\n\n    // compute the approximate total body size by adding size of header and body\n    sizeInfo.total = (sizeInfo.body || 0) + sizeInfo.header;\n    return sizeInfo;\n  },\n  /**\n   * Returns the response encoding defined as header or detected from body.\n   *\n   * @private\n   * @returns {Object} - {format: string, source: string}\n   */\n  encoding: function () {\n    var contentEncoding = this.headers.get(CONTENT_ENCODING),\n      body = this.stream || this.body,\n      source;\n    if (contentEncoding) {\n      source = HEADER;\n    }\n\n    // if the encoding is not found, we check\n    else if (body) {\n      // @todo add detection for deflate\n      // eslint-disable-next-line lodash/prefer-matches\n      if (body[0] === 0x1F && body[1] === 0x8B && body[2] === 0x8) {\n        contentEncoding = GZIP;\n      }\n      if (contentEncoding) {\n        source = BODY;\n      }\n    }\n    return {\n      format: contentEncoding,\n      source: source\n    };\n  }\n});\n_.assign(Response, /** @lends Response */{\n  /**\n   * Defines the name of this property for internal use.\n   *\n   * @private\n   * @readOnly\n   * @type {String}\n   */\n  _postman_propertyName: 'Response',\n  /**\n   * Check whether an object is an instance of {@link ItemGroup}.\n   *\n   * @param {*} obj -\n   * @returns {Boolean}\n   */\n  isResponse: function (obj) {\n    return Boolean(obj) && (obj instanceof Response || _.inSuperChain(obj.constructor, '_postman_propertyName', Response._postman_propertyName));\n  },\n  /**\n   * Converts the response object from the request module to the postman responseBody format\n   *\n   * @param {Object} response The response object, as received from the request module\n   * @param {Object} cookies -\n   * @returns {Object} The transformed responseBody\n   * @todo Add a key: `originalRequest` to the returned object as well, referring to response.request\n   */\n  createFromNode: function (response, cookies) {\n    return new Response({\n      cookie: cookies,\n      body: response.body.toString(),\n      stream: response.body,\n      header: response.headers,\n      code: response.statusCode,\n      status: response.statusMessage,\n      responseTime: response.elapsedTime\n    });\n  },\n  /**\n   * @private\n   * @deprecated discontinued in v4.0\n   */\n  mimeInfo: function () {\n    throw new Error('`Response.mimeInfo` has been discontinued, use `Response#contentInfo` instead.');\n  },\n  /**\n   * Returns the durations of each request phase in milliseconds\n   *\n   * @typedef Response.timings\n   * @property {Number} start - timestamp of the request sent from the client (in Unix Epoch milliseconds)\n   * @property {Object} offset - event timestamps in millisecond resolution relative to start\n   * @property {Number} offset.request - timestamp of the start of the request\n   * @property {Number} offset.socket - timestamp when the socket is assigned to the request\n   * @property {Number} offset.lookup - timestamp when the DNS has been resolved\n   * @property {Number} offset.connect - timestamp when the server acknowledges the TCP connection\n   * @property {Number} offset.secureConnect - timestamp when secure handshaking process is completed\n   * @property {Number} offset.response -  timestamp when the first bytes are received from the server\n   * @property {Number} offset.end - timestamp when the last bytes of the response are received\n   * @property {Number} offset.done - timestamp when the response is received at the client\n   *\n   * @note If there were redirects, the properties reflect the timings\n   *       of the final request in the redirect chain\n   *\n   * @param {Response.timings} timings -\n   * @returns {Object}\n   *\n   * @example Output\n   * Request.timingPhases(timings);\n   * {\n   *     prepare: Number,         // duration of request preparation\n   *     wait: Number,            // duration of socket initialization\n   *     dns: Number,             // duration of DNS lookup\n   *     tcp: Number,             // duration of TCP connection\n   *     secureHandshake: Number, // duration of secure handshake\n   *     firstByte: Number,       // duration of HTTP server response\n   *     download: Number,        // duration of HTTP download\n   *     process: Number,         // duration of response processing\n   *     total: Number            // duration entire HTTP round-trip\n   * }\n   *\n   * @note if there were redirects, the properties reflect the timings of the\n   *       final request in the redirect chain.\n   */\n  timingPhases: function (timings) {\n    // bail out if timing information is not provided\n    if (!(timings && timings.offset)) {\n      return;\n    }\n    var phases,\n      offset = timings.offset;\n\n    // REFER: https://github.com/postmanlabs/postman-request/blob/v2.88.1-postman.5/request.js#L996\n    phases = {\n      prepare: offset.request,\n      wait: offset.socket - offset.request,\n      dns: offset.lookup - offset.socket,\n      tcp: offset.connect - offset.lookup,\n      firstByte: offset.response - offset.connect,\n      download: offset.end - offset.response,\n      process: offset.done - offset.end,\n      total: offset.done\n    };\n    if (offset.secureConnect) {\n      phases.secureHandshake = offset.secureConnect - offset.connect;\n      phases.firstByte = offset.response - offset.secureConnect;\n    }\n    return phases;\n  }\n});\nmodule.exports = {\n  Response\n};","map":{"version":3,"names":["util","require","_","lodash","httpReasons","LJSON","Property","PropertyBase","Request","CookieList","HeaderList","contentInfo","E","HEADER","BODY","GZIP","CONTENT_ENCODING","CONTENT_LENGTH","BASE64","STREAM_TYPE_BUFFER","STREAM_TYPE_BASE64","FUNCTION","STRING","HTTP_X_X","SP","CRLF","REGEX_JSONP_LEFT","REGEX_JSONP_RIGHT","stripJSONP","str","replace","supportsBuffer","Buffer","undefined","isFunction","byteLength","normalizeStream","stream","type","isArray","data","from","Uint8Array","buffer","Response","inherit","PostmanResponse","options","super_","apply","arguments","update","assign","prototype","mergeDefined","_details","clone","lookup","code","name","choose","reason","status","standardName","originalRequest","headers","header","body","isObject","cookies","cookie","responseTime","responseSize","_postman_propertyRequiresId","toJSON","response","details","text","bufferOrArrayBufferToString","charset","json","reviver","strict","parse","jsonp","mime","Error","dataURI","contentType","isNil","bufferOrArrayBufferToBase64","btoa","size","sizeInfo","total","contentEncoding","get","contentLength","isCompressed","isString","toLowerCase","indexOf","isNumeric","parseInt","toString","length","contentSize","encoding","source","format","_postman_propertyName","isResponse","obj","Boolean","inSuperChain","constructor","createFromNode","statusCode","statusMessage","elapsedTime","mimeInfo","timingPhases","timings","offset","phases","prepare","request","wait","socket","dns","tcp","connect","firstByte","download","end","process","done","secureConnect","secureHandshake","module","exports"],"sources":["/Users/Qusai.Qishta/node_modules/postman-collection/lib/collection/response.js"],"sourcesContent":["var util = require('../util'),\n    _ = util.lodash,\n    httpReasons = require('http-reasons'),\n    LJSON = require('liquid-json'),\n    Property = require('./property').Property,\n    PropertyBase = require('./property-base').PropertyBase,\n    Request = require('./request').Request,\n    CookieList = require('./cookie-list').CookieList,\n    HeaderList = require('./header-list').HeaderList,\n    contentInfo = require('../content-info').contentInfo,\n\n    /**\n     * @private\n     * @const\n     * @type {string}\n     */\n    E = '',\n\n    /**\n     * @private\n     * @const\n     * @type {String}\n     */\n    HEADER = 'header',\n\n    /**\n     * @private\n     * @const\n     * @type {String}\n     */\n    BODY = 'body',\n\n    /**\n     * @private\n     * @const\n     * @type {String}\n     */\n    GZIP = 'gzip',\n\n    /**\n     * @private\n     * @const\n     * @type {String}\n     */\n    CONTENT_ENCODING = 'Content-Encoding',\n\n    /**\n     * @private\n     * @const\n     * @type {String}\n     */\n    CONTENT_LENGTH = 'Content-Length',\n\n    /**\n     * @private\n     * @const\n     * @type {string}\n     */\n    BASE64 = 'base64',\n\n    /**\n     * @private\n     * @const\n     * @type {string}\n     */\n    STREAM_TYPE_BUFFER = 'Buffer',\n\n    /**\n     * @private\n     * @const\n     * @type {string}\n     */\n    STREAM_TYPE_BASE64 = 'Base64',\n\n    /**\n     * @private\n     * @const\n     * @type {string}\n     */\n    FUNCTION = 'function',\n\n    /**\n     * @private\n     * @const\n     * @type {string}\n     */\n    STRING = 'string',\n\n    /**\n     * @private\n     * @const\n     * @type {String}\n     */\n    HTTP_X_X = 'HTTP/X.X',\n\n    /**\n     * @private\n     * @const\n     * @type {String}\n     */\n    SP = ' ',\n\n    /**\n     * @private\n     * @const\n     * @type {String}\n     */\n    CRLF = '\\r\\n',\n\n    /**\n     * @private\n     * @const\n     * @type {RegExp}\n     */\n    REGEX_JSONP_LEFT = /^[^{(].*\\(/,\n\n    /**\n     * @private\n     * @const\n     * @type {RegExp}\n     */\n    REGEX_JSONP_RIGHT = /\\)[^}].*$|\\)$/,\n\n    /**\n     * Remove JSON padded string to pure JSON\n     *\n     * @private\n     * @param {String} str -\n     * @returns {String}\n     */\n    stripJSONP = function (str) {\n        return str.replace(REGEX_JSONP_LEFT, E).replace(REGEX_JSONP_RIGHT, E);\n    },\n\n    /**\n     * @private\n     * @type {Boolean}\n     */\n    supportsBuffer = (typeof Buffer !== undefined) && _.isFunction(Buffer.byteLength),\n\n    /**\n     * Normalizes an input Buffer, Buffer.toJSON() or base64 string into a Buffer or ArrayBuffer.\n     *\n     * @private\n     * @param {Buffer|Object} stream - An instance of Buffer, Buffer.toJSON(), or Base64 string\n     * @returns {Buffer|ArrayBuffer|undefined}\n     */\n    normalizeStream = function (stream) {\n        if (!stream) { return; }\n\n        // create buffer from buffer's JSON representation\n        if (stream.type === STREAM_TYPE_BUFFER && _.isArray(stream.data)) {\n            // @todo Add tests for Browser environments, where ArrayBuffer is returned instead of Buffer\n            return typeof Buffer === FUNCTION ? Buffer.from(stream.data) : new Uint8Array(stream.data).buffer;\n        }\n\n        // create buffer from base64 string\n        if (stream.type === STREAM_TYPE_BASE64 && typeof stream.data === STRING) {\n            return Buffer.from(stream.data, BASE64);\n        }\n\n        // probably it's already of type buffer\n        return stream;\n    },\n\n    Response; // constructor\n\n/**\n * @typedef Response.definition\n * @property {Number} code - define the response code\n * @property {String=} [reason] - optionally, if the response has a non-standard response code reason, provide it here\n * @property {Array<Header.definition>} [header]\n * @property {Array<Cookie.definition>} [cookie]\n * @property {String} [body]\n * @property {Buffer|ArrayBuffer} [stream]\n * @property {Number} responseTime\n *\n * @todo pluralise `header`, `cookie`\n */\n_.inherit((\n\n    /**\n     * Response holds data related to the request body. By default, it provides a nice wrapper for url-encoded,\n     * form-data, and raw types of request bodies.\n     *\n     * @constructor\n     * @extends {Property}\n     *\n     * @param {Response.definition} options -\n     */\n    Response = function PostmanResponse (options) {\n        // this constructor is intended to inherit and as such the super constructor is required to be executed\n        Response.super_.apply(this, arguments);\n        this.update(options || {});\n    }), Property);\n\n_.assign(Response.prototype, /** @lends Response.prototype */ {\n    update (options) {\n        // options.stream accepts Buffer, Buffer.toJSON() or base64 string\n        // @todo this temporarily doubles the memory footprint (options.stream + generated buffer).\n        var stream = normalizeStream(options.stream);\n\n        _.mergeDefined((this._details = _.clone(httpReasons.lookup(options.code))), {\n            name: _.choose(options.reason, options.status),\n            code: options.code,\n            standardName: this._details.name\n        });\n\n        _.mergeDefined(this, /** @lends Response.prototype */ {\n            /**\n             * @type {Request}\n             */\n            originalRequest: options.originalRequest ? new Request(options.originalRequest) : undefined,\n\n            /**\n             * @type {String}\n             */\n            status: this._details.name,\n\n            /**\n             * @type {Number}\n             */\n            code: options.code,\n\n            /**\n             * @type {HeaderList}\n             */\n            headers: new HeaderList(this, options.header),\n\n            /**\n             * @type {String}\n             */\n            body: options.body,\n\n            /**\n             * @private\n             *\n             * @type {Buffer|UInt8Array}\n             */\n            stream: (options.body && _.isObject(options.body)) ? options.body : stream,\n\n            /**\n             * @type {CookieList}\n             */\n            cookies: new CookieList(this, options.cookie),\n\n            /**\n             * Time taken for the request to complete.\n             *\n             * @type {Number}\n             */\n            responseTime: options.responseTime,\n\n            /**\n             * @private\n             * @type {Number}\n             */\n            responseSize: stream && stream.byteLength\n        });\n    }\n});\n\n_.assign(Response.prototype, /** @lends Response.prototype */ {\n    /**\n     * Defines that this property requires an ID field\n     *\n     * @private\n     * @readOnly\n     */\n    _postman_propertyRequiresId: true,\n\n    /**\n     * Convert this response into a JSON serializable object. The _details meta property is omitted.\n     *\n     * @returns {Object}\n     *\n     * @todo consider switching to a different response buffer (stream) representation as Buffer.toJSON\n     *       appears to cause multiple performance issues.\n     */\n    toJSON: function () {\n        // @todo benchmark PropertyBase.toJSON, response Buffer.toJSON or _.cloneElement might\n        // be the bottleneck.\n        var response = PropertyBase.toJSON(this);\n\n        response._details && (delete response._details);\n\n        return response;\n    },\n\n    /**\n     * Get the http response reason phrase based on the current response code.\n     *\n     * @returns {String|undefined}\n     */\n    reason: function () {\n        return this.status || httpReasons.lookup(this.code).name;\n    },\n\n    /**\n     * Creates a JSON representation of the current response details, and returns it.\n     *\n     * @returns {Object} A set of response details, including the custom server reason.\n     * @private\n     */\n    details: function () {\n        if (!this._details || this._details.code !== this.code) {\n            this._details = _.clone(httpReasons.lookup(this.code));\n            this._details.code = this.code;\n            this._details.standardName = this._details.name;\n        }\n\n        return _.clone(this._details);\n    },\n\n    /**\n     * Get the response body as a string/text.\n     *\n     * @returns {String|undefined}\n     */\n    text: function () {\n        return (this.stream ? util.bufferOrArrayBufferToString(this.stream, this.contentInfo().charset) : this.body);\n    },\n\n    /**\n     * Get the response body as a JavaScript object. Note that it throws an error if the response is not a valid JSON\n     *\n     * @param {Function=} [reviver] -\n     * @param {Boolean} [strict=false] Specify whether JSON parsing will be strict. This will fail on comments and BOM\n     * @example\n     * // assuming that the response is stored in a collection instance `myCollection`\n     * var response = myCollection.items.one('some request').responses.idx(0),\n     *     jsonBody;\n     * try {\n     *     jsonBody = response.json();\n     * }\n     * catch (e) {\n     *     console.log(\"There was an error parsing JSON \", e);\n     * }\n     * // log the root-level keys in the response JSON.\n     * console.log('All keys in json response: ' + Object.keys(json));\n     *\n     * @returns {Object}\n     */\n    json: function (reviver, strict) {\n        return LJSON.parse(this.text(), reviver, strict);\n    },\n\n    /**\n     * Get the JSON from response body that reuturns JSONP response.\n     *\n     * @param {Function=} [reviver] -\n     * @param {Boolean} [strict=false] Specify whether JSON parsing will be strict. This will fail on comments and BOM\n     *\n     * @throws {JSONError} when response body is empty\n     */\n    jsonp: function (reviver, strict) {\n        return LJSON.parse(stripJSONP(this.text() || /* istanbul ignore next */ E), reviver, strict);\n    },\n\n    /**\n     * Extracts mime type, format, charset, extension and filename of the response content\n     * A fallback of default filename is given, if filename is not present in content-disposition header\n     *\n     * @returns {Response.ResponseContentInfo} - contentInfo for the response\n     */\n    contentInfo: function () {\n        return contentInfo(this);\n    },\n\n    /**\n     * @private\n     * @deprecated discontinued in v4.0\n     */\n    mime: function () {\n        throw new Error('`Response#mime` has been discontinued, use `Response#contentInfo` instead.');\n    },\n\n    /**\n     * Converts the response to a dataURI that can be used for storage or serialisation. The data URI is formed using\n     * the following syntax `data:<content-type>;baseg4, <base64-encoded-body>`.\n     *\n     * @returns {String}\n     * @todo write unit tests\n     */\n    dataURI: function () {\n        const { contentType } = this.contentInfo();\n\n        // if there is no mime detected, there is no accurate way to render this thing\n        /* istanbul ignore if */\n        if (!contentType) {\n            return E;\n        }\n\n        // we create the body string first from stream and then fallback to body\n        return `data:${contentType};base64, ` + ((!_.isNil(this.stream) &&\n            util.bufferOrArrayBufferToBase64(this.stream)) || (!_.isNil(this.body) && util.btoa(this.body)) || E);\n    },\n\n    /**\n     * Get the response size by computing the same from content length header or using the actual response body.\n     *\n     * @returns {Number}\n     * @todo write unit tests\n     */\n    size: function () {\n        var sizeInfo = {\n                body: 0,\n                header: 0,\n                total: 0\n            },\n\n            contentEncoding = this.headers.get(CONTENT_ENCODING),\n            contentLength = this.headers.get(CONTENT_LENGTH),\n            isCompressed = false,\n            byteLength;\n\n        // if server sent encoded data, we should first try deriving length from headers\n        if (_.isString(contentEncoding)) {\n            // desensitise case of content encoding\n            contentEncoding = contentEncoding.toLowerCase();\n            // eslint-disable-next-line lodash/prefer-includes\n            isCompressed = (contentEncoding.indexOf('gzip') > -1) || (contentEncoding.indexOf('deflate') > -1);\n        }\n\n        // if 'Content-Length' header is present and encoding is of type gzip/deflate, we take body as declared by\n        // server. else we need to compute the same.\n        if (contentLength && isCompressed && util.isNumeric(contentLength)) {\n            sizeInfo.body = _.parseInt(contentLength, 10);\n        }\n        // if there is a stream defined which looks like buffer, use it's data and move on\n        else if (this.stream) {\n            byteLength = this.stream.byteLength;\n            sizeInfo.body = util.isNumeric(byteLength) ? byteLength :\n                /* istanbul ignore next */\n                0;\n        }\n        // otherwise, if body is defined, we try get the true length of the body\n        else if (!_.isNil(this.body)) {\n            sizeInfo.body = supportsBuffer ? Buffer.byteLength(this.body.toString()) :\n                /* istanbul ignore next */\n                this.body.toString().length;\n        }\n\n        // size of header is added\n        // https://tools.ietf.org/html/rfc7230#section-3\n        // HTTP-message   = start-line (request-line / status-line)\n        //                  *( header-field CRLF )\n        //                  CRLF\n        //                  [ message-body ]\n        // status-line = HTTP-version SP status-code SP reason-phrase CRLF\n        sizeInfo.header = (HTTP_X_X + SP + this.code + SP + this.reason() + CRLF + CRLF).length +\n            this.headers.contentSize();\n\n        // compute the approximate total body size by adding size of header and body\n        sizeInfo.total = (sizeInfo.body || 0) + (sizeInfo.header);\n\n        return sizeInfo;\n    },\n\n    /**\n     * Returns the response encoding defined as header or detected from body.\n     *\n     * @private\n     * @returns {Object} - {format: string, source: string}\n     */\n    encoding: function () {\n        var contentEncoding = this.headers.get(CONTENT_ENCODING),\n            body = this.stream || this.body,\n            source;\n\n        if (contentEncoding) {\n            source = HEADER;\n        }\n\n        // if the encoding is not found, we check\n        else if (body) { // @todo add detection for deflate\n            // eslint-disable-next-line lodash/prefer-matches\n            if (body[0] === 0x1F && body[1] === 0x8B && body[2] === 0x8) {\n                contentEncoding = GZIP;\n            }\n\n            if (contentEncoding) {\n                source = BODY;\n            }\n        }\n\n        return {\n            format: contentEncoding,\n            source: source\n        };\n    }\n});\n\n_.assign(Response, /** @lends Response */ {\n    /**\n     * Defines the name of this property for internal use.\n     *\n     * @private\n     * @readOnly\n     * @type {String}\n     */\n    _postman_propertyName: 'Response',\n\n    /**\n     * Check whether an object is an instance of {@link ItemGroup}.\n     *\n     * @param {*} obj -\n     * @returns {Boolean}\n     */\n    isResponse: function (obj) {\n        return Boolean(obj) && ((obj instanceof Response) ||\n            _.inSuperChain(obj.constructor, '_postman_propertyName', Response._postman_propertyName));\n    },\n\n    /**\n     * Converts the response object from the request module to the postman responseBody format\n     *\n     * @param {Object} response The response object, as received from the request module\n     * @param {Object} cookies -\n     * @returns {Object} The transformed responseBody\n     * @todo Add a key: `originalRequest` to the returned object as well, referring to response.request\n     */\n    createFromNode: function (response, cookies) {\n        return new Response({\n            cookie: cookies,\n            body: response.body.toString(),\n            stream: response.body,\n            header: response.headers,\n            code: response.statusCode,\n            status: response.statusMessage,\n            responseTime: response.elapsedTime\n        });\n    },\n\n    /**\n     * @private\n     * @deprecated discontinued in v4.0\n     */\n    mimeInfo: function () {\n        throw new Error('`Response.mimeInfo` has been discontinued, use `Response#contentInfo` instead.');\n    },\n\n    /**\n     * Returns the durations of each request phase in milliseconds\n     *\n     * @typedef Response.timings\n     * @property {Number} start - timestamp of the request sent from the client (in Unix Epoch milliseconds)\n     * @property {Object} offset - event timestamps in millisecond resolution relative to start\n     * @property {Number} offset.request - timestamp of the start of the request\n     * @property {Number} offset.socket - timestamp when the socket is assigned to the request\n     * @property {Number} offset.lookup - timestamp when the DNS has been resolved\n     * @property {Number} offset.connect - timestamp when the server acknowledges the TCP connection\n     * @property {Number} offset.secureConnect - timestamp when secure handshaking process is completed\n     * @property {Number} offset.response -  timestamp when the first bytes are received from the server\n     * @property {Number} offset.end - timestamp when the last bytes of the response are received\n     * @property {Number} offset.done - timestamp when the response is received at the client\n     *\n     * @note If there were redirects, the properties reflect the timings\n     *       of the final request in the redirect chain\n     *\n     * @param {Response.timings} timings -\n     * @returns {Object}\n     *\n     * @example Output\n     * Request.timingPhases(timings);\n     * {\n     *     prepare: Number,         // duration of request preparation\n     *     wait: Number,            // duration of socket initialization\n     *     dns: Number,             // duration of DNS lookup\n     *     tcp: Number,             // duration of TCP connection\n     *     secureHandshake: Number, // duration of secure handshake\n     *     firstByte: Number,       // duration of HTTP server response\n     *     download: Number,        // duration of HTTP download\n     *     process: Number,         // duration of response processing\n     *     total: Number            // duration entire HTTP round-trip\n     * }\n     *\n     * @note if there were redirects, the properties reflect the timings of the\n     *       final request in the redirect chain.\n     */\n    timingPhases: function (timings) {\n        // bail out if timing information is not provided\n        if (!(timings && timings.offset)) {\n            return;\n        }\n\n        var phases,\n            offset = timings.offset;\n\n        // REFER: https://github.com/postmanlabs/postman-request/blob/v2.88.1-postman.5/request.js#L996\n        phases = {\n            prepare: offset.request,\n            wait: offset.socket - offset.request,\n            dns: offset.lookup - offset.socket,\n            tcp: offset.connect - offset.lookup,\n            firstByte: offset.response - offset.connect,\n            download: offset.end - offset.response,\n            process: offset.done - offset.end,\n            total: offset.done\n        };\n\n        if (offset.secureConnect) {\n            phases.secureHandshake = offset.secureConnect - offset.connect;\n            phases.firstByte = offset.response - offset.secureConnect;\n        }\n\n        return phases;\n    }\n});\n\nmodule.exports = {\n    Response\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}