{"ast":null,"code":"/**\n * An instruction is a self contained piece of information that can be created and then later be executed. {@link Run}\n * instance uses this as the values of the `Run.next` queue.\n *\n * @module  Run~Instructions\n */\nvar _ = require('lodash'),\n  Timings = require('./timings'),\n  arrayProtoSlice = Array.prototype.slice,\n  arrayProtoUnshift = Array.prototype.unshift,\n  pool; // function\n\n/**\n * Create a new instruction pool\n *\n * @param {Object.<Function>} processors - hash of all command processor functions\n * @returns {InstructionPool}\n */\npool = function (processors) {\n  !_.isObject(processors) && (processors = {});\n\n  /**\n   * Create a new instruction to be executed later\n   *\n   * @constructor\n   *\n   * @param {String} name - name of the instruction. this is useful for later lookup of the `processor` function when\n   * deserialising this object\n   * @param {Object} [payload] - a **JSON compatible** object that will be forwarded as the 2nd last parameter to the\n   * processor.\n   * @param {Array} [args] - all the arguments that needs to be passed to the processor is in this array\n   * @private\n   * @example\n   * var inst = Instruction.create(function (arg1, payload, next) {\n   *         console.log(payload);\n   *         next(null, 'hello-on-execute with ' + arg1);\n   *     }, 'sample-instruction', {\n   *         payloadData1: 'value'\n   *     }, ['one-arg']);\n   *\n   * // now, when we do execute, the result will be a console.log of payload and message will be as expected\n   * instance.execute(function (err, message) {\n   *     console.log(message);\n   * });\n   *\n   */\n  var Instruction = function (name, payload, args) {\n    var processor = processors[name];\n    if (!_.isString(name) || !_.isFunction(processor)) {\n      throw new Error('run-instruction: invalid construction');\n    }\n\n    // ensure that payload is an object so that data storage can be done. also ensure arguments is an array\n    !_.isObject(payload) && (payload = {});\n    !_.isArray(args) && (args = []);\n    _.assign(this, /** @lends Instruction.prototype */{\n      /**\n       * @type {String}\n       */\n      action: name,\n      /**\n       * @type {Object}\n       */\n      payload: payload,\n      /**\n       * @type {Array}\n       */\n      in: args,\n      /**\n       * @type {Timings}\n       */\n      timings: Timings.create(),\n      /**\n       * @private\n       * @type {Function}\n       */\n      _processor: processor\n    });\n\n    // record the timing when this instruction was created\n    this.timings.record('created');\n  };\n\n  /**\n   * Shortcut to `new Instruction(...);`\n   *\n   * @param {Function} processor -\n   * @param {String} name -\n   * @param {Object} [payload] -\n   * @param {Array} [args] -\n   *\n   * @returns {Instruction}\n   */\n  Instruction.create = function (processor, name, payload, args) {\n    return new Instruction(processor, name, payload, args);\n  };\n\n  /**\n   * Store all thenable items\n   *\n   * @type {Array}\n   */\n  Instruction._queue = [];\n\n  /**\n   * Executes an instruction with previously saved payload and arguments\n   *\n   * @param {Function} callback -\n   * @param {*} [scope] -\n   *\n   * @todo: use timeback and control it via options sent during pool creation as an option\n   */\n  Instruction.prototype.execute = function (callback, scope) {\n    !scope && (scope = this);\n    var params = _.clone(this.in),\n      sealed = false,\n      doneAndSpread = function (err) {\n        if (sealed) {\n          console.error('__postmanruntime_fatal_debug: instruction.execute callback called twice');\n          if (err) {\n            console.error(err);\n          }\n          return;\n        }\n        sealed = true;\n        this.timings.record('end');\n        var args = arrayProtoSlice.call(arguments);\n        arrayProtoUnshift.call(args, scope);\n        if (err) {\n          // in case it errored, we do not process any thenables\n          _.isArray(this._catch) && _.invokeMap(this._catch, _.apply, scope, arguments);\n        } else {\n          // call all the `then` stuff and then the main callback\n          _.isArray(this._done) && _.invokeMap(this._done, _.apply, scope, _.tail(arguments));\n        }\n        setTimeout(callback.bind(...args), 0);\n      }.bind(this);\n\n    // add two additional arguments at the end of the arguments saved - i.e. the payload and a function to call the\n    // callback asynchronously\n    params.push(this.payload, doneAndSpread);\n    this.timings.record('start');\n\n    // run the processor in a try block to avoid causing stalled runs\n    try {\n      this._processor.apply(scope, params);\n    } catch (e) {\n      doneAndSpread(e);\n    }\n  };\n  Instruction.prototype.done = function (callback) {\n    (this._done || (this._done = [])).push(callback);\n    return this;\n  };\n  Instruction.prototype.catch = function (callback) {\n    (this._catch || (this._catch = [])).push(callback);\n    return this;\n  };\n  Instruction.clear = function () {\n    _.forEach(Instruction._queue, function (instruction) {\n      delete instruction._done;\n    });\n    Instruction._queue.length = 0;\n  };\n  Instruction.shift = function () {\n    return Instruction._queue.shift(...arguments);\n  };\n  Instruction.unshift = function () {\n    return Instruction._queue.unshift(...arguments);\n  };\n  Instruction.push = function () {\n    return Instruction._queue.push(...arguments);\n  };\n  return Instruction;\n};\nmodule.exports = {\n  pool\n};","map":{"version":3,"names":["_","require","Timings","arrayProtoSlice","Array","prototype","slice","arrayProtoUnshift","unshift","pool","processors","isObject","Instruction","name","payload","args","processor","isString","isFunction","Error","isArray","assign","action","in","timings","create","_processor","record","_queue","execute","callback","scope","params","clone","sealed","doneAndSpread","err","console","error","call","arguments","_catch","invokeMap","apply","_done","tail","setTimeout","bind","push","e","done","catch","clear","forEach","instruction","length","shift","module","exports"],"sources":["/Users/Qusai.Qishta/node_modules/postman-runtime/lib/runner/instruction.js"],"sourcesContent":["/**\n * An instruction is a self contained piece of information that can be created and then later be executed. {@link Run}\n * instance uses this as the values of the `Run.next` queue.\n *\n * @module  Run~Instructions\n */\nvar _ = require('lodash'),\n    Timings = require('./timings'),\n\n    arrayProtoSlice = Array.prototype.slice,\n    arrayProtoUnshift = Array.prototype.unshift,\n\n    pool; // function\n\n/**\n * Create a new instruction pool\n *\n * @param {Object.<Function>} processors - hash of all command processor functions\n * @returns {InstructionPool}\n */\npool = function (processors) {\n    !_.isObject(processors) && (processors = {});\n\n    /**\n     * Create a new instruction to be executed later\n     *\n     * @constructor\n     *\n     * @param {String} name - name of the instruction. this is useful for later lookup of the `processor` function when\n     * deserialising this object\n     * @param {Object} [payload] - a **JSON compatible** object that will be forwarded as the 2nd last parameter to the\n     * processor.\n     * @param {Array} [args] - all the arguments that needs to be passed to the processor is in this array\n     * @private\n     * @example\n     * var inst = Instruction.create(function (arg1, payload, next) {\n     *         console.log(payload);\n     *         next(null, 'hello-on-execute with ' + arg1);\n     *     }, 'sample-instruction', {\n     *         payloadData1: 'value'\n     *     }, ['one-arg']);\n     *\n     * // now, when we do execute, the result will be a console.log of payload and message will be as expected\n     * instance.execute(function (err, message) {\n     *     console.log(message);\n     * });\n     *\n     */\n    var Instruction = function (name, payload, args) {\n        var processor = processors[name];\n\n        if (!_.isString(name) || !_.isFunction(processor)) {\n            throw new Error('run-instruction: invalid construction');\n        }\n\n        // ensure that payload is an object so that data storage can be done. also ensure arguments is an array\n        !_.isObject(payload) && (payload = {});\n        !_.isArray(args) && (args = []);\n\n        _.assign(this, /** @lends Instruction.prototype */ {\n            /**\n             * @type {String}\n             */\n            action: name,\n\n            /**\n             * @type {Object}\n             */\n            payload: payload,\n\n            /**\n             * @type {Array}\n             */\n            in: args,\n\n            /**\n             * @type {Timings}\n             */\n            timings: Timings.create(),\n\n            /**\n             * @private\n             * @type {Function}\n             */\n            _processor: processor\n        });\n\n        // record the timing when this instruction was created\n        this.timings.record('created');\n    };\n\n    /**\n     * Shortcut to `new Instruction(...);`\n     *\n     * @param {Function} processor -\n     * @param {String} name -\n     * @param {Object} [payload] -\n     * @param {Array} [args] -\n     *\n     * @returns {Instruction}\n     */\n    Instruction.create = function (processor, name, payload, args) {\n        return new Instruction(processor, name, payload, args);\n    };\n\n    /**\n     * Store all thenable items\n     *\n     * @type {Array}\n     */\n    Instruction._queue = [];\n\n    /**\n     * Executes an instruction with previously saved payload and arguments\n     *\n     * @param {Function} callback -\n     * @param {*} [scope] -\n     *\n     * @todo: use timeback and control it via options sent during pool creation as an option\n     */\n    Instruction.prototype.execute = function (callback, scope) {\n        !scope && (scope = this);\n\n        var params = _.clone(this.in),\n            sealed = false,\n\n            doneAndSpread = function (err) {\n                if (sealed) {\n                    console.error('__postmanruntime_fatal_debug: instruction.execute callback called twice');\n                    if (err) {\n                        console.error(err);\n                    }\n\n                    return;\n                }\n                sealed = true;\n                this.timings.record('end');\n\n                var args = arrayProtoSlice.call(arguments);\n\n                arrayProtoUnshift.call(args, scope);\n\n                if (err) { // in case it errored, we do not process any thenables\n                    _.isArray(this._catch) && _.invokeMap(this._catch, _.apply, scope, arguments);\n                }\n                else {\n                    // call all the `then` stuff and then the main callback\n                    _.isArray(this._done) && _.invokeMap(this._done, _.apply, scope, _.tail(arguments));\n                }\n\n                setTimeout(callback.bind(...args), 0);\n            }.bind(this);\n\n        // add two additional arguments at the end of the arguments saved - i.e. the payload and a function to call the\n        // callback asynchronously\n        params.push(this.payload, doneAndSpread);\n\n        this.timings.record('start');\n\n        // run the processor in a try block to avoid causing stalled runs\n        try {\n            this._processor.apply(scope, params);\n        }\n        catch (e) {\n            doneAndSpread(e);\n        }\n    };\n\n    Instruction.prototype.done = function (callback) {\n        (this._done || (this._done = [])).push(callback);\n\n        return this;\n    };\n\n    Instruction.prototype.catch = function (callback) {\n        (this._catch || (this._catch = [])).push(callback);\n\n        return this;\n    };\n\n    Instruction.clear = function () {\n        _.forEach(Instruction._queue, function (instruction) {\n            delete instruction._done;\n        });\n        Instruction._queue.length = 0;\n    };\n\n    Instruction.shift = function () {\n        return Instruction._queue.shift(...arguments);\n    };\n\n    Instruction.unshift = function () {\n        return Instruction._queue.unshift(...arguments);\n    };\n\n    Instruction.push = function () {\n        return Instruction._queue.push(...arguments);\n    };\n\n    return Instruction;\n};\n\nmodule.exports = {\n    pool\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}