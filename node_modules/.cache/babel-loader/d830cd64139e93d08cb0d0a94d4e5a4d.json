{"ast":null,"code":"/* eslint-disable object-shorthand */\nvar _ = require('lodash').noConflict(),\n  constants = require('../../constants'),\n  v1Common = require('../../common/v1'),\n  util = require('../../util'),\n  headersCommentPrefix = '//',\n  IS_SUBFOLDER = Symbol('_postman_isSubFolder'),\n  /**\n   * A constructor that is capable of being used for one-off conversions of requests, and folders.\n   *\n   * @param {Object} options - The set of options for builder construction.\n   * @class Builders\n   * @constructor\n   */\n  Builders = function (options) {\n    this.options = options || {};\n  },\n  /**\n   * Parse formdata & urlencoded request data.\n   *   - filter params missing property `key`\n   *   - handle file type param value\n   *   -cleanup `enabled` & `description`\n   *\n   * @param {Object[]} data - Data to parse.\n   * @param {?Boolean} [retainEmpty] - To retain empty values or not.\n   * @returns {Object[]} - Parsed data.\n   */\n  parseFormData = function (data, retainEmpty) {\n    if (!(Array.isArray(data) && data.length)) {\n      return [];\n    }\n    var formdata = [],\n      i,\n      ii,\n      param;\n    for (i = 0, ii = data.length; i < ii; i++) {\n      // clone param to avoid mutating data.\n      // eslint-disable-next-line prefer-object-spread\n      param = Object.assign({}, data[i]);\n\n      // skip if param is missing property `key`,\n      // `key` is a required property, value can be null/undefined.\n      // because in a FormParam property lists, key is used for indexing.\n      if (_.isNil(param.key)) {\n        continue;\n      }\n\n      // for file `type`, set `value` to `src`\n      if (param.type === 'file' && !param.src && param.value) {\n        param.src = _.isString(param.value) || _.isArray(param.value) ? param.value : null;\n        delete param.value;\n      }\n\n      // `hasOwnProperty` check ensures that it don't delete undefined property: `enabled`\n      if (Object.prototype.hasOwnProperty.call(param, 'enabled')) {\n        // set `disabled` flag if `enabled` is false.\n        param.enabled === false && (param.disabled = true);\n        delete param.enabled; // cleanup\n      }\n\n      // Prevent empty descriptions from showing up in the converted results. This keeps collections clean.\n      util.cleanEmptyValue(param, 'description', retainEmpty);\n      formdata.push(param);\n    }\n    return formdata;\n  };\n_.assign(Builders.prototype, {\n  /**\n   * Constructs a V2 compatible \"info\" object from a V1 Postman Collection\n   *\n   * @param {Object} collectionV1 - A v1 collection to derive collection metadata from.\n   * @returns {Object} - The resultant v2 info object.\n   */\n  info: function (collectionV1) {\n    var info = {\n      _postman_id: collectionV1.id || util.uid(),\n      name: collectionV1.name\n    };\n    if (collectionV1.description) {\n      info.description = collectionV1.description;\n    } else if (this.options.retainEmptyValues) {\n      info.description = null;\n    }\n    info.schema = constants.SCHEMA_V2_URL;\n    return info;\n  },\n  /**\n   * Facilitates sanitized variable transformations across all levels for v1 collection normalization.\n   *\n   * @param {Object} entity - The wrapper object containing variable definitions.\n   * @param {?Object} options - The set of options for the current variable transformation.\n   * @param {?Object} options.fallback - The set of fallback values to be applied when no variables exist.\n   * @param {?Boolean} options.noDefaults - When set to true, no defaults are applied.\n   * @param {?Boolean} options.retainIds - When set to true, ids are left as is.\n   * @returns {Object[]} - The set of sanitized variables.\n   */\n  variable: function (entity, options) {\n    return util.handleVars(entity, options);\n  },\n  /**\n   * Constructs a V2 compatible URL object from a V1 request\n   *\n   * @param {Object} requestV1 - The source v1 request to extract the URL from.\n   * @returns {String|Object} - The resultant URL.\n   */\n  url: function (requestV1) {\n    var queryParams = [],\n      pathVariables = [],\n      traversedVars = {},\n      queryParamAltered,\n      retainIds = this.options.retainIds,\n      parsed = util.urlparse(requestV1.url),\n      retainEmpty = this.options.retainEmptyValues;\n\n    // add query params\n    _.forEach(requestV1.queryParams, function (queryParam) {\n      queryParam.enabled === false && (queryParam.disabled = true);\n      delete queryParam.enabled;\n      util.cleanEmptyValue(queryParam, 'description', retainEmpty);\n      if (_.has(queryParam, 'equals')) {\n        if (queryParam.equals) {\n          queryParam.value === null && (queryParam.value = '');\n        } else {\n          // = is not appended when the value is null. However,\n          // non empty value should be preserved\n          queryParam.value = queryParam.value || null;\n        }\n        queryParamAltered = true;\n        delete queryParam.equals;\n      }\n      queryParams.push(queryParam);\n    });\n\n    // only add query params from URL if not given explicitly\n    if (!_.size(queryParams)) {\n      // parsed query params are taken from the url, so no descriptions are available from them\n      queryParams = parsed.query;\n    }\n\n    // Merge path variables\n    _.forEach(requestV1.pathVariableData, function (pathVariable) {\n      pathVariable = _.clone(pathVariable);\n      util.cleanEmptyValue(pathVariable, 'description', retainEmpty);\n      if (!retainIds && pathVariable.id) {\n        delete pathVariable.id;\n      }\n      pathVariables.push(pathVariable);\n      traversedVars[pathVariable.key] = true;\n    });\n    // pathVariables in v1 are of the form  {foo: bar}, so no descriptions can be obtained from them\n    _.forEach(requestV1.pathVariables, function (value, key) {\n      !traversedVars[key] && pathVariables.push({\n        value: value,\n        key: key\n      });\n    });\n    !_.isEmpty(queryParams) && (parsed.query = queryParams);\n    !_.isEmpty(pathVariables) && (parsed.variable = pathVariables);\n\n    // If the query params have been altered, update the raw stringified URL\n    queryParamAltered && (parsed.raw = util.urlunparse(parsed));\n\n    // return the objectified URL only if query param or path variable descriptions are present, string otherwise\n    return parsed.query || parsed.variable ? parsed : parsed.raw || (\n    // avoid unnecessary empty string for null or undefined input\n    _.isNil(requestV1.url) ? undefined : String(requestV1.url));\n  },\n  /**\n   * Extracts the HTTP Method from a V1 request\n   *\n   * @param {Object} requestV1 - The v1 request to extract the request method from.\n   * @returns {String} - The extracted request method.\n   */\n  method: function (requestV1) {\n    return requestV1.method;\n  },\n  /**\n   * Constructs an array of Key-Values from a raw HTTP Header string.\n   *\n   * @param {Object} requestV1 - The v1 request to extract header information from.\n   * @returns {Object[]} - A list of header definition objects.\n   */\n  header: function (requestV1) {\n    if (_.isArray(requestV1.headers)) {\n      return requestV1.headers;\n    }\n    var headers = [],\n      traversed = {},\n      headerData = requestV1.headerData || [],\n      retainEmpty = this.options.retainEmptyValues;\n    _.forEach(headerData, function (header) {\n      if (_.startsWith(header.key, headersCommentPrefix) || header.enabled === false) {\n        header.disabled = true;\n        header.key = header.key.replace(headersCommentPrefix, '').trim();\n      }\n\n      // prevent empty header descriptions from showing up in converted results. This keeps the collections clean\n      util.cleanEmptyValue(header, 'description', retainEmpty);\n      delete header.enabled;\n      headers.push(header); // @todo Improve this sequence to account for multi-valued headers\n\n      traversed[header.key] = true;\n    });\n\n    // requestV1.headers is a string, so no descriptions can be obtained from it\n    _.forEach(v1Common.parseHeaders(requestV1.headers), function (header) {\n      !traversed[header.key] && headers.push(header);\n    });\n    return headers;\n  },\n  /**\n   * Constructs a V2 Request compatible \"body\" object from a V1 Postman request\n   *\n   * @param {Object} requestV1 - The v1 request to extract the body from.\n   * @returns {{mode: *, content: (*|string)}}\n   */\n  body: function (requestV1) {\n    var modes = {\n        binary: 'file',\n        graphql: 'graphql',\n        params: 'formdata',\n        raw: 'raw',\n        urlencoded: 'urlencoded'\n      },\n      data = {},\n      rawModeData,\n      graphqlModeData,\n      dataMode = modes[requestV1.dataMode],\n      retainEmpty = this.options.retainEmptyValues,\n      bodyOptions = {},\n      mode,\n      // flag indicating that all the props which holds request body data\n      // i.e, data (urlencoded, formdata), rawModeData (raw, file) and graphqlModeData (graphql)\n      // are empty.\n      emptyBody = _.isEmpty(requestV1.data) && _.isEmpty(requestV1.rawModeData) && _.isEmpty(requestV1.graphqlModeData);\n\n    // set body to null if:\n    //   1. emptyBody is true and dataMode is unset\n    //   2. dataMode is explicitly set to null\n    // @note the explicit null check is added to ensure that body is not set\n    // in case the dataMode was set to null by the app.\n    if (!dataMode && emptyBody || requestV1.dataMode === null) {\n      return retainEmpty ? null : undefined;\n    }\n\n    // set `rawModeData` if its a string\n    if (_.isString(requestV1.rawModeData)) {\n      rawModeData = requestV1.rawModeData;\n    }\n    // check if `rawModeData` is an array like: ['rawModeData']\n    else if (Array.isArray(requestV1.rawModeData) && requestV1.rawModeData.length === 1 && _.isString(requestV1.rawModeData[0])) {\n      rawModeData = requestV1.rawModeData[0];\n    }\n\n    // set graphqlModeData if its not empty\n    if (!_.isEmpty(requestV1.graphqlModeData)) {\n      graphqlModeData = requestV1.graphqlModeData;\n    }\n\n    // set data.mode.\n    // if dataMode is not set, infer from data or rawModeData or graphqlModeData\n    if (dataMode) {\n      data.mode = dataMode;\n    }\n    // at this point we are sure that the body is not empty so let's\n    // infer the data mode.\n    // @note its possible that multiple body types are set e.g, both\n    // rawModeData and graphqlModeData are set. So, the priority will be:\n    // raw -> formdata -> graphql (aligned with pre-graphql behaviour).\n    //\n    // set `formdata` if rawModeData is not set and data is an array\n    // `data` takes higher precedence over `rawModeData`.\n    else if (!rawModeData && Array.isArray(requestV1.data || requestV1.rawModeData)) {\n      data.mode = 'formdata';\n    }\n    // set `graphql` if graphqlModeData is set\n    else if (!rawModeData && graphqlModeData) {\n      data.mode = 'graphql';\n    }\n    // set `raw` mode as default\n    else {\n      data.mode = 'raw';\n    }\n    if (data.mode === 'raw') {\n      if (rawModeData) {\n        data[data.mode] = rawModeData;\n      } else if (_.isString(requestV1.data)) {\n        data[data.mode] = requestV1.data;\n      } else {\n        // empty string instead of retainEmpty check to have parity with other modes.\n        data[data.mode] = '';\n      }\n    } else if (data.mode === 'graphql') {\n      data[data.mode] = graphqlModeData;\n    } else if (data.mode === 'file') {\n      // rawModeData can be string or undefined.\n      data[data.mode] = {\n        src: rawModeData\n      };\n    } else {\n      // parse data for formdata or urlencoded data modes.\n      // `rawModeData` is checked in case its of type `data`.\n      data[data.mode] = parseFormData(requestV1.data || requestV1.rawModeData, retainEmpty);\n    }\n    if (requestV1.dataOptions) {\n      // Convert v1 mode to v2 mode\n      for (mode in modes) {\n        if (!_.isEmpty(requestV1.dataOptions[mode])) {\n          bodyOptions[modes[mode]] = requestV1.dataOptions[mode];\n        }\n      }\n      !_.isEmpty(bodyOptions) && (data.options = bodyOptions);\n    }\n    if (requestV1.dataDisabled) {\n      data.disabled = true;\n    } else if (retainEmpty) {\n      data.disabled = false;\n    }\n    return data;\n  },\n  /**\n   * Constructs a V2 \"events\" object from a V1 Postman Request\n   *\n   * @param {Object} entityV1 - The v1 entity to extract script information from.\n   * @returns {Object[]|*}\n   */\n  event: function (entityV1) {\n    if (!entityV1) {\n      return;\n    }\n    const retainIds = this.options.retainIds;\n\n    // if prioritizeV2 is true, events is used as the source of truth\n    if ((util.notLegacy(entityV1, 'event') || this.options.prioritizeV2) && !_.isEmpty(entityV1.events)) {\n      // in v1, `events` is regarded as the source of truth if it exists, so handle that first and bail out.\n      // @todo: Improve this to order prerequest events before test events\n      _.forEach(entityV1.events, function (event) {\n        !event.listen && (event.listen = 'test');\n\n        // just delete the event.id if retainIds is not set\n        if (!retainIds && event.id) {\n          delete event.id;\n        }\n        if (event.script) {\n          // just delete the script.id if retainIds is not set\n          if (!retainIds && event.script.id) {\n            delete event.script.id;\n          }\n          !event.script.type && (event.script.type = 'text/javascript');\n\n          // @todo: Add support for src\n          _.isString(event.script.exec) && (event.script.exec = event.script.exec.split('\\n'));\n        }\n      });\n      return entityV1.events;\n    }\n    var events = [];\n\n    // @todo: Extract both flows below into a common method\n    if (entityV1.tests) {\n      events.push({\n        listen: 'test',\n        script: {\n          type: 'text/javascript',\n          exec: _.isString(entityV1.tests) ? entityV1.tests.split('\\n') : entityV1.tests\n        }\n      });\n    }\n    if (entityV1.preRequestScript) {\n      events.push({\n        listen: 'prerequest',\n        script: {\n          type: 'text/javascript',\n          exec: _.isString(entityV1.preRequestScript) ? entityV1.preRequestScript.split('\\n') : entityV1.preRequestScript\n        }\n      });\n    }\n    return events.length ? events : undefined;\n  },\n  /**\n   * A number of auth parameter names have changed from V1 to V2. This function calls the appropriate\n   * mapper function, and creates the V2 auth parameter object.\n   *\n   * @param {Object} entityV1 - The v1 entity to derive auth information from.\n   * @param {?Object} options - The set of options for the current auth cleansing operation.\n   * @param {?Boolean} [options.includeNoauth=false] - When set to true, noauth is set to null.\n   * @returns {{type: *}}\n   */\n  auth: function (entityV1, options) {\n    if (!entityV1) {\n      return;\n    }\n    if ((util.notLegacy(entityV1, 'auth') || this.options.prioritizeV2) && entityV1.auth) {\n      return util.authArrayToMap(entityV1, options);\n    }\n    if (!entityV1.currentHelper || entityV1.currentHelper === null || entityV1.currentHelper === 'normal') {\n      return;\n    }\n    var params,\n      type = v1Common.authMap[entityV1.currentHelper] || entityV1.currentHelper,\n      auth = {\n        type: type\n      };\n\n    // Some legacy versions of the App export Helper Attributes as a string.\n    if (_.isString(entityV1.helperAttributes)) {\n      try {\n        entityV1.helperAttributes = JSON.parse(entityV1.helperAttributes);\n      } catch (e) {\n        return;\n      }\n    }\n    if (entityV1.helperAttributes && util.authMappersFromLegacy[entityV1.currentHelper]) {\n      params = util.authMappersFromLegacy[entityV1.currentHelper](entityV1.helperAttributes);\n    }\n    params && (auth[type] = params);\n    return auth;\n  },\n  /**\n   * Creates a V2 format request from a V1 Postman Collection Request\n   *\n   * @param {Object} requestV1 - The v1 request to be transformed.\n   * @returns {Object} - The converted v2 request.\n   */\n  request: function (requestV1) {\n    var self = this,\n      request = {},\n      retainEmpty = self.options.retainEmptyValues,\n      units = ['auth', 'method', 'header', 'body', 'url'];\n    units.forEach(function (unit) {\n      request[unit] = self[unit](requestV1);\n    });\n    if (requestV1.description) {\n      request.description = requestV1.description;\n    } else if (retainEmpty) {\n      request.description = null;\n    }\n    return request;\n  },\n  /**\n   * Converts a V1 cookie to a V2 cookie.\n   *\n   * @param {Object} cookieV1 - The v1 cookie object to convert.\n   * @returns {{expires: string, hostOnly: *, httpOnly: *, domain: *, path: *, secure: *, session: *, value: *}}\n   */\n  cookie: function (cookieV1) {\n    return {\n      expires: new Date(cookieV1.expirationDate * 1000).toString(),\n      hostOnly: cookieV1.hostOnly,\n      httpOnly: cookieV1.httpOnly,\n      domain: cookieV1.domain,\n      path: cookieV1.path,\n      secure: cookieV1.secure,\n      session: cookieV1.session,\n      value: cookieV1.value,\n      key: cookieV1.name\n    };\n  },\n  /**\n   * Gets the saved request for the given response, and handles edge cases between Apps & Sync\n   *\n   * Handles a lot of edge cases, so the code is not very clean.\n   *\n   * The Flow followed here is:\n   *\n   * If responseV1.requestObject is present\n   *      If it is a string\n   *          Try parsing it as JSON\n   *              If parsed,\n   *                  return it\n   *              else\n   *                  It is a request ID\n   * If responseV1.request is present\n   *      If it is a string\n   *          Try parsing it as JSON\n   *              If parsed,\n   *                  return it\n   *              else\n   *                  It is a request ID\n   * Look up the collection for the request ID and return it, or return undefined.\n   *\n   * @param {Object} responseV1 - The v1 response to be converted.\n   * @returns {Object} - The converted saved request, in v2 format.\n   */\n  savedRequest: function (responseV1) {\n    var self = this,\n      associatedRequestId;\n    if (responseV1.requestObject) {\n      if (_.isString(responseV1.requestObject)) {\n        try {\n          return JSON.parse(responseV1.requestObject);\n        } catch (e) {\n          // if there was an error parsing it as JSON, it's probably an ID, so store it in the ID variable\n          associatedRequestId = responseV1.requestObject;\n        }\n      } else {\n        return responseV1.requestObject;\n      }\n    }\n    if (responseV1.request) {\n      if (_.isString(responseV1.request)) {\n        try {\n          return JSON.parse(responseV1.request);\n        } catch (e) {\n          // if there was an error parsing it as JSON, it's probably an ID, so store it in the ID variable\n          associatedRequestId = responseV1.request;\n        }\n      } else {\n        return responseV1.request;\n      }\n    }\n\n    // we have a request ID\n    return associatedRequestId && _.get(self, ['cache', associatedRequestId]);\n  },\n  /**\n   * Since a V2 response contains the entire associated request that was sent, creating the response means it\n   * also must use the V1 request.\n   *\n   * @param {Object} responseV1 - The response object to convert from v1 to v2.\n   * @returns {Object} - The v2 response object.\n   */\n  singleResponse: function (responseV1) {\n    var response = {},\n      self = this,\n      originalRequest;\n    originalRequest = self.savedRequest(responseV1);\n\n    // add ids to the v2 result only if both: the id and retainIds are truthy.\n    // this prevents successive exports to v2 from being overwhelmed by id diffs\n    self.options.retainIds && (response.id = responseV1.id || util.uid());\n    response.name = responseV1.name || 'response';\n    response.originalRequest = originalRequest ? self.request(originalRequest) : undefined;\n    response.status = responseV1.responseCode && responseV1.responseCode.name || undefined;\n    response.code = responseV1.responseCode && Number(responseV1.responseCode.code) || undefined;\n    response._postman_previewlanguage = responseV1.language;\n    response._postman_previewtype = responseV1.previewType;\n    response.header = responseV1.headers;\n    response.cookie = _.map(responseV1.cookies, function (cookie) {\n      return self.cookie(cookie);\n    });\n    response.responseTime = responseV1.time;\n    response.body = responseV1.text;\n    return response;\n  },\n  /**\n   * Constructs an array of \"sample\" responses (compatible with a V2 collection)\n   * from a Postman Collection V1 Request.\n   *\n   * If response ordering via `responses_order` field is present,\n   * ensure the ordering is respected while constructing responses array.\n   *\n   * @param {Object} requestV1 - The v1 request object to extract response information from.\n   * @returns {Object[]} - The list of v2 response definitions.\n   */\n  response: function (requestV1) {\n    var self = this,\n      responses = _.get(requestV1, 'responses', []),\n      responsesCache = _.keyBy(responses, 'id'),\n      responses_order = _.get(requestV1, 'responses_order', []);\n\n    // If ordering of responses is not available\n    // Create a default ordering using the `responses` field\n    if (!(responses_order && responses_order.length)) {\n      responses_order = _.map(responses, 'id');\n    }\n\n    // Filter out any response id that is not available\n    responses_order = _.filter(responses_order, function (responseId) {\n      return _.has(responsesCache, responseId);\n    });\n    return _.map(responses_order, function (responseId) {\n      return self.singleResponse(responsesCache[responseId]);\n    });\n  },\n  /**\n   * Creates a V2 compatible ``item`` from a V1 Postman Collection Request\n   *\n   * @param {Object} requestV1 - Postman collection V1 request.\n   * @returns {Object} - The converted request object, in v2 format.\n   */\n  singleItem: function (requestV1) {\n    if (!requestV1) {\n      return;\n    }\n    var self = this,\n      retainIds = self.options.retainIds,\n      units = ['request', 'response'],\n      variable = self.variable(requestV1, {\n        retainIds: retainIds\n      }),\n      item = {\n        name: requestV1.name || '',\n        // Inline building to avoid additional function call\n        event: self.event(requestV1)\n      };\n    retainIds && (item.id = requestV1.id || util.uid());\n    // add protocolProfileBehavior property from requestV1 to the item\n    util.addProtocolProfileBehavior(requestV1, item);\n    units.forEach(function (unit) {\n      item[unit] = self[unit](requestV1);\n    });\n    variable && variable.length && (item.variable = variable);\n    return item;\n  },\n  /**\n   * Constructs an array of Items & ItemGroups compatible with the V2 format.\n   *\n   * @param {Object} collectionV1 - The v1 collection to derive folder information from.\n   * @returns {Object[]} - The list of item group definitions.\n   */\n  itemGroups: function (collectionV1) {\n    var self = this,\n      items = [],\n      itemGroupCache = {},\n      retainEmpty = self.options.retainEmptyValues;\n\n    // Read all folder data, and prep it so that we can throw subfolders in the right places\n    itemGroupCache = _.reduce(collectionV1.folders, function (accumulator, folder) {\n      if (!folder) {\n        return accumulator;\n      }\n      var retainIds = self.options.retainIds,\n        auth = self.auth(folder),\n        event = self.event(folder),\n        variable = self.variable(folder, {\n          retainIds: retainIds\n        }),\n        result = {\n          name: folder.name,\n          item: []\n        };\n      retainIds && (result.id = folder.id || util.uid());\n      if (folder.description) {\n        result.description = folder.description;\n      } else if (retainEmpty) {\n        result.description = null;\n      }\n      (auth || auth === null) && (result.auth = auth);\n      event && (result.event = event);\n      variable && variable.length && (result.variable = variable);\n      util.addProtocolProfileBehavior(folder, result);\n      accumulator[folder.id] = result;\n      return accumulator;\n    }, {});\n\n    // Populate each ItemGroup with subfolders\n    _.forEach(collectionV1.folders, function (folderV1) {\n      if (!folderV1) {\n        return;\n      }\n      var itemGroup = itemGroupCache[folderV1.id],\n        hasSubfolders = folderV1.folders_order && folderV1.folders_order.length,\n        hasRequests = folderV1.order && folderV1.order.length;\n\n      // Add subfolders\n      hasSubfolders && _.forEach(folderV1.folders_order, function (subFolderId) {\n        if (!itemGroupCache[subFolderId]) {\n          // todo: figure out what to do when a collection contains a subfolder ID,\n          // but the subfolder is not actually there.\n          return;\n        }\n        itemGroupCache[subFolderId][IS_SUBFOLDER] = true;\n        itemGroup.item.push(itemGroupCache[subFolderId]);\n      });\n\n      // Add items\n      hasRequests && _.forEach(folderV1.order, function (requestId) {\n        if (!self.cache[requestId]) {\n          // todo: what do we do here??\n          return;\n        }\n        itemGroup.item.push(self.singleItem(self.cache[requestId]));\n      });\n    });\n\n    // This compromises some self-healing, which was originally present, but the performance cost of\n    // doing self-healing the right way is high, so we directly rely on collectionV1.folders_order\n    // The self-healing way would be to iterate over itemGroupCache directly, but preserving the right order\n    // becomes a pain in that case.\n    _.forEach(_.uniq(collectionV1.folders_order || _.map(collectionV1.folders, 'id')), function (folderId) {\n      var itemGroup = itemGroupCache[folderId];\n      itemGroup && !_.get(itemGroup, IS_SUBFOLDER) && items.push(itemGroup);\n    });\n\n    // This is useful later\n    self.itemGroupCache = itemGroupCache;\n    return _.compact(items);\n  },\n  /**\n   * Creates a V2 compatible array of items from a V1 Postman Collection\n   *\n   * @param {Object} collectionV1 - A Postman Collection object in the V1 format.\n   * @returns {Object[]} - The list of item groups (folders) in v2 format.\n   */\n  item: function (collectionV1) {\n    var self = this,\n      requestsCache = _.keyBy(collectionV1.requests, 'id'),\n      allRequests = _.map(collectionV1.requests, 'id'),\n      result;\n    self.cache = requestsCache;\n    result = self.itemGroups(collectionV1);\n    _.forEach(_.intersection(collectionV1.order, allRequests), function (requestId) {\n      var request = self.singleItem(requestsCache[requestId]);\n      request && result.push(request);\n    });\n    return result;\n  }\n});\nmodule.exports = {\n  input: '1.0.0',\n  output: '2.0.0',\n  Builders: Builders,\n  /**\n   * Converts a single V1 request to a V2 item.\n   *\n   * @param {Object} request - The v1 request to convert to v2.\n   * @param {Object} options - The set of options for v1 -> v2 conversion.\n   * @param {Function} callback - The function to be invoked when the conversion has completed.\n   */\n  convertSingle: function (request, options, callback) {\n    var builders = new Builders(options),\n      converted,\n      err;\n    try {\n      converted = builders.singleItem(_.cloneDeep(request));\n    } catch (e) {\n      err = e;\n    }\n    if (callback) {\n      return callback(err, converted);\n    }\n    if (err) {\n      throw err;\n    }\n    return converted;\n  },\n  /**\n   * Converts a single V1 Response to a V2 Response.\n   *\n   * @param {Object} response - The v1 response to convert to v2.\n   * @param {Object} options - The set of options for v1 -> v2 conversion.\n   * @param {Function} callback - The function to be invoked when the conversion has completed.\n   */\n  convertResponse: function (response, options, callback) {\n    var builders = new Builders(options),\n      converted,\n      err;\n    try {\n      converted = builders.singleResponse(_.cloneDeep(response));\n    } catch (e) {\n      err = e;\n    }\n    if (callback) {\n      return callback(err, converted);\n    }\n    if (err) {\n      throw err;\n    }\n    return converted;\n  },\n  /**\n   * Converts a V1 collection to a V2 collection (performs ID replacement, etc as necessary).\n   *\n   * @param {Object} collection - The v1 collection to convert to v2.\n   * @param {Object} options - The set of options for v1 -> v2 conversion.\n   * @param {Function} callback - The function to be invoked when the conversion has completed.\n   */\n  convert: function (collection, options, callback) {\n    collection = _.cloneDeep(collection);\n    var auth,\n      event,\n      variable,\n      newCollection = {},\n      units = ['info', 'item'],\n      builders = new Builders(options),\n      authOptions = {\n        excludeNoauth: true\n      },\n      varOpts = options && {\n        fallback: options.env,\n        retainIds: options.retainIds\n      };\n    try {\n      units.forEach(function (unit) {\n        newCollection[unit] = builders[unit](collection);\n      });\n      (auth = builders.auth(collection, authOptions)) && (newCollection.auth = auth);\n      (event = builders.event(collection)) && (newCollection.event = event);\n      (variable = builders.variable(collection, varOpts)) && (newCollection.variable = variable);\n      util.addProtocolProfileBehavior(collection, newCollection);\n    } catch (e) {\n      if (callback) {\n        return callback(e, null);\n      }\n      throw e;\n    }\n    if (callback) {\n      return callback(null, newCollection);\n    }\n    return newCollection;\n  }\n};","map":{"version":3,"names":["_","require","noConflict","constants","v1Common","util","headersCommentPrefix","IS_SUBFOLDER","Symbol","Builders","options","parseFormData","data","retainEmpty","Array","isArray","length","formdata","i","ii","param","Object","assign","isNil","key","type","src","value","isString","prototype","hasOwnProperty","call","enabled","disabled","cleanEmptyValue","push","info","collectionV1","_postman_id","id","uid","name","description","retainEmptyValues","schema","SCHEMA_V2_URL","variable","entity","handleVars","url","requestV1","queryParams","pathVariables","traversedVars","queryParamAltered","retainIds","parsed","urlparse","forEach","queryParam","has","equals","size","query","pathVariableData","pathVariable","clone","isEmpty","raw","urlunparse","undefined","String","method","header","headers","traversed","headerData","startsWith","replace","trim","parseHeaders","body","modes","binary","graphql","params","urlencoded","rawModeData","graphqlModeData","dataMode","bodyOptions","mode","emptyBody","dataOptions","dataDisabled","event","entityV1","notLegacy","prioritizeV2","events","listen","script","exec","split","tests","preRequestScript","auth","authArrayToMap","currentHelper","authMap","helperAttributes","JSON","parse","e","authMappersFromLegacy","request","self","units","unit","cookie","cookieV1","expires","Date","expirationDate","toString","hostOnly","httpOnly","domain","path","secure","session","savedRequest","responseV1","associatedRequestId","requestObject","get","singleResponse","response","originalRequest","status","responseCode","code","Number","_postman_previewlanguage","language","_postman_previewtype","previewType","map","cookies","responseTime","time","text","responses","responsesCache","keyBy","responses_order","filter","responseId","singleItem","item","addProtocolProfileBehavior","itemGroups","items","itemGroupCache","reduce","folders","accumulator","folder","result","folderV1","itemGroup","hasSubfolders","folders_order","hasRequests","order","subFolderId","requestId","cache","uniq","folderId","compact","requestsCache","requests","allRequests","intersection","module","exports","input","output","convertSingle","callback","builders","converted","err","cloneDeep","convertResponse","convert","collection","newCollection","authOptions","excludeNoauth","varOpts","fallback","env"],"sources":["/Users/Qusai.Qishta/node_modules/postman-collection-transformer/lib/converters/v1.0.0/converter-v1-to-v2.js"],"sourcesContent":["/* eslint-disable object-shorthand */\nvar _ = require('lodash').noConflict(),\n    constants = require('../../constants'),\n    v1Common = require('../../common/v1'),\n    util = require('../../util'),\n\n    headersCommentPrefix = '//',\n    IS_SUBFOLDER = Symbol('_postman_isSubFolder'),\n\n    /**\n     * A constructor that is capable of being used for one-off conversions of requests, and folders.\n     *\n     * @param {Object} options - The set of options for builder construction.\n     * @class Builders\n     * @constructor\n     */\n    Builders = function (options) {\n        this.options = options || {};\n    },\n\n    /**\n     * Parse formdata & urlencoded request data.\n     *   - filter params missing property `key`\n     *   - handle file type param value\n     *   -cleanup `enabled` & `description`\n     *\n     * @param {Object[]} data - Data to parse.\n     * @param {?Boolean} [retainEmpty] - To retain empty values or not.\n     * @returns {Object[]} - Parsed data.\n     */\n    parseFormData = function (data, retainEmpty) {\n        if (!(Array.isArray(data) && data.length)) { return []; }\n\n        var formdata = [],\n            i,\n            ii,\n            param;\n\n        for (i = 0, ii = data.length; i < ii; i++) {\n            // clone param to avoid mutating data.\n            // eslint-disable-next-line prefer-object-spread\n            param = Object.assign({}, data[i]);\n\n            // skip if param is missing property `key`,\n            // `key` is a required property, value can be null/undefined.\n            // because in a FormParam property lists, key is used for indexing.\n            if (_.isNil(param.key)) {\n                continue;\n            }\n\n            // for file `type`, set `value` to `src`\n            if (param.type === 'file' && !param.src && param.value) {\n                param.src = (_.isString(param.value) || _.isArray(param.value)) ? param.value : null;\n                delete param.value;\n            }\n\n            // `hasOwnProperty` check ensures that it don't delete undefined property: `enabled`\n            if (Object.prototype.hasOwnProperty.call(param, 'enabled')) {\n                // set `disabled` flag if `enabled` is false.\n                param.enabled === false && (param.disabled = true);\n\n                delete param.enabled; // cleanup\n            }\n\n            // Prevent empty descriptions from showing up in the converted results. This keeps collections clean.\n            util.cleanEmptyValue(param, 'description', retainEmpty);\n\n            formdata.push(param);\n        }\n\n        return formdata;\n    };\n\n_.assign(Builders.prototype, {\n\n    /**\n     * Constructs a V2 compatible \"info\" object from a V1 Postman Collection\n     *\n     * @param {Object} collectionV1 - A v1 collection to derive collection metadata from.\n     * @returns {Object} - The resultant v2 info object.\n     */\n    info: function (collectionV1) {\n        var info = {\n            _postman_id: collectionV1.id || util.uid(),\n            name: collectionV1.name\n        };\n\n        if (collectionV1.description) { info.description = collectionV1.description; }\n        else if (this.options.retainEmptyValues) { info.description = null; }\n\n        info.schema = constants.SCHEMA_V2_URL;\n\n        return info;\n    },\n\n    /**\n     * Facilitates sanitized variable transformations across all levels for v1 collection normalization.\n     *\n     * @param {Object} entity - The wrapper object containing variable definitions.\n     * @param {?Object} options - The set of options for the current variable transformation.\n     * @param {?Object} options.fallback - The set of fallback values to be applied when no variables exist.\n     * @param {?Boolean} options.noDefaults - When set to true, no defaults are applied.\n     * @param {?Boolean} options.retainIds - When set to true, ids are left as is.\n     * @returns {Object[]} - The set of sanitized variables.\n     */\n    variable: function (entity, options) {\n        return util.handleVars(entity, options);\n    },\n\n    /**\n     * Constructs a V2 compatible URL object from a V1 request\n     *\n     * @param {Object} requestV1 - The source v1 request to extract the URL from.\n     * @returns {String|Object} - The resultant URL.\n     */\n    url: function (requestV1) {\n        var queryParams = [],\n            pathVariables = [],\n            traversedVars = {},\n            queryParamAltered,\n            retainIds = this.options.retainIds,\n            parsed = util.urlparse(requestV1.url),\n            retainEmpty = this.options.retainEmptyValues;\n\n        // add query params\n        _.forEach(requestV1.queryParams, function (queryParam) {\n            (queryParam.enabled === false) && (queryParam.disabled = true);\n\n            delete queryParam.enabled;\n\n            util.cleanEmptyValue(queryParam, 'description', retainEmpty);\n\n            if (_.has(queryParam, 'equals')) {\n                if (queryParam.equals) {\n                    (queryParam.value === null) && (queryParam.value = '');\n                }\n                else {\n                    // = is not appended when the value is null. However,\n                    // non empty value should be preserved\n                    queryParam.value = queryParam.value || null;\n                }\n\n                queryParamAltered = true;\n                delete queryParam.equals;\n            }\n            queryParams.push(queryParam);\n        });\n\n        // only add query params from URL if not given explicitly\n        if (!_.size(queryParams)) {\n            // parsed query params are taken from the url, so no descriptions are available from them\n            queryParams = parsed.query;\n        }\n\n        // Merge path variables\n        _.forEach(requestV1.pathVariableData, function (pathVariable) {\n            pathVariable = _.clone(pathVariable);\n            util.cleanEmptyValue(pathVariable, 'description', retainEmpty);\n\n            if (!retainIds && pathVariable.id) {\n                delete pathVariable.id;\n            }\n\n            pathVariables.push(pathVariable);\n            traversedVars[pathVariable.key] = true;\n        });\n        // pathVariables in v1 are of the form  {foo: bar}, so no descriptions can be obtained from them\n        _.forEach(requestV1.pathVariables, function (value, key) {\n            !traversedVars[key] && pathVariables.push({\n                value: value,\n                key: key\n            });\n        });\n\n        !_.isEmpty(queryParams) && (parsed.query = queryParams);\n        !_.isEmpty(pathVariables) && (parsed.variable = pathVariables);\n\n        // If the query params have been altered, update the raw stringified URL\n        queryParamAltered && (parsed.raw = util.urlunparse(parsed));\n\n        // return the objectified URL only if query param or path variable descriptions are present, string otherwise\n        return (parsed.query || parsed.variable) ?\n            parsed : (\n                parsed.raw || (\n                    // avoid unnecessary empty string for null or undefined input\n                    _.isNil(requestV1.url) ? undefined : String(requestV1.url)\n                )\n            );\n    },\n\n    /**\n     * Extracts the HTTP Method from a V1 request\n     *\n     * @param {Object} requestV1 - The v1 request to extract the request method from.\n     * @returns {String} - The extracted request method.\n     */\n    method: function (requestV1) {\n        return requestV1.method;\n    },\n\n    /**\n     * Constructs an array of Key-Values from a raw HTTP Header string.\n     *\n     * @param {Object} requestV1 - The v1 request to extract header information from.\n     * @returns {Object[]} - A list of header definition objects.\n     */\n    header: function (requestV1) {\n        if (_.isArray(requestV1.headers)) {\n            return requestV1.headers;\n        }\n\n        var headers = [],\n            traversed = {},\n            headerData = requestV1.headerData || [],\n            retainEmpty = this.options.retainEmptyValues;\n\n        _.forEach(headerData, function (header) {\n            if (_.startsWith(header.key, headersCommentPrefix) || (header.enabled === false)) {\n                header.disabled = true;\n                header.key = header.key.replace(headersCommentPrefix, '').trim();\n            }\n\n            // prevent empty header descriptions from showing up in converted results. This keeps the collections clean\n            util.cleanEmptyValue(header, 'description', retainEmpty);\n\n            delete header.enabled;\n            headers.push(header); // @todo Improve this sequence to account for multi-valued headers\n\n            traversed[header.key] = true;\n        });\n\n        // requestV1.headers is a string, so no descriptions can be obtained from it\n        _.forEach(v1Common.parseHeaders(requestV1.headers), function (header) {\n            !traversed[header.key] && headers.push(header);\n        });\n\n        return headers;\n    },\n\n    /**\n     * Constructs a V2 Request compatible \"body\" object from a V1 Postman request\n     *\n     * @param {Object} requestV1 - The v1 request to extract the body from.\n     * @returns {{mode: *, content: (*|string)}}\n     */\n    body: function (requestV1) {\n        var modes = {\n                binary: 'file',\n                graphql: 'graphql',\n                params: 'formdata',\n                raw: 'raw',\n                urlencoded: 'urlencoded'\n            },\n            data = {},\n            rawModeData,\n            graphqlModeData,\n            dataMode = modes[requestV1.dataMode],\n            retainEmpty = this.options.retainEmptyValues,\n            bodyOptions = {},\n            mode,\n            // flag indicating that all the props which holds request body data\n            // i.e, data (urlencoded, formdata), rawModeData (raw, file) and graphqlModeData (graphql)\n            // are empty.\n            emptyBody = _.isEmpty(requestV1.data) && _.isEmpty(requestV1.rawModeData) &&\n                _.isEmpty(requestV1.graphqlModeData);\n\n        // set body to null if:\n        //   1. emptyBody is true and dataMode is unset\n        //   2. dataMode is explicitly set to null\n        // @note the explicit null check is added to ensure that body is not set\n        // in case the dataMode was set to null by the app.\n        if ((!dataMode && emptyBody) || requestV1.dataMode === null) {\n            return retainEmpty ? null : undefined;\n        }\n\n        // set `rawModeData` if its a string\n        if (_.isString(requestV1.rawModeData)) {\n            rawModeData = requestV1.rawModeData;\n        }\n        // check if `rawModeData` is an array like: ['rawModeData']\n        else if (Array.isArray(requestV1.rawModeData) &&\n            requestV1.rawModeData.length === 1 &&\n            _.isString(requestV1.rawModeData[0])) {\n            rawModeData = requestV1.rawModeData[0];\n        }\n\n        // set graphqlModeData if its not empty\n        if (!_.isEmpty(requestV1.graphqlModeData)) {\n            graphqlModeData = requestV1.graphqlModeData;\n        }\n\n        // set data.mode.\n        // if dataMode is not set, infer from data or rawModeData or graphqlModeData\n        if (dataMode) {\n            data.mode = dataMode;\n        }\n        // at this point we are sure that the body is not empty so let's\n        // infer the data mode.\n        // @note its possible that multiple body types are set e.g, both\n        // rawModeData and graphqlModeData are set. So, the priority will be:\n        // raw -> formdata -> graphql (aligned with pre-graphql behaviour).\n        //\n        // set `formdata` if rawModeData is not set and data is an array\n        // `data` takes higher precedence over `rawModeData`.\n        else if (!rawModeData && Array.isArray(requestV1.data || requestV1.rawModeData)) {\n            data.mode = 'formdata';\n        }\n        // set `graphql` if graphqlModeData is set\n        else if (!rawModeData && graphqlModeData) {\n            data.mode = 'graphql';\n        }\n        // set `raw` mode as default\n        else {\n            data.mode = 'raw';\n        }\n\n        if (data.mode === 'raw') {\n            if (rawModeData) {\n                data[data.mode] = rawModeData;\n            }\n            else if (_.isString(requestV1.data)) {\n                data[data.mode] = requestV1.data;\n            }\n            else {\n                // empty string instead of retainEmpty check to have parity with other modes.\n                data[data.mode] = '';\n            }\n        }\n        else if (data.mode === 'graphql') {\n            data[data.mode] = graphqlModeData;\n        }\n        else if (data.mode === 'file') {\n            // rawModeData can be string or undefined.\n            data[data.mode] = { src: rawModeData };\n        }\n        else {\n            // parse data for formdata or urlencoded data modes.\n            // `rawModeData` is checked in case its of type `data`.\n            data[data.mode] = parseFormData(requestV1.data || requestV1.rawModeData, retainEmpty);\n        }\n\n        if (requestV1.dataOptions) {\n            // Convert v1 mode to v2 mode\n            for (mode in modes) {\n                if (!_.isEmpty(requestV1.dataOptions[mode])) {\n                    bodyOptions[modes[mode]] = requestV1.dataOptions[mode];\n                }\n            }\n\n            !_.isEmpty(bodyOptions) && (data.options = bodyOptions);\n        }\n\n        if (requestV1.dataDisabled) { data.disabled = true; }\n        else if (retainEmpty) { data.disabled = false; }\n\n        return data;\n    },\n\n    /**\n     * Constructs a V2 \"events\" object from a V1 Postman Request\n     *\n     * @param {Object} entityV1 - The v1 entity to extract script information from.\n     * @returns {Object[]|*}\n     */\n    event: function (entityV1) {\n        if (!entityV1) { return; }\n\n        const retainIds = this.options.retainIds;\n\n        // if prioritizeV2 is true, events is used as the source of truth\n        if ((util.notLegacy(entityV1, 'event') || this.options.prioritizeV2) && !_.isEmpty(entityV1.events)) {\n            // in v1, `events` is regarded as the source of truth if it exists, so handle that first and bail out.\n            // @todo: Improve this to order prerequest events before test events\n            _.forEach(entityV1.events, function (event) {\n                !event.listen && (event.listen = 'test');\n\n                // just delete the event.id if retainIds is not set\n                if (!retainIds && event.id) {\n                    delete event.id;\n                }\n\n                if (event.script) {\n                    // just delete the script.id if retainIds is not set\n                    if (!retainIds && event.script.id) {\n                        delete event.script.id;\n                    }\n\n                    !event.script.type && (event.script.type = 'text/javascript');\n\n                    // @todo: Add support for src\n                    _.isString(event.script.exec) && (event.script.exec = event.script.exec.split('\\n'));\n                }\n            });\n\n            return entityV1.events;\n        }\n\n        var events = [];\n\n        // @todo: Extract both flows below into a common method\n        if (entityV1.tests) {\n            events.push({\n                listen: 'test',\n                script: {\n                    type: 'text/javascript',\n                    exec: _.isString(entityV1.tests) ?\n                        entityV1.tests.split('\\n') :\n                        entityV1.tests\n                }\n            });\n        }\n        if (entityV1.preRequestScript) {\n            events.push({\n                listen: 'prerequest',\n                script: {\n                    type: 'text/javascript',\n                    exec: _.isString(entityV1.preRequestScript) ?\n                        entityV1.preRequestScript.split('\\n') :\n                        entityV1.preRequestScript\n                }\n            });\n        }\n\n        return events.length ? events : undefined;\n    },\n\n    /**\n     * A number of auth parameter names have changed from V1 to V2. This function calls the appropriate\n     * mapper function, and creates the V2 auth parameter object.\n     *\n     * @param {Object} entityV1 - The v1 entity to derive auth information from.\n     * @param {?Object} options - The set of options for the current auth cleansing operation.\n     * @param {?Boolean} [options.includeNoauth=false] - When set to true, noauth is set to null.\n     * @returns {{type: *}}\n     */\n    auth: function (entityV1, options) {\n        if (!entityV1) { return; }\n        if ((util.notLegacy(entityV1, 'auth') || this.options.prioritizeV2) && entityV1.auth) {\n            return util.authArrayToMap(entityV1, options);\n        }\n        if (!entityV1.currentHelper || (entityV1.currentHelper === null) || (entityV1.currentHelper === 'normal')) {\n            return;\n        }\n\n        var params,\n            type = v1Common.authMap[entityV1.currentHelper] || entityV1.currentHelper,\n            auth = {\n                type: type\n            };\n\n        // Some legacy versions of the App export Helper Attributes as a string.\n        if (_.isString(entityV1.helperAttributes)) {\n            try {\n                entityV1.helperAttributes = JSON.parse(entityV1.helperAttributes);\n            }\n            catch (e) {\n                return;\n            }\n        }\n\n        if (entityV1.helperAttributes && util.authMappersFromLegacy[entityV1.currentHelper]) {\n            params = util.authMappersFromLegacy[entityV1.currentHelper](entityV1.helperAttributes);\n        }\n\n        params && (auth[type] = params);\n\n        return auth;\n    },\n\n    /**\n     * Creates a V2 format request from a V1 Postman Collection Request\n     *\n     * @param {Object} requestV1 - The v1 request to be transformed.\n     * @returns {Object} - The converted v2 request.\n     */\n    request: function (requestV1) {\n        var self = this,\n            request = {},\n            retainEmpty = self.options.retainEmptyValues,\n            units = ['auth', 'method', 'header', 'body', 'url'];\n\n        units.forEach(function (unit) {\n            request[unit] = self[unit](requestV1);\n        });\n\n        if (requestV1.description) { request.description = requestV1.description; }\n        else if (retainEmpty) { request.description = null; }\n\n        return request;\n    },\n\n    /**\n     * Converts a V1 cookie to a V2 cookie.\n     *\n     * @param {Object} cookieV1 - The v1 cookie object to convert.\n     * @returns {{expires: string, hostOnly: *, httpOnly: *, domain: *, path: *, secure: *, session: *, value: *}}\n     */\n    cookie: function (cookieV1) {\n        return {\n            expires: (new Date(cookieV1.expirationDate * 1000)).toString(),\n            hostOnly: cookieV1.hostOnly,\n            httpOnly: cookieV1.httpOnly,\n            domain: cookieV1.domain,\n            path: cookieV1.path,\n            secure: cookieV1.secure,\n            session: cookieV1.session,\n            value: cookieV1.value,\n            key: cookieV1.name\n        };\n    },\n\n    /**\n     * Gets the saved request for the given response, and handles edge cases between Apps & Sync\n     *\n     * Handles a lot of edge cases, so the code is not very clean.\n     *\n     * The Flow followed here is:\n     *\n     * If responseV1.requestObject is present\n     *      If it is a string\n     *          Try parsing it as JSON\n     *              If parsed,\n     *                  return it\n     *              else\n     *                  It is a request ID\n     * If responseV1.request is present\n     *      If it is a string\n     *          Try parsing it as JSON\n     *              If parsed,\n     *                  return it\n     *              else\n     *                  It is a request ID\n     * Look up the collection for the request ID and return it, or return undefined.\n     *\n     * @param {Object} responseV1 - The v1 response to be converted.\n     * @returns {Object} - The converted saved request, in v2 format.\n     */\n    savedRequest: function (responseV1) {\n        var self = this,\n            associatedRequestId;\n\n        if (responseV1.requestObject) {\n            if (_.isString(responseV1.requestObject)) {\n                try {\n                    return JSON.parse(responseV1.requestObject);\n                }\n                catch (e) {\n                    // if there was an error parsing it as JSON, it's probably an ID, so store it in the ID variable\n                    associatedRequestId = responseV1.requestObject;\n                }\n            }\n            else {\n                return responseV1.requestObject;\n            }\n        }\n\n        if (responseV1.request) {\n            if (_.isString(responseV1.request)) {\n                try {\n                    return JSON.parse(responseV1.request);\n                }\n                catch (e) {\n                    // if there was an error parsing it as JSON, it's probably an ID, so store it in the ID variable\n                    associatedRequestId = responseV1.request;\n                }\n            }\n            else {\n                return responseV1.request;\n            }\n        }\n\n        // we have a request ID\n        return associatedRequestId && _.get(self, ['cache', associatedRequestId]);\n    },\n\n    /**\n     * Since a V2 response contains the entire associated request that was sent, creating the response means it\n     * also must use the V1 request.\n     *\n     * @param {Object} responseV1 - The response object to convert from v1 to v2.\n     * @returns {Object} - The v2 response object.\n     */\n    singleResponse: function (responseV1) {\n        var response = {},\n            self = this,\n            originalRequest;\n\n        originalRequest = self.savedRequest(responseV1);\n\n        // add ids to the v2 result only if both: the id and retainIds are truthy.\n        // this prevents successive exports to v2 from being overwhelmed by id diffs\n        self.options.retainIds && (response.id = responseV1.id || util.uid());\n\n        response.name = responseV1.name || 'response';\n        response.originalRequest = originalRequest ? self.request(originalRequest) : undefined;\n        response.status = responseV1.responseCode && responseV1.responseCode.name || undefined;\n        response.code = responseV1.responseCode && Number(responseV1.responseCode.code) || undefined;\n        response._postman_previewlanguage = responseV1.language;\n        response._postman_previewtype = responseV1.previewType;\n        response.header = responseV1.headers;\n        response.cookie = _.map(responseV1.cookies, function (cookie) {\n            return self.cookie(cookie);\n        });\n        response.responseTime = responseV1.time;\n        response.body = responseV1.text;\n\n        return response;\n    },\n\n    /**\n     * Constructs an array of \"sample\" responses (compatible with a V2 collection)\n     * from a Postman Collection V1 Request.\n     *\n     * If response ordering via `responses_order` field is present,\n     * ensure the ordering is respected while constructing responses array.\n     *\n     * @param {Object} requestV1 - The v1 request object to extract response information from.\n     * @returns {Object[]} - The list of v2 response definitions.\n     */\n    response: function (requestV1) {\n        var self = this,\n            responses = _.get(requestV1, 'responses', []),\n            responsesCache = _.keyBy(responses, 'id'),\n            responses_order = _.get(requestV1, 'responses_order', []);\n\n        // If ordering of responses is not available\n        // Create a default ordering using the `responses` field\n        if (!(responses_order && responses_order.length)) {\n            responses_order = _.map(responses, 'id');\n        }\n\n        // Filter out any response id that is not available\n        responses_order = _.filter(responses_order, function (responseId) {\n            return _.has(responsesCache, responseId);\n        });\n\n        return _.map(responses_order, function (responseId) {\n            return self.singleResponse(responsesCache[responseId]);\n        });\n    },\n\n    /**\n     * Creates a V2 compatible ``item`` from a V1 Postman Collection Request\n     *\n     * @param {Object} requestV1 - Postman collection V1 request.\n     * @returns {Object} - The converted request object, in v2 format.\n     */\n    singleItem: function (requestV1) {\n        if (!requestV1) { return; }\n\n        var self = this,\n            retainIds = self.options.retainIds,\n            units = ['request', 'response'],\n            variable = self.variable(requestV1, { retainIds: retainIds }),\n            item = {\n                name: requestV1.name || '', // Inline building to avoid additional function call\n                event: self.event(requestV1)\n            };\n\n        retainIds && (item.id = requestV1.id || util.uid());\n        // add protocolProfileBehavior property from requestV1 to the item\n        util.addProtocolProfileBehavior(requestV1, item);\n\n        units.forEach(function (unit) {\n            item[unit] = self[unit](requestV1);\n        });\n\n        variable && variable.length && (item.variable = variable);\n\n        return item;\n    },\n\n    /**\n     * Constructs an array of Items & ItemGroups compatible with the V2 format.\n     *\n     * @param {Object} collectionV1 - The v1 collection to derive folder information from.\n     * @returns {Object[]} - The list of item group definitions.\n     */\n    itemGroups: function (collectionV1) {\n        var self = this,\n            items = [],\n            itemGroupCache = {},\n            retainEmpty = self.options.retainEmptyValues;\n\n        // Read all folder data, and prep it so that we can throw subfolders in the right places\n        itemGroupCache = _.reduce(collectionV1.folders, function (accumulator, folder) {\n            if (!folder) { return accumulator; }\n\n            var retainIds = self.options.retainIds,\n                auth = self.auth(folder),\n                event = self.event(folder),\n                variable = self.variable(folder, { retainIds: retainIds }),\n                result = {\n                    name: folder.name,\n                    item: []\n                };\n\n            retainIds && (result.id = folder.id || util.uid());\n\n            if (folder.description) { result.description = folder.description; }\n            else if (retainEmpty) { result.description = null; }\n\n            (auth || (auth === null)) && (result.auth = auth);\n            event && (result.event = event);\n            variable && variable.length && (result.variable = variable);\n            util.addProtocolProfileBehavior(folder, result);\n\n            accumulator[folder.id] = result;\n\n            return accumulator;\n        }, {});\n\n        // Populate each ItemGroup with subfolders\n        _.forEach(collectionV1.folders, function (folderV1) {\n            if (!folderV1) { return; }\n\n            var itemGroup = itemGroupCache[folderV1.id],\n                hasSubfolders = folderV1.folders_order && folderV1.folders_order.length,\n                hasRequests = folderV1.order && folderV1.order.length;\n\n            // Add subfolders\n            hasSubfolders && _.forEach(folderV1.folders_order, function (subFolderId) {\n                if (!itemGroupCache[subFolderId]) {\n                    // todo: figure out what to do when a collection contains a subfolder ID,\n                    // but the subfolder is not actually there.\n                    return;\n                }\n\n                itemGroupCache[subFolderId][IS_SUBFOLDER] = true;\n\n                itemGroup.item.push(itemGroupCache[subFolderId]);\n            });\n\n            // Add items\n            hasRequests && _.forEach(folderV1.order, function (requestId) {\n                if (!self.cache[requestId]) {\n                    // todo: what do we do here??\n                    return;\n                }\n\n                itemGroup.item.push(self.singleItem(self.cache[requestId]));\n            });\n        });\n\n        // This compromises some self-healing, which was originally present, but the performance cost of\n        // doing self-healing the right way is high, so we directly rely on collectionV1.folders_order\n        // The self-healing way would be to iterate over itemGroupCache directly, but preserving the right order\n        // becomes a pain in that case.\n        _.forEach(_.uniq(collectionV1.folders_order || _.map(collectionV1.folders, 'id')), function (folderId) {\n            var itemGroup = itemGroupCache[folderId];\n\n            itemGroup && !_.get(itemGroup, IS_SUBFOLDER) && items.push(itemGroup);\n        });\n\n        // This is useful later\n        self.itemGroupCache = itemGroupCache;\n\n        return _.compact(items);\n    },\n\n    /**\n     * Creates a V2 compatible array of items from a V1 Postman Collection\n     *\n     * @param {Object} collectionV1 - A Postman Collection object in the V1 format.\n     * @returns {Object[]} - The list of item groups (folders) in v2 format.\n     */\n    item: function (collectionV1) {\n        var self = this,\n            requestsCache = _.keyBy(collectionV1.requests, 'id'),\n            allRequests = _.map(collectionV1.requests, 'id'),\n            result;\n\n        self.cache = requestsCache;\n        result = self.itemGroups(collectionV1);\n\n        _.forEach(_.intersection(collectionV1.order, allRequests), function (requestId) {\n            var request = self.singleItem(requestsCache[requestId]);\n\n            request && (result.push(request));\n        });\n\n        return result;\n    }\n});\n\nmodule.exports = {\n    input: '1.0.0',\n    output: '2.0.0',\n    Builders: Builders,\n\n    /**\n     * Converts a single V1 request to a V2 item.\n     *\n     * @param {Object} request - The v1 request to convert to v2.\n     * @param {Object} options - The set of options for v1 -> v2 conversion.\n     * @param {Function} callback - The function to be invoked when the conversion has completed.\n     */\n    convertSingle: function (request, options, callback) {\n        var builders = new Builders(options),\n            converted,\n            err;\n\n        try {\n            converted = builders.singleItem(_.cloneDeep(request));\n        }\n        catch (e) {\n            err = e;\n        }\n\n        if (callback) {\n            return callback(err, converted);\n        }\n\n        if (err) {\n            throw err;\n        }\n\n        return converted;\n    },\n\n    /**\n     * Converts a single V1 Response to a V2 Response.\n     *\n     * @param {Object} response - The v1 response to convert to v2.\n     * @param {Object} options - The set of options for v1 -> v2 conversion.\n     * @param {Function} callback - The function to be invoked when the conversion has completed.\n     */\n    convertResponse: function (response, options, callback) {\n        var builders = new Builders(options),\n            converted,\n            err;\n\n        try {\n            converted = builders.singleResponse(_.cloneDeep(response));\n        }\n        catch (e) {\n            err = e;\n        }\n\n        if (callback) {\n            return callback(err, converted);\n        }\n\n        if (err) {\n            throw err;\n        }\n\n        return converted;\n    },\n\n    /**\n     * Converts a V1 collection to a V2 collection (performs ID replacement, etc as necessary).\n     *\n     * @param {Object} collection - The v1 collection to convert to v2.\n     * @param {Object} options - The set of options for v1 -> v2 conversion.\n     * @param {Function} callback - The function to be invoked when the conversion has completed.\n     */\n    convert: function (collection, options, callback) {\n        collection = _.cloneDeep(collection);\n\n        var auth,\n            event,\n            variable,\n            newCollection = {},\n            units = ['info', 'item'],\n            builders = new Builders(options),\n            authOptions = { excludeNoauth: true },\n            varOpts = options && { fallback: options.env, retainIds: options.retainIds };\n\n        try {\n            units.forEach(function (unit) {\n                newCollection[unit] = builders[unit](collection);\n            });\n\n            (auth = builders.auth(collection, authOptions)) && (newCollection.auth = auth);\n            (event = builders.event(collection)) && (newCollection.event = event);\n            (variable = builders.variable(collection, varOpts)) && (newCollection.variable = variable);\n            util.addProtocolProfileBehavior(collection, newCollection);\n        }\n        catch (e) {\n            if (callback) {\n                return callback(e, null);\n            }\n            throw e;\n        }\n\n        if (callback) { return callback(null, newCollection); }\n\n        return newCollection;\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}