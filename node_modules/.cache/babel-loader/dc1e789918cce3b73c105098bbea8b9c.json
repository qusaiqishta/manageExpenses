{"ast":null,"code":"/* eslint-disable jsdoc/require-param-type,jsdoc/require-param-description */\nvar _ = require('lodash'),\n  core = require('./core'),\n  EventEmitter = require('events'),\n  now = require('performance-now'),\n  sdk = require('postman-collection'),\n  requests = require('./request-wrapper'),\n  dryRun = require('./dry-run'),\n  RESPONSE_START_EVENT_BASE = 'response.start.',\n  RESPONSE_END_EVENT_BASE = 'response.end.',\n  RESPONSE_START = 'responseStart',\n  RESPONSE_END = 'response',\n  ERROR_RESTRICTED_ADDRESS = 'NETERR: getaddrinfo ENOTFOUND ',\n  /**\n   * Headers which get overwritten by the requester.\n   *\n   * @private\n   * @const\n   * @type {Object}\n   */\n  OVERWRITTEN_HEADERS = {\n    cookie: true,\n    // cookies get appended with `;`\n    'content-length': true\n  },\n  /**\n   * Creates a sdk compatible cookie from a tough-cookie compatible cookie.\n   *\n   * @param cookie\n   * @returns {Object}\n   */\n  toPostmanCookie = function (cookie) {\n    var expires = cookie.expiryTime();\n    cookie.toJSON && (cookie = cookie.toJSON());\n    return new sdk.Cookie({\n      name: cookie.key,\n      value: cookie.value,\n      expires: Number.isFinite(expires) ? new Date(expires) : null,\n      maxAge: cookie.maxAge,\n      domain: cookie.domain,\n      path: cookie.path,\n      secure: cookie.secure,\n      httpOnly: cookie.httpOnly,\n      hostOnly: cookie.hostOnly,\n      extensions: cookie.extensions\n    });\n  },\n  /**\n   * This method is used in conjunction with _.transform method to convert multi-value headers to multiple single\n   * value headers\n   *\n   * @param  {Array} acc\n   * @param  {Array|String} val\n   * @param  {String} key\n   * @return {Object}\n   */\n  transformMultiValueHeaders = function (acc, val, key) {\n    var i, ii;\n    if (Array.isArray(val)) {\n      for (i = 0, ii = val.length; i < ii; i++) {\n        acc.push({\n          key: key,\n          value: val[i]\n        });\n      }\n    } else {\n      acc.push({\n        key: key,\n        value: val\n      });\n    }\n  },\n  /**\n   * Calculate request timings offset by adding runtime overhead which\n   * helps to determine request prepare and process time taken.\n   *\n   * @param {Number} runtimeTimer - Runtime request start HR time\n   * @param {Number} requestTimer - Request start HR time\n   * @param {Object} timings - Request timings offset\n   * @returns {Object}\n   */\n  calcTimingsOffset = function (runtimeTimer, requestTimer, timings) {\n    if (!(runtimeTimer && requestTimer && timings)) {\n      return;\n    }\n\n    // runtime + postman-request initialization time\n    var initTime = requestTimer - runtimeTimer,\n      offset = {\n        request: initTime\n      };\n\n    // add initialization overhead to request offsets\n    _.forOwn(timings, function (value, key) {\n      offset[key] = value + initTime;\n    });\n\n    // total time taken by runtime to get the response\n    // @note if offset.end is missing, that means request is not complete.\n    //       this is used to calculate timings on responseStart.\n    if (offset.end) {\n      offset.done = now() - runtimeTimer;\n    }\n    return offset;\n  };\nclass Requester extends EventEmitter {\n  /**\n   * Creates a new Requester, which is used to make HTTP(s) requests.\n   *\n   * @param trace\n   * @param options\n   * @param {Boolean} [options.keepAlive=true] Optimizes HTTP connections by keeping them alive, so that new requests\n   * to the same host are made over the same underlying TCP connection.\n   * @param {CookieJar} [options.cookieJar] A cookie jar to use with Node requests.\n   * @param {Boolean} [options.strictSSL]\n   * @param {Boolean} [options.followRedirects=true] If false, returns a 301/302 as the response code\n   * instead of following the redirect\n   * @note `options.keepAlive` is only supported in Node.\n   * @note `options.cookieJar` is only supported in Node.\n   */\n  constructor(trace, options) {\n    super();\n    this.trace = trace;\n    this.options = options || {};\n\n    // protect the timeout value from being non-numeric or infinite\n    if (!_.isFinite(this.options.timeout)) {\n      this.options.timeout = undefined;\n    }\n  }\n\n  /**\n   * Perform an HTTP request.\n   *\n   * @param {String} id\n   * @param {Request} request\n   * @param {Object} protocolProfileBehavior\n   * @param {Function} callback\n   */\n  request(id, request, protocolProfileBehavior, callback) {\n    var self = this,\n      hostname,\n      cookieJar,\n      requestOptions,\n      networkOptions = self.options.network || {},\n      startTime = Date.now(),\n      startTimer = now(),\n      // high-resolution time\n      cookies = [],\n      responseHeaders = [],\n      responseJSON = {},\n      // keep track of `responseStart` and `response` triggers\n      _responseStarted = false,\n      _responseEnded = false,\n      _responseData = {},\n      // Refer: https://github.com/postmanlabs/postman-runtime/blob/v7.14.0/docs/history.md\n      getExecutionHistory = function (debugInfo) {\n        var history = {\n            execution: {\n              verbose: Boolean(requestOptions.verbose),\n              sessions: {},\n              data: []\n            }\n          },\n          executionData = [],\n          requestSessions = {};\n        if (!Array.isArray(debugInfo)) {\n          return history;\n        }\n\n        // prepare history from request debug data\n        debugInfo.forEach(function (debugData) {\n          if (!debugData) {\n            return;\n          }\n\n          // @todo cache connection sessions and fetch reused session\n          // from the requester pool.\n          if (debugData.session && !requestSessions[debugData.session.id]) {\n            requestSessions[debugData.session.id] = debugData.session.data;\n          }\n          executionData.push({\n            request: debugData.request,\n            response: debugData.response,\n            timings: debugData.timings && {\n              // runtime start time\n              start: startTime,\n              // request start time\n              requestStart: debugData.timingStart,\n              // offsets calculated are relative to runtime start time\n              offset: calcTimingsOffset(startTimer, debugData.timingStartTimer, debugData.timings)\n            },\n            session: debugData.session && {\n              id: debugData.session.id,\n              // is connection socket reused\n              reused: debugData.session.reused\n            }\n          });\n        });\n\n        // update history object\n        history.execution.data = executionData;\n        history.execution.sessions = requestSessions;\n        return history;\n      },\n      /**\n       * Add the missing/system headers in the request object\n       *\n       * @param {Object[]} headers\n       */\n      addMissingRequestHeaders = function (headers) {\n        _.forEach(headers, function (header) {\n          var lowerCasedKey = header.key.toLowerCase();\n\n          // update headers which gets overwritten by the requester\n          if (OVERWRITTEN_HEADERS[lowerCasedKey]) {\n            if (Array.isArray(_.get(request.headers, ['reference', lowerCasedKey]))) {\n              request.headers.remove(header.key);\n            }\n            request.headers.upsert({\n              key: header.key,\n              value: header.value,\n              system: true\n            });\n          }\n        });\n      },\n      /**\n       * Helper function to trigger `callback` and complete the request function\n       *\n       * @param {Error} error - error while requesting\n       * @param {Response} response - SDK Response instance\n       * @param {Object} history - Request-Response History\n       */\n      onEnd = function (error, response, history) {\n        self.emit(RESPONSE_END_EVENT_BASE + id, error, self.trace.cursor, self.trace, response, request, cookies, history);\n        return callback(error, response, request, cookies, history);\n      },\n      /**\n       * Helper function to keep track of `responseStart` and `response`\n       * triggers to make they are emitted in correct order.\n       *\n       * @todo fix requester control flow to remove this hack!\n       *  this is required because CookieJar.getCookies is async method\n       *  and by that time postman-request ends the request, which affects\n       *  request post-send helpers because `response.start` event is not\n       *  emitted on time and shared variables `cookies`, `responseJSON`,\n       *  and, `responseHeaders` are initialized in onStart function.\n       *\n       * @param {String} trigger - trigger name\n       * @param {Response} response - SDK Response instance\n       * @param {Object} history - Request-Response History\n       */\n      onComplete = function (trigger, response, history) {\n        if (trigger === RESPONSE_START) {\n          // set flag for responseStart callback\n          _responseStarted = true;\n\n          // if response is ended, end the response using cached data\n          if (_responseEnded) {\n            onEnd(null, _responseData.response, _responseData.history);\n          }\n\n          // bail out and wait for response end if not ended already\n          return;\n        }\n\n        // if response started, don't wait and end the response\n        if (_responseStarted) {\n          onEnd(null, response, history);\n          return;\n        }\n\n        // wait for responseStart and cache response callback data\n        _responseEnded = true;\n        _responseData = {\n          response,\n          history\n        };\n      },\n      /**\n       * Helper function to trigger `responseStart` callback and\n       * - transform postman-request response instance to SDK Response\n       * - filter cookies\n       * - filter response headers\n       * - add missing request headers\n       *\n       * @param {Object} response - Postman-Request response instance\n       */\n      onStart = function (response) {\n        var responseStartEventName = RESPONSE_START_EVENT_BASE + id,\n          executionData,\n          initialRequest,\n          finalRequest,\n          sdkResponse,\n          history,\n          done = function () {\n            // emit the response.start event which eventually\n            // triggers responseStart callback\n            self.emit(responseStartEventName, null, sdkResponse, request, cookies, history);\n\n            // trigger completion of responseStart\n            onComplete(RESPONSE_START);\n          };\n\n        // @todo get rid of jsonifyResponse\n        responseJSON = core.jsonifyResponse(response, requestOptions);\n\n        // transform response headers to SDK compatible HeaderList\n        responseHeaders = _.transform(responseJSON.headers, transformMultiValueHeaders, []);\n\n        // initialize SDK Response instance\n        sdkResponse = new sdk.Response({\n          status: response && response.statusMessage,\n          code: responseJSON.statusCode,\n          header: responseHeaders\n        });\n\n        // prepare history from request debug data\n        history = getExecutionHistory(_.get(response, 'request._debug'));\n\n        // get the initial and final (on redirect) request from history\n        executionData = _.get(history, 'execution.data') || [];\n        initialRequest = _.get(executionData, '[0].request') || {};\n        finalRequest = executionData.length > 1 ?\n        // get final redirect\n        _.get(executionData, [executionData.length - 1, 'request']) :\n        // no redirects\n        initialRequest;\n\n        // add missing request headers so that they get bubbled up into the UI\n        addMissingRequestHeaders(initialRequest.headers);\n\n        // pull out cookies from the cookie jar, and make them chrome compatible.\n        if (cookieJar && _.isFunction(cookieJar.getCookies)) {\n          // get cookies set for the final request URL\n          cookieJar.getCookies(finalRequest.href, function (err, cookiesFromJar) {\n            if (err) {\n              return done();\n            }\n            cookies = _.transform(cookiesFromJar, function (acc, cookie) {\n              acc.push(toPostmanCookie(cookie));\n            }, []);\n            cookies = new sdk.CookieList(null, cookies);\n            done();\n          });\n        } else {\n          cookies = new sdk.CookieList(null, []);\n          done();\n        }\n      };\n\n    // at this point the request could have come from collection, auth or sandbox\n    // we can't trust the integrity of this request\n    // bail out if request url is empty\n    if (!(request && request.url && request.url.toString && request.url.toString())) {\n      return onEnd(new Error('runtime:extensions~request: request url is empty'));\n    }\n    cookieJar = self.options.cookieJar;\n    requestOptions = core.getRequestOptions(request, self.options, protocolProfileBehavior);\n\n    // update url with the final encoded url\n    // @note this mutates the request object which will be passed in request\n    // and response callbacks\n    request.url.update(requestOptions.url.href);\n    hostname = request.url.getHost();\n\n    // check if host is on the `restrictedAddresses`\n    if (networkOptions.restrictedAddresses && core.isAddressRestricted(hostname, networkOptions)) {\n      return onEnd(new Error(ERROR_RESTRICTED_ADDRESS + hostname));\n    }\n    return requests(request, requestOptions, onStart, function (err, res, resBody, debug) {\n      // prepare history from request debug data\n      var history = getExecutionHistory(debug),\n        responseTime,\n        response;\n      if (err) {\n        // bubble up http errors\n        // @todo - Should we send an empty sdk Response here?\n        //\n        // Sending `history` object even in case of error\n        return onEnd(err, undefined, history);\n      }\n\n      // Calculate the time taken for us to get the response.\n      responseTime = Date.now() - startTime;\n      if (res && res.timings) {\n        // update response time to actual response end time\n        // of the final request in the redirect chain.\n        responseTime = Math.ceil(res.timings.end);\n      }\n      if (resBody && resBody instanceof ArrayBuffer) {\n        resBody = Buffer.from(resBody);\n      }\n\n      // Response in the SDK format\n      // @todo reuse same response instance used for responseStart callback\n      response = new sdk.Response({\n        code: responseJSON.statusCode,\n        status: res && res.statusMessage,\n        header: responseHeaders,\n        stream: resBody,\n        responseTime: responseTime\n      });\n      onComplete(RESPONSE_END, response, history);\n    });\n  }\n\n  /**\n   * Removes all current event listeners on the requester, and makes it ready for garbage collection :).\n   *\n   * @param {Function=} cb - Optional callback to be called on disposal\n   *\n   * @todo - In the future, when the requester manages its own connections etc, close them all here.\n   */\n  dispose(cb) {\n    // This is safe for us, because we do not use wait on events. (i.e, no part of Runtime ever waits on\n    // any event to occur). We rely on callbacks for that, only choosing to use events as a way of streaming\n    // information outside runtime.\n    this.removeAllListeners();\n    _.isFunction(cb) && cb();\n  }\n\n  /**\n   * Asynchronously create a new requester.\n   *\n   * @param trace\n   * @param trace.type - type of requester to return (for now, just http)\n   * @param trace.source - information about who needs this requester, e.g Auth, etc.\n   * @param trace.cursor - the cursor\n   * @param options\n   * @param callback\n   * @returns {*}\n   */\n  static create(trace, options, callback) {\n    return callback(null, new Requester(trace, options));\n  }\n\n  /**\n   * A helper method to dry run the given request instance.\n   * It returns the cloned request instance with the system added properties.\n   *\n   * @param {Request} request\n   * @param {Object} options\n   * @param {Object} options.cookieJar\n   * @param {Object} options.protocolProfileBehavior\n   * @param {Object} options.implicitCacheControl\n   * @param {Object} options.implicitTraceHeader\n   * @param {Function} done\n   */\n  static dryRun(request, options, done) {\n    return dryRun(request, options, done);\n  }\n}\nmodule.exports.Requester = Requester;","map":{"version":3,"names":["_","require","core","EventEmitter","now","sdk","requests","dryRun","RESPONSE_START_EVENT_BASE","RESPONSE_END_EVENT_BASE","RESPONSE_START","RESPONSE_END","ERROR_RESTRICTED_ADDRESS","OVERWRITTEN_HEADERS","cookie","toPostmanCookie","expires","expiryTime","toJSON","Cookie","name","key","value","Number","isFinite","Date","maxAge","domain","path","secure","httpOnly","hostOnly","extensions","transformMultiValueHeaders","acc","val","i","ii","Array","isArray","length","push","calcTimingsOffset","runtimeTimer","requestTimer","timings","initTime","offset","request","forOwn","end","done","Requester","constructor","trace","options","timeout","undefined","id","protocolProfileBehavior","callback","self","hostname","cookieJar","requestOptions","networkOptions","network","startTime","startTimer","cookies","responseHeaders","responseJSON","_responseStarted","_responseEnded","_responseData","getExecutionHistory","debugInfo","history","execution","verbose","Boolean","sessions","data","executionData","requestSessions","forEach","debugData","session","response","start","requestStart","timingStart","timingStartTimer","reused","addMissingRequestHeaders","headers","header","lowerCasedKey","toLowerCase","get","remove","upsert","system","onEnd","error","emit","cursor","onComplete","trigger","onStart","responseStartEventName","initialRequest","finalRequest","sdkResponse","jsonifyResponse","transform","Response","status","statusMessage","code","statusCode","isFunction","getCookies","href","err","cookiesFromJar","CookieList","url","toString","Error","getRequestOptions","update","getHost","restrictedAddresses","isAddressRestricted","res","resBody","debug","responseTime","Math","ceil","ArrayBuffer","Buffer","from","stream","dispose","cb","removeAllListeners","create","module","exports"],"sources":["/Users/Qusai.Qishta/node_modules/postman-runtime/lib/requester/requester.js"],"sourcesContent":["/* eslint-disable jsdoc/require-param-type,jsdoc/require-param-description */\nvar _ = require('lodash'),\n    core = require('./core'),\n    EventEmitter = require('events'),\n    now = require('performance-now'),\n    sdk = require('postman-collection'),\n    requests = require('./request-wrapper'),\n    dryRun = require('./dry-run'),\n\n    RESPONSE_START_EVENT_BASE = 'response.start.',\n    RESPONSE_END_EVENT_BASE = 'response.end.',\n\n    RESPONSE_START = 'responseStart',\n    RESPONSE_END = 'response',\n\n    ERROR_RESTRICTED_ADDRESS = 'NETERR: getaddrinfo ENOTFOUND ',\n\n    /**\n     * Headers which get overwritten by the requester.\n     *\n     * @private\n     * @const\n     * @type {Object}\n     */\n    OVERWRITTEN_HEADERS = {\n        cookie: true, // cookies get appended with `;`\n        'content-length': true\n    },\n\n    /**\n     * Creates a sdk compatible cookie from a tough-cookie compatible cookie.\n     *\n     * @param cookie\n     * @returns {Object}\n     */\n    toPostmanCookie = function (cookie) {\n        var expires = cookie.expiryTime();\n\n        cookie.toJSON && (cookie = cookie.toJSON());\n\n        return new sdk.Cookie({\n            name: cookie.key,\n            value: cookie.value,\n            expires: Number.isFinite(expires) ? new Date(expires) : null,\n            maxAge: cookie.maxAge,\n            domain: cookie.domain,\n            path: cookie.path,\n            secure: cookie.secure,\n            httpOnly: cookie.httpOnly,\n            hostOnly: cookie.hostOnly,\n            extensions: cookie.extensions\n        });\n    },\n\n    /**\n     * This method is used in conjunction with _.transform method to convert multi-value headers to multiple single\n     * value headers\n     *\n     * @param  {Array} acc\n     * @param  {Array|String} val\n     * @param  {String} key\n     * @return {Object}\n     */\n    transformMultiValueHeaders = function (acc, val, key) {\n        var i, ii;\n\n        if (Array.isArray(val)) {\n            for (i = 0, ii = val.length; i < ii; i++) {\n                acc.push({\n                    key: key,\n                    value: val[i]\n                });\n            }\n        }\n        else {\n            acc.push({\n                key: key,\n                value: val\n            });\n        }\n    },\n\n    /**\n     * Calculate request timings offset by adding runtime overhead which\n     * helps to determine request prepare and process time taken.\n     *\n     * @param {Number} runtimeTimer - Runtime request start HR time\n     * @param {Number} requestTimer - Request start HR time\n     * @param {Object} timings - Request timings offset\n     * @returns {Object}\n     */\n    calcTimingsOffset = function (runtimeTimer, requestTimer, timings) {\n        if (!(runtimeTimer && requestTimer && timings)) { return; }\n\n        // runtime + postman-request initialization time\n        var initTime = requestTimer - runtimeTimer,\n            offset = {\n                request: initTime\n            };\n\n        // add initialization overhead to request offsets\n        _.forOwn(timings, function (value, key) {\n            offset[key] = value + initTime;\n        });\n\n        // total time taken by runtime to get the response\n        // @note if offset.end is missing, that means request is not complete.\n        //       this is used to calculate timings on responseStart.\n        if (offset.end) {\n            offset.done = now() - runtimeTimer;\n        }\n\n        return offset;\n    };\n\nclass Requester extends EventEmitter {\n    /**\n     * Creates a new Requester, which is used to make HTTP(s) requests.\n     *\n     * @param trace\n     * @param options\n     * @param {Boolean} [options.keepAlive=true] Optimizes HTTP connections by keeping them alive, so that new requests\n     * to the same host are made over the same underlying TCP connection.\n     * @param {CookieJar} [options.cookieJar] A cookie jar to use with Node requests.\n     * @param {Boolean} [options.strictSSL]\n     * @param {Boolean} [options.followRedirects=true] If false, returns a 301/302 as the response code\n     * instead of following the redirect\n     * @note `options.keepAlive` is only supported in Node.\n     * @note `options.cookieJar` is only supported in Node.\n     */\n    constructor (trace, options) {\n        super();\n\n        this.trace = trace;\n        this.options = options || {};\n\n        // protect the timeout value from being non-numeric or infinite\n        if (!_.isFinite(this.options.timeout)) {\n            this.options.timeout = undefined;\n        }\n    }\n\n    /**\n     * Perform an HTTP request.\n     *\n     * @param {String} id\n     * @param {Request} request\n     * @param {Object} protocolProfileBehavior\n     * @param {Function} callback\n     */\n    request (id, request, protocolProfileBehavior, callback) {\n        var self = this,\n            hostname,\n            cookieJar,\n            requestOptions,\n            networkOptions = self.options.network || {},\n            startTime = Date.now(),\n            startTimer = now(), // high-resolution time\n            cookies = [],\n            responseHeaders = [],\n            responseJSON = {},\n\n            // keep track of `responseStart` and `response` triggers\n            _responseStarted = false,\n            _responseEnded = false,\n            _responseData = {},\n\n            // Refer: https://github.com/postmanlabs/postman-runtime/blob/v7.14.0/docs/history.md\n            getExecutionHistory = function (debugInfo) {\n                var history = {\n                        execution: {\n                            verbose: Boolean(requestOptions.verbose),\n                            sessions: {},\n                            data: []\n                        }\n                    },\n                    executionData = [],\n                    requestSessions = {};\n\n                if (!Array.isArray(debugInfo)) {\n                    return history;\n                }\n\n                // prepare history from request debug data\n                debugInfo.forEach(function (debugData) {\n                    if (!debugData) { return; }\n\n                    // @todo cache connection sessions and fetch reused session\n                    // from the requester pool.\n                    if (debugData.session && !requestSessions[debugData.session.id]) {\n                        requestSessions[debugData.session.id] = debugData.session.data;\n                    }\n\n                    executionData.push({\n                        request: debugData.request,\n                        response: debugData.response,\n                        timings: debugData.timings && {\n                            // runtime start time\n                            start: startTime,\n                            // request start time\n                            requestStart: debugData.timingStart,\n                            // offsets calculated are relative to runtime start time\n                            offset: calcTimingsOffset(startTimer, debugData.timingStartTimer, debugData.timings)\n                        },\n                        session: debugData.session && {\n                            id: debugData.session.id,\n                            // is connection socket reused\n                            reused: debugData.session.reused\n                        }\n                    });\n                });\n\n                // update history object\n                history.execution.data = executionData;\n                history.execution.sessions = requestSessions;\n\n                return history;\n            },\n\n            /**\n             * Add the missing/system headers in the request object\n             *\n             * @param {Object[]} headers\n             */\n            addMissingRequestHeaders = function (headers) {\n                _.forEach(headers, function (header) {\n                    var lowerCasedKey = header.key.toLowerCase();\n\n                    // update headers which gets overwritten by the requester\n                    if (OVERWRITTEN_HEADERS[lowerCasedKey]) {\n                        if (Array.isArray(_.get(request.headers, ['reference', lowerCasedKey]))) {\n                            request.headers.remove(header.key);\n                        }\n\n                        request.headers.upsert({\n                            key: header.key,\n                            value: header.value,\n                            system: true\n                        });\n                    }\n                });\n            },\n\n            /**\n             * Helper function to trigger `callback` and complete the request function\n             *\n             * @param {Error} error - error while requesting\n             * @param {Response} response - SDK Response instance\n             * @param {Object} history - Request-Response History\n             */\n            onEnd = function (error, response, history) {\n                self.emit(RESPONSE_END_EVENT_BASE + id, error, self.trace.cursor,\n                    self.trace, response, request, cookies, history);\n\n                return callback(error, response, request, cookies, history);\n            },\n\n            /**\n             * Helper function to keep track of `responseStart` and `response`\n             * triggers to make they are emitted in correct order.\n             *\n             * @todo fix requester control flow to remove this hack!\n             *  this is required because CookieJar.getCookies is async method\n             *  and by that time postman-request ends the request, which affects\n             *  request post-send helpers because `response.start` event is not\n             *  emitted on time and shared variables `cookies`, `responseJSON`,\n             *  and, `responseHeaders` are initialized in onStart function.\n             *\n             * @param {String} trigger - trigger name\n             * @param {Response} response - SDK Response instance\n             * @param {Object} history - Request-Response History\n             */\n            onComplete = function (trigger, response, history) {\n                if (trigger === RESPONSE_START) {\n                    // set flag for responseStart callback\n                    _responseStarted = true;\n\n                    // if response is ended, end the response using cached data\n                    if (_responseEnded) {\n                        onEnd(null, _responseData.response, _responseData.history);\n                    }\n\n                    // bail out and wait for response end if not ended already\n                    return;\n                }\n\n                // if response started, don't wait and end the response\n                if (_responseStarted) {\n                    onEnd(null, response, history);\n\n                    return;\n                }\n\n                // wait for responseStart and cache response callback data\n                _responseEnded = true;\n                _responseData = {\n                    response,\n                    history\n                };\n            },\n\n            /**\n             * Helper function to trigger `responseStart` callback and\n             * - transform postman-request response instance to SDK Response\n             * - filter cookies\n             * - filter response headers\n             * - add missing request headers\n             *\n             * @param {Object} response - Postman-Request response instance\n             */\n            onStart = function (response) {\n                var responseStartEventName = RESPONSE_START_EVENT_BASE + id,\n                    executionData,\n                    initialRequest,\n                    finalRequest,\n                    sdkResponse,\n                    history,\n                    done = function () {\n                        // emit the response.start event which eventually\n                        // triggers responseStart callback\n                        self.emit(responseStartEventName, null, sdkResponse, request, cookies, history);\n\n                        // trigger completion of responseStart\n                        onComplete(RESPONSE_START);\n                    };\n\n                // @todo get rid of jsonifyResponse\n                responseJSON = core.jsonifyResponse(response, requestOptions);\n\n                // transform response headers to SDK compatible HeaderList\n                responseHeaders = _.transform(responseJSON.headers, transformMultiValueHeaders, []);\n\n                // initialize SDK Response instance\n                sdkResponse = new sdk.Response({\n                    status: response && response.statusMessage,\n                    code: responseJSON.statusCode,\n                    header: responseHeaders\n                });\n\n                // prepare history from request debug data\n                history = getExecutionHistory(_.get(response, 'request._debug'));\n\n                // get the initial and final (on redirect) request from history\n                executionData = _.get(history, 'execution.data') || [];\n                initialRequest = _.get(executionData, '[0].request') || {};\n                finalRequest = executionData.length > 1 ?\n                    // get final redirect\n                    _.get(executionData, [executionData.length - 1, 'request']) :\n                    // no redirects\n                    initialRequest;\n\n                // add missing request headers so that they get bubbled up into the UI\n                addMissingRequestHeaders(initialRequest.headers);\n\n                // pull out cookies from the cookie jar, and make them chrome compatible.\n                if (cookieJar && _.isFunction(cookieJar.getCookies)) {\n                    // get cookies set for the final request URL\n                    cookieJar.getCookies(finalRequest.href, function (err, cookiesFromJar) {\n                        if (err) {\n                            return done();\n                        }\n\n                        cookies = _.transform(cookiesFromJar, function (acc, cookie) {\n                            acc.push(toPostmanCookie(cookie));\n                        }, []);\n\n                        cookies = new sdk.CookieList(null, cookies);\n\n                        done();\n                    });\n                }\n                else {\n                    cookies = new sdk.CookieList(null, []);\n                    done();\n                }\n            };\n\n        // at this point the request could have come from collection, auth or sandbox\n        // we can't trust the integrity of this request\n        // bail out if request url is empty\n        if (!(request && request.url && request.url.toString && request.url.toString())) {\n            return onEnd(new Error('runtime:extensions~request: request url is empty'));\n        }\n\n        cookieJar = self.options.cookieJar;\n        requestOptions = core.getRequestOptions(request, self.options, protocolProfileBehavior);\n\n        // update url with the final encoded url\n        // @note this mutates the request object which will be passed in request\n        // and response callbacks\n        request.url.update(requestOptions.url.href);\n        hostname = request.url.getHost();\n\n        // check if host is on the `restrictedAddresses`\n        if (networkOptions.restrictedAddresses && core.isAddressRestricted(hostname, networkOptions)) {\n            return onEnd(new Error(ERROR_RESTRICTED_ADDRESS + hostname));\n        }\n\n        return requests(request, requestOptions, onStart, function (err, res, resBody, debug) {\n            // prepare history from request debug data\n            var history = getExecutionHistory(debug),\n                responseTime,\n                response;\n\n            if (err) {\n                // bubble up http errors\n                // @todo - Should we send an empty sdk Response here?\n                //\n                // Sending `history` object even in case of error\n                return onEnd(err, undefined, history);\n            }\n\n\n            // Calculate the time taken for us to get the response.\n            responseTime = Date.now() - startTime;\n\n            if (res && res.timings) {\n                // update response time to actual response end time\n                // of the final request in the redirect chain.\n                responseTime = Math.ceil(res.timings.end);\n            }\n\n            if (resBody && resBody instanceof ArrayBuffer) {\n                resBody = Buffer.from(resBody);\n            }\n\n            // Response in the SDK format\n            // @todo reuse same response instance used for responseStart callback\n            response = new sdk.Response({\n                code: responseJSON.statusCode,\n                status: res && res.statusMessage,\n                header: responseHeaders,\n                stream: resBody,\n                responseTime: responseTime\n            });\n\n            onComplete(RESPONSE_END, response, history);\n        });\n    }\n\n    /**\n     * Removes all current event listeners on the requester, and makes it ready for garbage collection :).\n     *\n     * @param {Function=} cb - Optional callback to be called on disposal\n     *\n     * @todo - In the future, when the requester manages its own connections etc, close them all here.\n     */\n    dispose (cb) {\n        // This is safe for us, because we do not use wait on events. (i.e, no part of Runtime ever waits on\n        // any event to occur). We rely on callbacks for that, only choosing to use events as a way of streaming\n        // information outside runtime.\n        this.removeAllListeners();\n\n        _.isFunction(cb) && cb();\n    }\n\n    /**\n     * Asynchronously create a new requester.\n     *\n     * @param trace\n     * @param trace.type - type of requester to return (for now, just http)\n     * @param trace.source - information about who needs this requester, e.g Auth, etc.\n     * @param trace.cursor - the cursor\n     * @param options\n     * @param callback\n     * @returns {*}\n     */\n    static create (trace, options, callback) {\n        return callback(null, new Requester(trace, options));\n    }\n\n    /**\n     * A helper method to dry run the given request instance.\n     * It returns the cloned request instance with the system added properties.\n     *\n     * @param {Request} request\n     * @param {Object} options\n     * @param {Object} options.cookieJar\n     * @param {Object} options.protocolProfileBehavior\n     * @param {Object} options.implicitCacheControl\n     * @param {Object} options.implicitTraceHeader\n     * @param {Function} done\n     */\n    static dryRun (request, options, done) {\n        return dryRun(request, options, done);\n    }\n}\n\nmodule.exports.Requester = Requester;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}