{"ast":null,"code":"var _ = require('lodash');\nmodule.exports = {\n  init: function (done) {\n    done();\n  },\n  triggers: ['waitStateChange'],\n  prototype: {\n    /**\n     * @param {Function} fn - function to execute\n     * @param {Object} options -\n     * @param {String} options.source -\n     * @param {Number} options.time -\n     * @param {Object} options.cursor -\n     * @param {Function} next -\n     * @private\n     */\n    queueDelay(fn, options, next) {\n      var time = _.isFinite(options.time) ? parseInt(options.time, 10) : 0;\n\n      // if the time is a valid and finite time, we queue the delay command\n      if (time > 0) {\n        this.queue('delay', {\n          cursor: options.cursor,\n          source: options.source,\n          time: time\n        }).done(fn);\n      }\n      // otherwise, we do not delay and simply execute the function that was supposed to be called post delay\n      else {\n        fn();\n      }\n      next();\n    }\n  },\n  process: {\n    /**\n     * @param {Object} payload -\n     * @param {Number} payload.time -\n     * @param {Object} payload.cursor -\n     * @param {String} payload.source -\n     * @param {Function} next -\n     */\n    delay(payload, next) {\n      var cursor = payload.cursor || this.state.cursor.current();\n      this.waiting = true; // set flag\n      // trigger the waiting stae change event\n      this.triggers.waitStateChange(null, cursor, true, payload.time, payload.source);\n      setTimeout(function () {\n        this.waiting = false; // unset flag\n        this.triggers.waitStateChange(null, cursor, false, payload.time, payload.source);\n        next();\n      }.bind(this), payload.time || 0);\n    }\n  }\n};","map":{"version":3,"names":["_","require","module","exports","init","done","triggers","prototype","queueDelay","fn","options","next","time","isFinite","parseInt","queue","cursor","source","process","delay","payload","state","current","waiting","waitStateChange","setTimeout","bind"],"sources":["/Users/Qusai.Qishta/node_modules/postman-runtime/lib/runner/extensions/delay.command.js"],"sourcesContent":["var _ = require('lodash');\n\nmodule.exports = {\n    init: function (done) {\n        done();\n    },\n\n    triggers: ['waitStateChange'],\n\n    prototype: {\n        /**\n         * @param {Function} fn - function to execute\n         * @param {Object} options -\n         * @param {String} options.source -\n         * @param {Number} options.time -\n         * @param {Object} options.cursor -\n         * @param {Function} next -\n         * @private\n         */\n        queueDelay (fn, options, next) {\n            var time = _.isFinite(options.time) ? parseInt(options.time, 10) : 0;\n\n            // if the time is a valid and finite time, we queue the delay command\n            if (time > 0) {\n                this.queue('delay', {\n                    cursor: options.cursor,\n                    source: options.source,\n                    time: time\n                }).done(fn);\n            }\n            // otherwise, we do not delay and simply execute the function that was supposed to be called post delay\n            else {\n                fn();\n            }\n\n            next();\n        }\n    },\n\n    process: {\n        /**\n         * @param {Object} payload -\n         * @param {Number} payload.time -\n         * @param {Object} payload.cursor -\n         * @param {String} payload.source -\n         * @param {Function} next -\n         */\n        delay (payload, next) {\n            var cursor = payload.cursor || this.state.cursor.current();\n\n            this.waiting = true; // set flag\n            // trigger the waiting stae change event\n            this.triggers.waitStateChange(null, cursor, true, payload.time, payload.source);\n\n            setTimeout((function () {\n                this.waiting = false; // unset flag\n                this.triggers.waitStateChange(null, cursor, false, payload.time, payload.source);\n                next();\n            }).bind(this), payload.time || 0);\n        }\n    }\n};\n"],"mappings":"AAAA,IAAIA,CAAC,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAEzBC,MAAM,CAACC,OAAO,GAAG;EACbC,IAAI,EAAE,UAAUC,IAAI,EAAE;IAClBA,IAAI,EAAE;EACV,CAAC;EAEDC,QAAQ,EAAE,CAAC,iBAAiB,CAAC;EAE7BC,SAAS,EAAE;IACP;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQC,UAAU,CAAEC,EAAE,EAAEC,OAAO,EAAEC,IAAI,EAAE;MAC3B,IAAIC,IAAI,GAAGZ,CAAC,CAACa,QAAQ,CAACH,OAAO,CAACE,IAAI,CAAC,GAAGE,QAAQ,CAACJ,OAAO,CAACE,IAAI,EAAE,EAAE,CAAC,GAAG,CAAC;;MAEpE;MACA,IAAIA,IAAI,GAAG,CAAC,EAAE;QACV,IAAI,CAACG,KAAK,CAAC,OAAO,EAAE;UAChBC,MAAM,EAAEN,OAAO,CAACM,MAAM;UACtBC,MAAM,EAAEP,OAAO,CAACO,MAAM;UACtBL,IAAI,EAAEA;QACV,CAAC,CAAC,CAACP,IAAI,CAACI,EAAE,CAAC;MACf;MACA;MAAA,KACK;QACDA,EAAE,EAAE;MACR;MAEAE,IAAI,EAAE;IACV;EACJ,CAAC;EAEDO,OAAO,EAAE;IACL;AACR;AACA;AACA;AACA;AACA;AACA;IACQC,KAAK,CAAEC,OAAO,EAAET,IAAI,EAAE;MAClB,IAAIK,MAAM,GAAGI,OAAO,CAACJ,MAAM,IAAI,IAAI,CAACK,KAAK,CAACL,MAAM,CAACM,OAAO,EAAE;MAE1D,IAAI,CAACC,OAAO,GAAG,IAAI,CAAC,CAAC;MACrB;MACA,IAAI,CAACjB,QAAQ,CAACkB,eAAe,CAAC,IAAI,EAAER,MAAM,EAAE,IAAI,EAAEI,OAAO,CAACR,IAAI,EAAEQ,OAAO,CAACH,MAAM,CAAC;MAE/EQ,UAAU,CAAE,YAAY;QACpB,IAAI,CAACF,OAAO,GAAG,KAAK,CAAC,CAAC;QACtB,IAAI,CAACjB,QAAQ,CAACkB,eAAe,CAAC,IAAI,EAAER,MAAM,EAAE,KAAK,EAAEI,OAAO,CAACR,IAAI,EAAEQ,OAAO,CAACH,MAAM,CAAC;QAChFN,IAAI,EAAE;MACV,CAAC,CAAEe,IAAI,CAAC,IAAI,CAAC,EAAEN,OAAO,CAACR,IAAI,IAAI,CAAC,CAAC;IACrC;EACJ;AACJ,CAAC"},"metadata":{},"sourceType":"script"}