{"ast":null,"code":"var _ = require('../util').lodash,\n  Property = require('./property').Property,\n  PropertyBase = require('./property-base').PropertyBase,\n  VariableList = require('./variable-list').VariableList,\n  MutationTracker = require('./mutation-tracker').MutationTracker,\n  /**\n   * Known variable mutation types.\n   *\n   * @private\n   * @constant\n   * @type {Object}\n   */\n  MUTATIONS = {\n    SET: 'set',\n    UNSET: 'unset'\n  },\n  VariableScope;\n\n/**\n * Environment and Globals of postman is exported and imported in a specified data structure. This data structure can be\n * passed on to the constructor parameter of {@link VariableScope} or {@link VariableList} to instantiate an instance of\n * the same with pre-populated values from arguments.\n *\n * @typedef VariableScope.definition\n * @property {String} [id] ID of the scope\n * @property {String} [name] A name of the scope\n * @property {Array.<Variable.definition>} [values] A list of variables defined in an array in form of `{name:String,\n * value:String}`\n *\n * @example <caption>JSON definition of a VariableScope (environment, globals, etc)</caption>\n * {\n *   \"name\": \"globals\",\n *   \"values\": [{\n *     \"key\": \"var-1\",\n *     \"value\": \"value-1\"\n *   }, {\n *     \"key\": \"var-2\",\n *     \"value\": \"value-2\"\n *   }]\n * }\n */\n_.inherit(\n/**\n * VariableScope is a representation of a list of variables in Postman, such as the environment variables or the\n * globals. Using this object, it is easy to perform operations on this list of variables such as get a variable or\n * set a variable.\n *\n * @constructor\n * @extends {Property}\n *\n * @param {VariableScope.definition} definition The constructor accepts an initial set of values for initialising\n * the scope\n * @param {Array<VariableList>=} layers Additional parent scopes to search for and resolve variables\n *\n * @example <caption>Load a environment from file, modify and save back</caption>\n * var fs = require('fs'), // assuming NodeJS\n *     env,\n *     sum;\n *\n * // load env from file assuming it has initial data\n * env = new VariableScope(JSON.parse(fs.readFileSync('./my-postman-environment.postman_environment').toString()));\n *\n * // get two variables and add them\n * sum = env.get('one-var') + env.get('another-var');\n *\n * // save it back in environment and write to file\n * env.set('sum', sum, 'number');\n * fs.writeFileSync('./sum-of-vars.postman_environment', JSON.stringify(env.toJSON()));\n */\nVariableScope = function PostmanVariableScope(definition, layers) {\n  // in case the definition is an array (legacy format) or existing as list, we convert to actual format\n  if (_.isArray(definition) || VariableList.isVariableList(definition)) {\n    definition = {\n      values: definition\n    };\n  }\n\n  // we accept parent scopes to increase search area. Here we normalize the argument to be an array\n  // so we can easily loop though them and add them to the instance.\n  layers && !_.isArray(layers) && (layers = [layers]);\n\n  // this constructor is intended to inherit and as such the super constructor is required to be executed\n  VariableScope.super_.call(this, definition);\n  var values = definition && definition.values,\n    // access the values (need this var to reuse access)\n\n    // enable mutation tracking if `mutations` are in definition (restore the state)\n    // or is enabled  through options\n    mutations = definition && definition.mutations,\n    ii,\n    i;\n\n  /**\n   * @memberof VariableScope.prototype\n   * @type {VariableList}\n   */\n  this.values = new VariableList(this, VariableList.isVariableList(values) ? values.toJSON() : values);\n  // in above line, we clone the values if it is already a list. there is no point directly using the instance of\n  // a variable list since one cannot be created with a parent reference to begin with.\n\n  if (layers) {\n    this._layers = [];\n    for (i = 0, ii = layers.length; i < ii; i++) {\n      VariableList.isVariableList(layers[i]) && this._layers.push(layers[i]);\n    }\n  }\n\n  // restore previously tracked mutations\n  if (mutations) {\n    this.mutations = new MutationTracker(mutations);\n  }\n}, Property);\n\n/**\n * @note Handling disabled and duplicate variables:\n * | method | single enabled    | single disabled | with duplicates                                                    |\n * |--------|-------------------|-----------------|------------------------------------------------------------------- |\n * | has    | true              | false           | true (if last enabled) OR false (if all disabled)                  |\n * | get    | {Variable}        | undefined       | last enabled {Variable} OR undefined (if all disabled)             |\n * | set    | update {Variable} | new {Variable}  | update last enabled {Variable} OR new {Variable} (if all disabled) |\n * | unset  | delete {Variable} | noop            | delete all enabled {Variable}                                      |\n *\n * @todo Expected behavior of `unset` with duplicates:\n * delete last enabled {Variable} and update the reference with last enabled in rest of the list.\n * This requires unique identifier in the variable list for mutations to work correctly.\n */\n_.assign(VariableScope.prototype, /** @lends VariableScope.prototype */{\n  /**\n   * Defines whether this property instances requires an id\n   *\n   * @private\n   * @readOnly\n   * @type {String}\n   */\n  _postman_propertyRequiresId: true,\n  /**\n   * @private\n   * @deprecated discontinued in v4.0\n   */\n  variables: function () {\n    // eslint-disable-next-line max-len\n    throw new Error('`VariableScope#variables` has been discontinued, use `VariableScope#syncVariablesTo` instead.');\n  },\n  /**\n   * Converts a list of Variables into an object where key is `_postman_propertyIndexKey` and value is determined\n   * by the `valueOf` function\n   *\n   * @param {Boolean} excludeDisabled -\n   * @param {Boolean} caseSensitive -\n   * @returns {Object}\n   */\n  toObject: function (excludeDisabled, caseSensitive) {\n    // if the scope has no layers, we simply export the contents of primary store\n    if (!this._layers) {\n      return this.values.toObject(excludeDisabled, caseSensitive);\n    }\n    var mergedLayers = {};\n    _.forEachRight(this._layers, function (layer) {\n      _.assign(mergedLayers, layer.toObject(excludeDisabled, caseSensitive));\n    });\n    return _.assign(mergedLayers, this.values.toObject(excludeDisabled, caseSensitive));\n  },\n  /**\n   * Determines whether one particular variable is defined in this scope of variables.\n   *\n   * @param {String} key - The name of the variable to check\n   * @returns {Boolean} - Returns true if an enabled variable with given key is present in current or parent scopes,\n   *                      false otherwise\n   */\n  has: function (key) {\n    var variable = this.values.oneNormalizedVariable(key),\n      i,\n      ii;\n\n    // if a variable is disabled or does not exist in local scope,\n    // we search all the layers and return the first occurrence.\n    if ((!variable || variable.disabled === true) && this._layers) {\n      for (i = 0, ii = this._layers.length; i < ii; i++) {\n        variable = this._layers[i].oneNormalizedVariable(key);\n        if (variable && variable.disabled !== true) {\n          break;\n        }\n      }\n    }\n    return Boolean(variable && variable.disabled !== true);\n  },\n  /**\n   * Fetches a variable from the current scope or from parent scopes if present.\n   *\n   * @param {String} key - The name of the variable to get.\n   * @returns {*} The value of the specified variable across scopes.\n   */\n  get: function (key) {\n    var variable = this.values.oneNormalizedVariable(key),\n      i,\n      ii;\n\n    // if a variable does not exist in local scope, we search all the layers and return the first occurrence.\n    if ((!variable || variable.disabled === true) && this._layers) {\n      for (i = 0, ii = this._layers.length; i < ii; i++) {\n        variable = this._layers[i].oneNormalizedVariable(key);\n        if (variable && variable.disabled !== true) {\n          break;\n        }\n      }\n    }\n    return variable && variable.disabled !== true ? variable.valueOf() : undefined;\n  },\n  /**\n   * Creates a new variable, or updates an existing one.\n   *\n   * @param {String} key - The name of the variable to set.\n   * @param {*} value - The value of the variable to be set.\n   * @param {Variable.types} [type] - Optionally, the value of the variable can be set to a type\n   */\n  set: function (key, value, type) {\n    var variable = this.values.oneNormalizedVariable(key),\n      // create an object that will be used as setter\n      update = {\n        key,\n        value\n      };\n    _.isString(type) && (update.type = type);\n\n    // If a variable by the name key exists, update it's value and return.\n    // @note adds new variable if existing is disabled. Disabled variables are not updated.\n    if (variable && !variable.disabled) {\n      variable.update(update);\n    } else {\n      this.values.add(update);\n    }\n\n    // track the change if mutation tracking is enabled\n    this._postman_enableTracking && this.mutations.track(MUTATIONS.SET, key, value);\n  },\n  /**\n   * Removes the variable with the specified name.\n   *\n   * @param {String} key -\n   */\n  unset: function (key) {\n    var lastDisabledVariable;\n    this.values.remove(function (variable) {\n      // bail out if variable name didn't match\n      if (variable.key !== key) {\n        return false;\n      }\n\n      // don't delete disabled variables\n      if (variable.disabled) {\n        lastDisabledVariable = variable;\n        return false;\n      }\n\n      // delete all enabled variables\n      return true;\n    });\n\n    // restore the reference with the last disabled variable\n    if (lastDisabledVariable) {\n      this.values.reference[key] = lastDisabledVariable;\n    }\n\n    // track the change if mutation tracking is enabled\n    this._postman_enableTracking && this.mutations.track(MUTATIONS.UNSET, key);\n  },\n  /**\n   * Removes *all* variables from the current scope. This is a destructive action.\n   */\n  clear: function () {\n    var mutations = this.mutations;\n\n    // track the change if mutation tracking is enabled\n    // do this before deleting the keys\n    if (this._postman_enableTracking) {\n      this.values.each(function (variable) {\n        mutations.track(MUTATIONS.UNSET, variable.key);\n      });\n    }\n    this.values.clear();\n  },\n  /**\n   * Replace all variable names with their values in the given template.\n   *\n   * @param {String|Object} template - A string or an object to replace variables in\n   * @returns {String|Object} The string or object with variables (if any) substituted with their values\n   */\n  replaceIn: function (template) {\n    if (_.isString(template) || _.isArray(template)) {\n      // convert template to object because replaceSubstitutionsIn only accepts objects\n      var result = Property.replaceSubstitutionsIn({\n        template\n      }, _.concat(this.values, this._layers));\n      return result.template;\n    }\n    if (_.isObject(template)) {\n      return Property.replaceSubstitutionsIn(template, _.concat(this.values, this._layers));\n    }\n    return template;\n  },\n  /**\n   * Enable mutation tracking.\n   *\n   * @note: Would do nothing if already enabled.\n   * @note: Any previously tracked mutations would be reset when starting a new tracking session.\n   *\n   * @param {MutationTracker.definition} [options] Options for Mutation Tracker. See {@link MutationTracker}\n   */\n  enableTracking: function (options) {\n    // enabled already, do nothing\n    if (this._postman_enableTracking) {\n      return;\n    }\n\n    /**\n     * Controls if mutation tracking is enabled\n     *\n     * @memberof VariableScope.prototype\n     *\n     * @private\n     * @property {Boolean}\n     */\n    this._postman_enableTracking = true;\n\n    // we don't want to add more mutations to existing mutations\n    // that will lead to mutations not capturing the correct state\n    // so we reset this with the new instance\n    this.mutations = new MutationTracker(options);\n  },\n  /**\n   * Disable mutation tracking.\n   */\n  disableTracking: function () {\n    // disable further tracking but keep the tracked mutations\n    this._postman_enableTracking = false;\n  },\n  /**\n   * Apply a mutation instruction on this variable scope.\n   *\n   * @private\n   * @param {String} instruction Instruction identifying the type of the mutation, e.g. `set`, `unset`\n   * @param {String} key -\n   * @param {*} value -\n   */\n  applyMutation: function (instruction, key, value) {\n    // we know that `set` and `unset` are the only supported instructions\n    // and we know the parameter signature of both is the same as the items in a mutation\n    /* istanbul ignore else */\n    if (this[instruction]) {\n      this[instruction](key, value);\n    }\n  },\n  /**\n   * Using this function, one can sync the values of this variable list from a reference object.\n   *\n   * @private\n   * @param {Object} obj -\n   * @param {Boolean=} [track] -\n   * @returns {Object}\n   */\n  syncVariablesFrom: function (obj, track) {\n    return this.values.syncFromObject(obj, track);\n  },\n  /**\n   * Transfer the variables in this scope to an object\n   *\n   * @private\n   * @param {Object=} [obj] -\n   * @returns {Object}\n   */\n  syncVariablesTo: function (obj) {\n    return this.values.syncToObject(obj);\n  },\n  /**\n   * Convert this variable scope into a JSON serialisable object. Useful to transport or store, environment and\n   * globals as a whole.\n   *\n   * @returns {Object}\n   */\n  toJSON: function () {\n    var obj = PropertyBase.toJSON(this);\n\n    // @todo - remove this when pluralisation is complete\n    if (obj.value) {\n      obj.values = obj.value;\n      delete obj.value;\n    }\n\n    // ensure that the concept of layers is not exported as JSON. JSON cannot retain references and this will end up\n    // being a pointless object post JSONification.\n    if (obj._layers) {\n      delete obj._layers;\n    }\n\n    // ensure that tracking flag is not serialized\n    // otherwise, it is very easy to let tracking trickle to many instances leading to a snowball effect\n    if (obj._postman_enableTracking) {\n      delete obj._postman_enableTracking;\n    }\n    return obj;\n  },\n  /**\n   * Adds a variable list to the current instance in order to increase the surface area of variable resolution.\n   * This enables consumers to search across scopes (eg. environment and globals).\n   *\n   * @private\n   * @param {VariableList} [list] -\n   */\n  addLayer: function (list) {\n    if (!VariableList.isVariableList(list)) {\n      return;\n    }\n    !this._layers && (this._layers = []); // lazily initialize layers\n    this._layers.push(list);\n  }\n});\n_.assign(VariableScope, /** @lends VariableScope */{\n  /**\n   * Defines the name of this property for internal use.\n   *\n   * @private\n   * @readOnly\n   * @type {String}\n   *\n   * @note that this is directly accessed only in case of VariableScope from _.findValue lodash util mixin\n   */\n  _postman_propertyName: 'VariableScope',\n  /**\n   * Check whether an object is an instance of {@link VariableScope}.\n   *\n   * @param {*} obj -\n   * @returns {Boolean}\n   */\n  isVariableScope: function (obj) {\n    return Boolean(obj) && (obj instanceof VariableScope || _.inSuperChain(obj.constructor, '_postman_propertyName', VariableScope._postman_propertyName));\n  }\n});\nmodule.exports = {\n  VariableScope\n};","map":{"version":3,"names":["_","require","lodash","Property","PropertyBase","VariableList","MutationTracker","MUTATIONS","SET","UNSET","VariableScope","inherit","PostmanVariableScope","definition","layers","isArray","isVariableList","values","super_","call","mutations","ii","i","toJSON","_layers","length","push","assign","prototype","_postman_propertyRequiresId","variables","Error","toObject","excludeDisabled","caseSensitive","mergedLayers","forEachRight","layer","has","key","variable","oneNormalizedVariable","disabled","Boolean","get","valueOf","undefined","set","value","type","update","isString","add","_postman_enableTracking","track","unset","lastDisabledVariable","remove","reference","clear","each","replaceIn","template","result","replaceSubstitutionsIn","concat","isObject","enableTracking","options","disableTracking","applyMutation","instruction","syncVariablesFrom","obj","syncFromObject","syncVariablesTo","syncToObject","addLayer","list","_postman_propertyName","isVariableScope","inSuperChain","constructor","module","exports"],"sources":["/Users/Qusai.Qishta/node_modules/postman-collection/lib/collection/variable-scope.js"],"sourcesContent":["var _ = require('../util').lodash,\n    Property = require('./property').Property,\n    PropertyBase = require('./property-base').PropertyBase,\n    VariableList = require('./variable-list').VariableList,\n    MutationTracker = require('./mutation-tracker').MutationTracker,\n\n    /**\n     * Known variable mutation types.\n     *\n     * @private\n     * @constant\n     * @type {Object}\n     */\n    MUTATIONS = {\n        SET: 'set',\n        UNSET: 'unset'\n    },\n\n    VariableScope;\n\n/**\n * Environment and Globals of postman is exported and imported in a specified data structure. This data structure can be\n * passed on to the constructor parameter of {@link VariableScope} or {@link VariableList} to instantiate an instance of\n * the same with pre-populated values from arguments.\n *\n * @typedef VariableScope.definition\n * @property {String} [id] ID of the scope\n * @property {String} [name] A name of the scope\n * @property {Array.<Variable.definition>} [values] A list of variables defined in an array in form of `{name:String,\n * value:String}`\n *\n * @example <caption>JSON definition of a VariableScope (environment, globals, etc)</caption>\n * {\n *   \"name\": \"globals\",\n *   \"values\": [{\n *     \"key\": \"var-1\",\n *     \"value\": \"value-1\"\n *   }, {\n *     \"key\": \"var-2\",\n *     \"value\": \"value-2\"\n *   }]\n * }\n */\n_.inherit((\n\n    /**\n     * VariableScope is a representation of a list of variables in Postman, such as the environment variables or the\n     * globals. Using this object, it is easy to perform operations on this list of variables such as get a variable or\n     * set a variable.\n     *\n     * @constructor\n     * @extends {Property}\n     *\n     * @param {VariableScope.definition} definition The constructor accepts an initial set of values for initialising\n     * the scope\n     * @param {Array<VariableList>=} layers Additional parent scopes to search for and resolve variables\n     *\n     * @example <caption>Load a environment from file, modify and save back</caption>\n     * var fs = require('fs'), // assuming NodeJS\n     *     env,\n     *     sum;\n     *\n     * // load env from file assuming it has initial data\n     * env = new VariableScope(JSON.parse(fs.readFileSync('./my-postman-environment.postman_environment').toString()));\n     *\n     * // get two variables and add them\n     * sum = env.get('one-var') + env.get('another-var');\n     *\n     * // save it back in environment and write to file\n     * env.set('sum', sum, 'number');\n     * fs.writeFileSync('./sum-of-vars.postman_environment', JSON.stringify(env.toJSON()));\n     */\n    VariableScope = function PostmanVariableScope (definition, layers) {\n        // in case the definition is an array (legacy format) or existing as list, we convert to actual format\n        if (_.isArray(definition) || VariableList.isVariableList(definition)) {\n            definition = { values: definition };\n        }\n\n        // we accept parent scopes to increase search area. Here we normalize the argument to be an array\n        // so we can easily loop though them and add them to the instance.\n        layers && !_.isArray(layers) && (layers = [layers]);\n\n        // this constructor is intended to inherit and as such the super constructor is required to be executed\n        VariableScope.super_.call(this, definition);\n\n        var values = definition && definition.values, // access the values (need this var to reuse access)\n\n            // enable mutation tracking if `mutations` are in definition (restore the state)\n            // or is enabled  through options\n            mutations = definition && definition.mutations,\n            ii,\n            i;\n\n        /**\n         * @memberof VariableScope.prototype\n         * @type {VariableList}\n         */\n        this.values = new VariableList(this, VariableList.isVariableList(values) ? values.toJSON() : values);\n        // in above line, we clone the values if it is already a list. there is no point directly using the instance of\n        // a variable list since one cannot be created with a parent reference to begin with.\n\n        if (layers) {\n            this._layers = [];\n\n            for (i = 0, ii = layers.length; i < ii; i++) {\n                VariableList.isVariableList(layers[i]) && this._layers.push(layers[i]);\n            }\n        }\n\n        // restore previously tracked mutations\n        if (mutations) {\n            this.mutations = new MutationTracker(mutations);\n        }\n    }), Property);\n\n/**\n * @note Handling disabled and duplicate variables:\n * | method | single enabled    | single disabled | with duplicates                                                    |\n * |--------|-------------------|-----------------|------------------------------------------------------------------- |\n * | has    | true              | false           | true (if last enabled) OR false (if all disabled)                  |\n * | get    | {Variable}        | undefined       | last enabled {Variable} OR undefined (if all disabled)             |\n * | set    | update {Variable} | new {Variable}  | update last enabled {Variable} OR new {Variable} (if all disabled) |\n * | unset  | delete {Variable} | noop            | delete all enabled {Variable}                                      |\n *\n * @todo Expected behavior of `unset` with duplicates:\n * delete last enabled {Variable} and update the reference with last enabled in rest of the list.\n * This requires unique identifier in the variable list for mutations to work correctly.\n */\n_.assign(VariableScope.prototype, /** @lends VariableScope.prototype */ {\n    /**\n     * Defines whether this property instances requires an id\n     *\n     * @private\n     * @readOnly\n     * @type {String}\n     */\n    _postman_propertyRequiresId: true,\n\n    /**\n     * @private\n     * @deprecated discontinued in v4.0\n     */\n    variables: function () {\n        // eslint-disable-next-line max-len\n        throw new Error('`VariableScope#variables` has been discontinued, use `VariableScope#syncVariablesTo` instead.');\n    },\n\n    /**\n     * Converts a list of Variables into an object where key is `_postman_propertyIndexKey` and value is determined\n     * by the `valueOf` function\n     *\n     * @param {Boolean} excludeDisabled -\n     * @param {Boolean} caseSensitive -\n     * @returns {Object}\n     */\n    toObject: function (excludeDisabled, caseSensitive) {\n        // if the scope has no layers, we simply export the contents of primary store\n        if (!this._layers) {\n            return this.values.toObject(excludeDisabled, caseSensitive);\n        }\n\n        var mergedLayers = {};\n\n        _.forEachRight(this._layers, function (layer) {\n            _.assign(mergedLayers, layer.toObject(excludeDisabled, caseSensitive));\n        });\n\n        return _.assign(mergedLayers, this.values.toObject(excludeDisabled, caseSensitive));\n    },\n\n    /**\n     * Determines whether one particular variable is defined in this scope of variables.\n     *\n     * @param {String} key - The name of the variable to check\n     * @returns {Boolean} - Returns true if an enabled variable with given key is present in current or parent scopes,\n     *                      false otherwise\n     */\n    has: function (key) {\n        var variable = this.values.oneNormalizedVariable(key),\n            i,\n            ii;\n\n        // if a variable is disabled or does not exist in local scope,\n        // we search all the layers and return the first occurrence.\n        if ((!variable || variable.disabled === true) && this._layers) {\n            for (i = 0, ii = this._layers.length; i < ii; i++) {\n                variable = this._layers[i].oneNormalizedVariable(key);\n                if (variable && variable.disabled !== true) { break; }\n            }\n        }\n\n        return Boolean(variable && variable.disabled !== true);\n    },\n\n    /**\n     * Fetches a variable from the current scope or from parent scopes if present.\n     *\n     * @param {String} key - The name of the variable to get.\n     * @returns {*} The value of the specified variable across scopes.\n     */\n    get: function (key) {\n        var variable = this.values.oneNormalizedVariable(key),\n            i,\n            ii;\n\n        // if a variable does not exist in local scope, we search all the layers and return the first occurrence.\n        if ((!variable || variable.disabled === true) && this._layers) {\n            for (i = 0, ii = this._layers.length; i < ii; i++) {\n                variable = this._layers[i].oneNormalizedVariable(key);\n                if (variable && variable.disabled !== true) { break; }\n            }\n        }\n\n        return (variable && variable.disabled !== true) ? variable.valueOf() : undefined;\n    },\n\n    /**\n     * Creates a new variable, or updates an existing one.\n     *\n     * @param {String} key - The name of the variable to set.\n     * @param {*} value - The value of the variable to be set.\n     * @param {Variable.types} [type] - Optionally, the value of the variable can be set to a type\n     */\n    set: function (key, value, type) {\n        var variable = this.values.oneNormalizedVariable(key),\n\n            // create an object that will be used as setter\n            update = { key, value };\n\n        _.isString(type) && (update.type = type);\n\n        // If a variable by the name key exists, update it's value and return.\n        // @note adds new variable if existing is disabled. Disabled variables are not updated.\n        if (variable && !variable.disabled) {\n            variable.update(update);\n        }\n        else {\n            this.values.add(update);\n        }\n\n        // track the change if mutation tracking is enabled\n        this._postman_enableTracking && this.mutations.track(MUTATIONS.SET, key, value);\n    },\n\n    /**\n     * Removes the variable with the specified name.\n     *\n     * @param {String} key -\n     */\n    unset: function (key) {\n        var lastDisabledVariable;\n\n        this.values.remove(function (variable) {\n            // bail out if variable name didn't match\n            if (variable.key !== key) {\n                return false;\n            }\n\n            // don't delete disabled variables\n            if (variable.disabled) {\n                lastDisabledVariable = variable;\n\n                return false;\n            }\n\n            // delete all enabled variables\n            return true;\n        });\n\n        // restore the reference with the last disabled variable\n        if (lastDisabledVariable) {\n            this.values.reference[key] = lastDisabledVariable;\n        }\n\n        // track the change if mutation tracking is enabled\n        this._postman_enableTracking && this.mutations.track(MUTATIONS.UNSET, key);\n    },\n\n    /**\n     * Removes *all* variables from the current scope. This is a destructive action.\n     */\n    clear: function () {\n        var mutations = this.mutations;\n\n        // track the change if mutation tracking is enabled\n        // do this before deleting the keys\n        if (this._postman_enableTracking) {\n            this.values.each(function (variable) {\n                mutations.track(MUTATIONS.UNSET, variable.key);\n            });\n        }\n\n        this.values.clear();\n    },\n\n    /**\n     * Replace all variable names with their values in the given template.\n     *\n     * @param {String|Object} template - A string or an object to replace variables in\n     * @returns {String|Object} The string or object with variables (if any) substituted with their values\n     */\n    replaceIn: function (template) {\n        if (_.isString(template) || _.isArray(template)) {\n            // convert template to object because replaceSubstitutionsIn only accepts objects\n            var result = Property.replaceSubstitutionsIn({ template }, _.concat(this.values, this._layers));\n\n            return result.template;\n        }\n\n        if (_.isObject(template)) {\n            return Property.replaceSubstitutionsIn(template, _.concat(this.values, this._layers));\n        }\n\n        return template;\n    },\n\n    /**\n     * Enable mutation tracking.\n     *\n     * @note: Would do nothing if already enabled.\n     * @note: Any previously tracked mutations would be reset when starting a new tracking session.\n     *\n     * @param {MutationTracker.definition} [options] Options for Mutation Tracker. See {@link MutationTracker}\n     */\n    enableTracking: function (options) {\n        // enabled already, do nothing\n        if (this._postman_enableTracking) {\n            return;\n        }\n\n        /**\n         * Controls if mutation tracking is enabled\n         *\n         * @memberof VariableScope.prototype\n         *\n         * @private\n         * @property {Boolean}\n         */\n        this._postman_enableTracking = true;\n\n        // we don't want to add more mutations to existing mutations\n        // that will lead to mutations not capturing the correct state\n        // so we reset this with the new instance\n        this.mutations = new MutationTracker(options);\n    },\n\n    /**\n     * Disable mutation tracking.\n     */\n    disableTracking: function () {\n        // disable further tracking but keep the tracked mutations\n        this._postman_enableTracking = false;\n    },\n\n    /**\n     * Apply a mutation instruction on this variable scope.\n     *\n     * @private\n     * @param {String} instruction Instruction identifying the type of the mutation, e.g. `set`, `unset`\n     * @param {String} key -\n     * @param {*} value -\n     */\n    applyMutation: function (instruction, key, value) {\n        // we know that `set` and `unset` are the only supported instructions\n        // and we know the parameter signature of both is the same as the items in a mutation\n        /* istanbul ignore else */\n        if (this[instruction]) {\n            this[instruction](key, value);\n        }\n    },\n\n    /**\n     * Using this function, one can sync the values of this variable list from a reference object.\n     *\n     * @private\n     * @param {Object} obj -\n     * @param {Boolean=} [track] -\n     * @returns {Object}\n     */\n    syncVariablesFrom: function (obj, track) {\n        return this.values.syncFromObject(obj, track);\n    },\n\n    /**\n     * Transfer the variables in this scope to an object\n     *\n     * @private\n     * @param {Object=} [obj] -\n     * @returns {Object}\n     */\n    syncVariablesTo: function (obj) {\n        return this.values.syncToObject(obj);\n    },\n\n    /**\n     * Convert this variable scope into a JSON serialisable object. Useful to transport or store, environment and\n     * globals as a whole.\n     *\n     * @returns {Object}\n     */\n    toJSON: function () {\n        var obj = PropertyBase.toJSON(this);\n\n        // @todo - remove this when pluralisation is complete\n        if (obj.value) {\n            obj.values = obj.value;\n            delete obj.value;\n        }\n\n        // ensure that the concept of layers is not exported as JSON. JSON cannot retain references and this will end up\n        // being a pointless object post JSONification.\n        if (obj._layers) {\n            delete obj._layers;\n        }\n\n        // ensure that tracking flag is not serialized\n        // otherwise, it is very easy to let tracking trickle to many instances leading to a snowball effect\n        if (obj._postman_enableTracking) {\n            delete obj._postman_enableTracking;\n        }\n\n        return obj;\n    },\n\n    /**\n     * Adds a variable list to the current instance in order to increase the surface area of variable resolution.\n     * This enables consumers to search across scopes (eg. environment and globals).\n     *\n     * @private\n     * @param {VariableList} [list] -\n     */\n    addLayer: function (list) {\n        if (!VariableList.isVariableList(list)) {\n            return;\n        }\n\n        !this._layers && (this._layers = []); // lazily initialize layers\n        this._layers.push(list);\n    }\n});\n\n_.assign(VariableScope, /** @lends VariableScope */ {\n    /**\n     * Defines the name of this property for internal use.\n     *\n     * @private\n     * @readOnly\n     * @type {String}\n     *\n     * @note that this is directly accessed only in case of VariableScope from _.findValue lodash util mixin\n     */\n    _postman_propertyName: 'VariableScope',\n\n    /**\n     * Check whether an object is an instance of {@link VariableScope}.\n     *\n     * @param {*} obj -\n     * @returns {Boolean}\n     */\n    isVariableScope: function (obj) {\n        return Boolean(obj) && ((obj instanceof VariableScope) ||\n            _.inSuperChain(obj.constructor, '_postman_propertyName', VariableScope._postman_propertyName));\n    }\n});\n\nmodule.exports = {\n    VariableScope\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}