{"ast":null,"code":"'use strict';\n\nvar tunnel = require('@postman/tunnel-agent');\nvar defaultProxyHeaderWhiteList = ['accept', 'accept-charset', 'accept-encoding', 'accept-language', 'accept-ranges', 'cache-control', 'content-encoding', 'content-language', 'content-location', 'content-md5', 'content-range', 'content-type', 'connection', 'date', 'expect', 'max-forwards', 'pragma', 'referer', 'te', 'user-agent', 'via'];\nvar defaultProxyHeaderExclusiveList = ['proxy-authorization'];\nfunction constructProxyHost(uriObject) {\n  var port = uriObject.port;\n  var protocol = uriObject.protocol;\n  var proxyHost = uriObject.hostname + ':';\n  if (port) {\n    proxyHost += port;\n  } else if (protocol === 'https:') {\n    proxyHost += '443';\n  } else {\n    proxyHost += '80';\n  }\n  return proxyHost;\n}\nfunction constructProxyHeaderWhiteList(headers, proxyHeaderWhiteList) {\n  var whiteList = proxyHeaderWhiteList.reduce(function (set, header) {\n    set[header.toLowerCase()] = true;\n    return set;\n  }, {});\n  return Object.keys(headers).filter(function (header) {\n    return whiteList[header.toLowerCase()];\n  }).reduce(function (set, header) {\n    set[header] = headers[header];\n    return set;\n  }, {});\n}\nfunction constructTunnelOptions(request, proxyHeaders) {\n  var proxy = request.proxy;\n  var tunnelOptions = {\n    proxy: {\n      host: proxy.hostname,\n      port: +proxy.port,\n      proxyAuth: proxy.auth,\n      headers: proxyHeaders\n    },\n    headers: request.headers,\n    ca: request.ca,\n    cert: request.cert,\n    key: request.key,\n    passphrase: request.passphrase,\n    pfx: request.pfx,\n    ciphers: request.ciphers,\n    rejectUnauthorized: request.rejectUnauthorized,\n    secureOptions: request.secureOptions,\n    secureProtocol: request.secureProtocol,\n    extraCA: request.extraCA\n  };\n  return tunnelOptions;\n}\nfunction constructTunnelFnName(uri, proxy) {\n  var uriProtocol = uri.protocol === 'https:' ? 'https' : 'http';\n  var proxyProtocol = proxy.protocol === 'https:' ? 'Https' : 'Http';\n  return [uriProtocol, proxyProtocol].join('Over');\n}\nfunction getTunnelFn(request) {\n  var uri = request.uri;\n  var proxy = request.proxy;\n  var tunnelFnName = constructTunnelFnName(uri, proxy);\n  return tunnel[tunnelFnName];\n}\nfunction Tunnel(request) {\n  this.request = request;\n  this.proxyHeaderWhiteList = defaultProxyHeaderWhiteList;\n  this.proxyHeaderExclusiveList = [];\n  if (typeof request.tunnel !== 'undefined') {\n    this.tunnelOverride = request.tunnel;\n  }\n}\nTunnel.prototype.isEnabled = function () {\n  var self = this;\n  var request = self.request;\n  // Tunnel HTTPS by default. Allow the user to override this setting.\n\n  // If self.tunnelOverride is set (the user specified a value), use it.\n  if (typeof self.tunnelOverride !== 'undefined') {\n    return self.tunnelOverride;\n  }\n\n  // If the destination is HTTPS, tunnel.\n  if (request.uri.protocol === 'https:') {\n    return true;\n  }\n\n  // Otherwise, do not use tunnel.\n  return false;\n};\nTunnel.prototype.setup = function (options) {\n  var self = this;\n  var request = self.request;\n  options = options || {};\n  if (typeof request.proxy === 'string') {\n    request.proxy = request.urlParser.parse(request.proxy);\n  }\n  if (!request.proxy || !request.tunnel) {\n    return false;\n  }\n\n  // Setup Proxy Header Exclusive List and White List\n  if (options.proxyHeaderWhiteList) {\n    self.proxyHeaderWhiteList = options.proxyHeaderWhiteList;\n  }\n  if (options.proxyHeaderExclusiveList) {\n    self.proxyHeaderExclusiveList = options.proxyHeaderExclusiveList;\n  }\n  var proxyHeaderExclusiveList = self.proxyHeaderExclusiveList.concat(defaultProxyHeaderExclusiveList);\n  var proxyHeaderWhiteList = self.proxyHeaderWhiteList.concat(proxyHeaderExclusiveList);\n\n  // Setup Proxy Headers and Proxy Headers Host\n  // Only send the Proxy White Listed Header names\n  var proxyHeaders = constructProxyHeaderWhiteList(request.headers, proxyHeaderWhiteList);\n  proxyHeaders.host = constructProxyHost(request.uri);\n  proxyHeaderExclusiveList.forEach(request.removeHeader, request);\n\n  // Set Agent from Tunnel Data\n  var tunnelFn = getTunnelFn(request);\n  var tunnelOptions = constructTunnelOptions(request, proxyHeaders);\n  request.agent = tunnelFn(tunnelOptions);\n  return true;\n};\nTunnel.defaultProxyHeaderWhiteList = defaultProxyHeaderWhiteList;\nTunnel.defaultProxyHeaderExclusiveList = defaultProxyHeaderExclusiveList;\nexports.Tunnel = Tunnel;","map":{"version":3,"names":["tunnel","require","defaultProxyHeaderWhiteList","defaultProxyHeaderExclusiveList","constructProxyHost","uriObject","port","protocol","proxyHost","hostname","constructProxyHeaderWhiteList","headers","proxyHeaderWhiteList","whiteList","reduce","set","header","toLowerCase","Object","keys","filter","constructTunnelOptions","request","proxyHeaders","proxy","tunnelOptions","host","proxyAuth","auth","ca","cert","key","passphrase","pfx","ciphers","rejectUnauthorized","secureOptions","secureProtocol","extraCA","constructTunnelFnName","uri","uriProtocol","proxyProtocol","join","getTunnelFn","tunnelFnName","Tunnel","proxyHeaderExclusiveList","tunnelOverride","prototype","isEnabled","self","setup","options","urlParser","parse","concat","forEach","removeHeader","tunnelFn","agent","exports"],"sources":["/Users/Qusai.Qishta/node_modules/postman-request/lib/tunnel.js"],"sourcesContent":["'use strict'\n\nvar tunnel = require('@postman/tunnel-agent')\n\nvar defaultProxyHeaderWhiteList = [\n  'accept',\n  'accept-charset',\n  'accept-encoding',\n  'accept-language',\n  'accept-ranges',\n  'cache-control',\n  'content-encoding',\n  'content-language',\n  'content-location',\n  'content-md5',\n  'content-range',\n  'content-type',\n  'connection',\n  'date',\n  'expect',\n  'max-forwards',\n  'pragma',\n  'referer',\n  'te',\n  'user-agent',\n  'via'\n]\n\nvar defaultProxyHeaderExclusiveList = [\n  'proxy-authorization'\n]\n\nfunction constructProxyHost (uriObject) {\n  var port = uriObject.port\n  var protocol = uriObject.protocol\n  var proxyHost = uriObject.hostname + ':'\n\n  if (port) {\n    proxyHost += port\n  } else if (protocol === 'https:') {\n    proxyHost += '443'\n  } else {\n    proxyHost += '80'\n  }\n\n  return proxyHost\n}\n\nfunction constructProxyHeaderWhiteList (headers, proxyHeaderWhiteList) {\n  var whiteList = proxyHeaderWhiteList\n    .reduce(function (set, header) {\n      set[header.toLowerCase()] = true\n      return set\n    }, {})\n\n  return Object.keys(headers)\n    .filter(function (header) {\n      return whiteList[header.toLowerCase()]\n    })\n    .reduce(function (set, header) {\n      set[header] = headers[header]\n      return set\n    }, {})\n}\n\nfunction constructTunnelOptions (request, proxyHeaders) {\n  var proxy = request.proxy\n\n  var tunnelOptions = {\n    proxy: {\n      host: proxy.hostname,\n      port: +proxy.port,\n      proxyAuth: proxy.auth,\n      headers: proxyHeaders\n    },\n    headers: request.headers,\n    ca: request.ca,\n    cert: request.cert,\n    key: request.key,\n    passphrase: request.passphrase,\n    pfx: request.pfx,\n    ciphers: request.ciphers,\n    rejectUnauthorized: request.rejectUnauthorized,\n    secureOptions: request.secureOptions,\n    secureProtocol: request.secureProtocol,\n    extraCA: request.extraCA\n  }\n\n  return tunnelOptions\n}\n\nfunction constructTunnelFnName (uri, proxy) {\n  var uriProtocol = (uri.protocol === 'https:' ? 'https' : 'http')\n  var proxyProtocol = (proxy.protocol === 'https:' ? 'Https' : 'Http')\n  return [uriProtocol, proxyProtocol].join('Over')\n}\n\nfunction getTunnelFn (request) {\n  var uri = request.uri\n  var proxy = request.proxy\n  var tunnelFnName = constructTunnelFnName(uri, proxy)\n  return tunnel[tunnelFnName]\n}\n\nfunction Tunnel (request) {\n  this.request = request\n  this.proxyHeaderWhiteList = defaultProxyHeaderWhiteList\n  this.proxyHeaderExclusiveList = []\n  if (typeof request.tunnel !== 'undefined') {\n    this.tunnelOverride = request.tunnel\n  }\n}\n\nTunnel.prototype.isEnabled = function () {\n  var self = this\n  var request = self.request\n    // Tunnel HTTPS by default. Allow the user to override this setting.\n\n  // If self.tunnelOverride is set (the user specified a value), use it.\n  if (typeof self.tunnelOverride !== 'undefined') {\n    return self.tunnelOverride\n  }\n\n  // If the destination is HTTPS, tunnel.\n  if (request.uri.protocol === 'https:') {\n    return true\n  }\n\n  // Otherwise, do not use tunnel.\n  return false\n}\n\nTunnel.prototype.setup = function (options) {\n  var self = this\n  var request = self.request\n\n  options = options || {}\n\n  if (typeof request.proxy === 'string') {\n    request.proxy = request.urlParser.parse(request.proxy)\n  }\n\n  if (!request.proxy || !request.tunnel) {\n    return false\n  }\n\n  // Setup Proxy Header Exclusive List and White List\n  if (options.proxyHeaderWhiteList) {\n    self.proxyHeaderWhiteList = options.proxyHeaderWhiteList\n  }\n  if (options.proxyHeaderExclusiveList) {\n    self.proxyHeaderExclusiveList = options.proxyHeaderExclusiveList\n  }\n\n  var proxyHeaderExclusiveList = self.proxyHeaderExclusiveList.concat(defaultProxyHeaderExclusiveList)\n  var proxyHeaderWhiteList = self.proxyHeaderWhiteList.concat(proxyHeaderExclusiveList)\n\n  // Setup Proxy Headers and Proxy Headers Host\n  // Only send the Proxy White Listed Header names\n  var proxyHeaders = constructProxyHeaderWhiteList(request.headers, proxyHeaderWhiteList)\n  proxyHeaders.host = constructProxyHost(request.uri)\n\n  proxyHeaderExclusiveList.forEach(request.removeHeader, request)\n\n  // Set Agent from Tunnel Data\n  var tunnelFn = getTunnelFn(request)\n  var tunnelOptions = constructTunnelOptions(request, proxyHeaders)\n  request.agent = tunnelFn(tunnelOptions)\n\n  return true\n}\n\nTunnel.defaultProxyHeaderWhiteList = defaultProxyHeaderWhiteList\nTunnel.defaultProxyHeaderExclusiveList = defaultProxyHeaderExclusiveList\nexports.Tunnel = Tunnel\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}