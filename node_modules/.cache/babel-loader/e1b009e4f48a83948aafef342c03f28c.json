{"ast":null,"code":"/**\n * @fileoverview\n *\n * Copied the URL parser and unparser from the SDK.\n * @todo Move this into it's own separate module, and make the SDK and transformer depend on it.\n */\n\nconst _ = require('lodash').noConflict(),\n  E = '',\n  HASH = '#',\n  SLASH = '/',\n  COLON = ':',\n  EQUALS = '=',\n  AMPERSAND = '&',\n  AUTH_SEPARATOR = '@',\n  QUERY_SEPARATOR = '?',\n  DOMAIN_SEPARATOR = '.',\n  PROTOCOL_SEPARATOR = '://',\n  PROTOCOL_SEPARATOR_WITH_BACKSLASH = ':\\\\\\\\',\n  STRING = 'string',\n  FUNCTION = 'function',\n  SAFE_REPLACE_CHAR = '_',\n  CLOSING_SQUARE_BRACKET = ']',\n  URL_PROPERTIES_ORDER = ['protocol', 'auth', 'host', 'port', 'path', 'query', 'hash'],\n  REGEX_HASH = /#/g,\n  REGEX_EQUALS = /=/g,\n  // eslint-disable-line no-div-regex\n  REGEX_AMPERSAND = /&/g,\n  REGEX_EXTRACT_VARS = /{{[^{}]*[.:/?#@&\\]][^{}]*}}/g,\n  REGEX_EXTRACT_VARS_IN_PARAM = /{{[^{}]*[&#=][^{}]*}}/g,\n  /**\n   * Percent encode reserved chars (&, = and #) in the given string.\n   *\n   * @private\n   * @param {String} str - String to encode\n   * @param {Boolean} encodeEquals - Encode '=' if true\n   * @returns {String} - Encoded string\n   */\n  encodeReservedChars = function (str, encodeEquals) {\n    if (!str) {\n      return str;\n    }\n\n    // eslint-disable-next-line lodash/prefer-includes\n    str.indexOf(AMPERSAND) !== -1 && (str = str.replace(REGEX_AMPERSAND, '%26'));\n\n    // eslint-disable-next-line lodash/prefer-includes\n    str.indexOf(HASH) !== -1 && (str = str.replace(REGEX_HASH, '%23'));\n\n    // eslint-disable-next-line lodash/prefer-includes\n    encodeEquals && str.indexOf(EQUALS) !== -1 && (str = str.replace(REGEX_EQUALS, '%3D'));\n    return str;\n  },\n  /**\n   * Normalize the given param string by percent-encoding the reserved chars\n   * such that it won't affect the re-parsing.\n   *\n   * @note `&`, `=` and `#` needs to be percent-encoded otherwise re-parsing\n   * the same URL string will generate different output\n   *\n   * @private\n   * @param {String} str - Parameter string to normalize\n   * @param {Boolean} encodeEquals - If true, encode '=' while normalizing\n   * @returns {String} - Normalized param string\n   */\n  normalizeParam = function (str, encodeEquals) {\n    // bail out if the given sting is null or empty\n    if (!(str && typeof str === STRING)) {\n      return str;\n    }\n\n    // bail out if the given string does not include reserved chars\n    // eslint-disable-next-line lodash/prefer-includes\n    if (str.indexOf(AMPERSAND) === -1 && str.indexOf(HASH) === -1) {\n      // eslint-disable-next-line lodash/prefer-includes\n      if (!(encodeEquals && str.indexOf(EQUALS) !== -1)) {\n        return str;\n      }\n    }\n    var normalizedString = '',\n      pointer = 0,\n      variable,\n      match,\n      index;\n\n    // find all the instances of {{<variable>}} which includes reserved chars\n    while ((match = REGEX_EXTRACT_VARS_IN_PARAM.exec(str)) !== null) {\n      variable = match[0];\n      index = match.index;\n\n      // [pointer, index) string is normalized + the matched variable\n      normalizedString += encodeReservedChars(str.slice(pointer, index), encodeEquals) + variable;\n\n      // update the pointer\n      pointer = index + variable.length;\n    }\n\n    // whatever left in the string is normalized as well\n    if (pointer < str.length) {\n      normalizedString += encodeReservedChars(str.slice(pointer), encodeEquals);\n    }\n    return normalizedString;\n  },\n  /**\n   * Unparses a single query param into a string.\n   *\n   * @private\n   * @param {Object} obj - The query parameter object to be unparsed.\n   * @returns {String} - The unparsed query string.\n   */\n  unparseQueryParam = function (obj) {\n    if (!obj) {\n      return E;\n    }\n    var key = obj.key,\n      value = obj.value,\n      result;\n    if (typeof key === STRING) {\n      result = normalizeParam(key, true);\n    } else {\n      result = E;\n    }\n    if (typeof value === STRING) {\n      result += EQUALS + normalizeParam(value);\n    }\n    return result;\n  },\n  /**\n   * Parses a single query param string into an object.\n   *\n   * @private\n   * @param {String} param - The query parameter string to be parsed.\n   * @returns {Object} - The parsed query object.\n   */\n  parseQueryParam = function (param) {\n    if (param === E) {\n      return {\n        key: null,\n        value: null\n      };\n    }\n    var index = _.indexOf(param, EQUALS);\n    if (index < 0) {\n      return {\n        key: param,\n        value: null\n      };\n    }\n    return {\n      key: param.substr(0, index),\n      value: param.substr(index + 1)\n    };\n  };\n\n/**\n * Tracks replacements done on a string and expose utility to patch replacements.\n *\n * @note due to performance reasons, it doesn't store the original string or\n * perform ops on the string.\n *\n * @private\n * @constructor\n */\nfunction ReplacementTracker() {\n  this.replacements = [];\n  this._offset = 0;\n  this._length = 0;\n}\n\n/**\n * Add new replacement to track.\n *\n * @param {String} value - value being replaced\n * @param {Number} index - index of replacement\n */\nReplacementTracker.prototype.add = function (value, index) {\n  this.replacements.push({\n    value: value,\n    index: index - this._offset\n  });\n  this._offset += value.length - 1; // - 1 replaced character\n  this._length++;\n};\n\n/**\n * Returns the total number of replacements.\n *\n * @returns {Number}\n */\nReplacementTracker.prototype.count = function () {\n  return this._length;\n};\n\n/**\n * Finds the lower index of replacement position for a given value using inexact\n * binary search.\n *\n * @param {Number} index - index to search in replacements\n * @returns {Number}\n */\nReplacementTracker.prototype._findLowerIndex = function (index) {\n  var length = this.count(),\n    start = 0,\n    end = length - 1,\n    mid;\n  while (start <= end) {\n    mid = start + end >> 1; // divide by 2\n\n    if (this.replacements[mid].index >= index) {\n      end = mid - 1;\n    } else {\n      start = mid + 1;\n    }\n  }\n  return start >= length ? -1 : start;\n};\n\n/**\n * Patches a given string by apply all the applicable replacements done in the\n * given range.\n *\n * @param {String} input - string to apply replacements on\n * @param {Number} beginIndex - index from where to apply replacements in input\n * @param {Number} endIndex - index until where to apply replacements in input\n * @returns {String}\n */\nReplacementTracker.prototype._applyInString = function (input, beginIndex, endIndex) {\n  var index,\n    replacement,\n    replacementIndex,\n    replacementValue,\n    offset = 0,\n    length = this.count();\n\n  // bail out if no replacements are done in the given range OR empty string\n  if (!input || (index = this._findLowerIndex(beginIndex)) === -1) {\n    return input;\n  }\n  do {\n    replacement = this.replacements[index];\n    replacementIndex = replacement.index;\n    replacementValue = replacement.value;\n\n    // bail out if all the replacements are done in the given range\n    if (replacementIndex >= endIndex) {\n      break;\n    }\n    replacementIndex = offset + replacementIndex - beginIndex;\n    input = input.slice(0, replacementIndex) + replacementValue + input.slice(replacementIndex + 1);\n    offset += replacementValue.length - 1;\n  } while (++index < length);\n  return input;\n};\n\n/**\n * Patches a given string or array of strings by apply all the applicable\n * replacements done in the given range.\n *\n * @param {String|String[]} input - string or splitted string to apply replacements on\n * @param {Number} beginIndex - index from where to apply replacements in input\n * @param {Number} endIndex - index until where to apply replacements in input\n * @returns {String|String[]}\n */\nReplacementTracker.prototype.apply = function (input, beginIndex, endIndex) {\n  var i,\n    ii,\n    length,\n    _endIndex,\n    _beginIndex,\n    value = input;\n\n  // apply replacements in string\n  if (typeof input === STRING) {\n    return this._applyInString(input, beginIndex, endIndex);\n  }\n\n  // apply replacements in the splitted string (Array)\n  _beginIndex = beginIndex;\n\n  // traverse all the segments until all the replacements are patched\n  for (i = 0, ii = input.length; i < ii; ++i) {\n    value = input[i];\n    _endIndex = _beginIndex + (length = value.length);\n\n    // apply replacements applicable for individual segment\n    input[i] = this._applyInString(value, _beginIndex, _endIndex);\n    _beginIndex += length + 1; // + 1 separator\n  }\n\n  return input;\n};\n\n/**\n * Normalize the given string by replacing the variables which includes\n * reserved characters in its name.\n * The replaced characters are added to the given replacement tracker instance.\n *\n * @private\n * @param {String} str - string to normalize\n * @param {ReplacementTracker} replacements - tracker to store replacements\n * @returns {String}\n */\nfunction normalizeVariables(str, replacements) {\n  var normalizedString = E,\n    pointer = 0,\n    // pointer till witch the string is normalized\n    variable,\n    match,\n    index;\n\n  // find all the instances of {{<variable>}} which includes reserved chars\n  // \"Hello {{user#name}}!!!\"\n  //  ↑ (pointer = 0)\n  while ((match = REGEX_EXTRACT_VARS.exec(str)) !== null) {\n    // {{user#name}}\n    variable = match[0];\n\n    // starting index of the {{variable}} in the string\n    // \"Hello {{user#name}}!!!\"\n    //        ↑ (index = 6)\n    index = match.index;\n\n    // [pointer, index) string is normalized + the safe replacement character\n    // \"Hello \" + \"_\"\n    normalizedString += str.slice(pointer, index) + SAFE_REPLACE_CHAR;\n\n    // track the replacement done for the {{variable}}\n    replacements.add(variable, index);\n\n    // update the pointer\n    // \"Hello {{user#name}}!!!\"\n    //                     ↑ (pointer = 19)\n    pointer = index + variable.length;\n  }\n\n  // avoid slicing the string in case of no matches\n  if (pointer === 0) {\n    return str;\n  }\n\n  // whatever left in the string is normalized as well\n  if (pointer < str.length) {\n    // \"Hello _\" + \"!!!\"\n    normalizedString += str.slice(pointer);\n  }\n  return normalizedString;\n}\n\n/**\n * Update replaced characters in the URL object with its original value.\n *\n * @private\n * @param {Object} url - url to apply replacements on\n * @param {ReplacementTracker} replacements - tracked replacements\n */\nfunction applyReplacements(url, replacements) {\n  var i, ii, prop;\n\n  // traverse each URL property in the given order\n  for (i = 0, ii = URL_PROPERTIES_ORDER.length; i < ii; ++i) {\n    prop = url[URL_PROPERTIES_ORDER[i]];\n\n    // bail out if the given property is not set (undefined or E)\n    if (!(prop && prop.value)) {\n      continue;\n    }\n    prop.value = replacements.apply(prop.value, prop.beginIndex, prop.endIndex);\n  }\n  return url;\n}\n\n/**\n * Parses the input string by decomposing the URL into constituent parts,\n * such as path, host, port, etc.\n *\n * @private\n * @param {String} urlString - url string to parse\n * @returns {Object}\n */\nfunction url_parse(urlString) {\n  // trim leading whitespace characters\n  urlString = String(urlString).trimLeft();\n  var url = {\n      protocol: {\n        value: undefined,\n        beginIndex: 0,\n        endIndex: 0\n      },\n      auth: {\n        value: undefined,\n        beginIndex: 0,\n        endIndex: 0\n      },\n      host: {\n        value: undefined,\n        beginIndex: 0,\n        endIndex: 0\n      },\n      port: {\n        value: undefined,\n        beginIndex: 0,\n        endIndex: 0\n      },\n      path: {\n        value: undefined,\n        beginIndex: 0,\n        endIndex: 0\n      },\n      query: {\n        value: undefined,\n        beginIndex: 0,\n        endIndex: 0\n      },\n      hash: {\n        value: undefined,\n        beginIndex: 0,\n        endIndex: 0\n      }\n    },\n    parsedUrl = {\n      raw: urlString,\n      protocol: undefined,\n      auth: undefined,\n      host: undefined,\n      port: undefined,\n      path: undefined,\n      query: undefined,\n      hash: undefined\n    },\n    replacements = new ReplacementTracker(),\n    pointer = 0,\n    length,\n    index,\n    port;\n\n  // bail out if input string is empty\n  if (!urlString) {\n    return parsedUrl;\n  }\n\n  // normalize the given string\n  urlString = normalizeVariables(urlString, replacements);\n  length = urlString.length;\n\n  // 1. url.hash\n  if ((index = urlString.indexOf(HASH)) !== -1) {\n    // extract from the back\n    url.hash.value = urlString.slice(index + 1);\n    url.hash.beginIndex = pointer + index + 1;\n    url.hash.endIndex = pointer + length;\n    urlString = urlString.slice(0, length = index);\n  }\n\n  // 2. url.query\n  if ((index = urlString.indexOf(QUERY_SEPARATOR)) !== -1) {\n    // extract from the back\n    url.query.value = urlString.slice(index + 1).split(AMPERSAND);\n    url.query.beginIndex = pointer + index + 1;\n    url.query.endIndex = pointer + length;\n    urlString = urlString.slice(0, length = index);\n  }\n\n  // 3. url.protocol\n  if ((index = urlString.indexOf(PROTOCOL_SEPARATOR)) !== -1) {\n    // extract from the front\n    url.protocol.value = urlString.slice(0, index);\n    url.protocol.beginIndex = pointer;\n    url.protocol.endIndex = pointer + index;\n    urlString = urlString.slice(index + 3);\n    length -= index + 3;\n    pointer += index + 3;\n  }\n  // protocol can be separated using :\\\\ as well\n  else if ((index = urlString.indexOf(PROTOCOL_SEPARATOR_WITH_BACKSLASH)) !== -1) {\n    // extract from the front\n    url.protocol.value = urlString.slice(0, index);\n    url.protocol.beginIndex = pointer;\n    url.protocol.endIndex = pointer + index;\n    urlString = urlString.slice(index + 3);\n    length -= index + 3;\n    pointer += index + 3;\n  }\n\n  // 4. url.path\n  urlString = urlString.replace(/\\\\/g, '/'); // sanitize path\n  if ((index = urlString.indexOf(SLASH)) !== -1) {\n    // extract from the back\n    url.path.value = urlString.slice(index + 1).split(SLASH);\n    url.path.beginIndex = pointer + index + 1;\n    url.path.endIndex = pointer + length;\n    urlString = urlString.slice(0, length = index);\n  }\n\n  // 5. url.auth\n  if ((index = urlString.lastIndexOf(AUTH_SEPARATOR)) !== -1) {\n    // extract from the front\n    url.auth.value = urlString.slice(0, index);\n    url.auth.beginIndex = pointer;\n    url.auth.endIndex = pointer + index;\n    urlString = urlString.slice(index + 1);\n    length -= index + 1;\n    pointer += index + 1;\n\n    // separate username:password\n    if ((index = url.auth.value.indexOf(COLON)) === -1) {\n      url.auth.value = [url.auth.value];\n    } else {\n      url.auth.value = [url.auth.value.slice(0, index), url.auth.value.slice(index + 1)];\n    }\n  }\n\n  // 6. url.port\n  if ((index = urlString.lastIndexOf(COLON)) !== -1 &&\n  // eslint-disable-next-line lodash/prefer-includes\n  (port = urlString.slice(index + 1)).indexOf(CLOSING_SQUARE_BRACKET) === -1) {\n    // extract from the back\n    url.port.value = port;\n    url.port.beginIndex = pointer + index + 1;\n    url.port.endIndex = pointer + length;\n    urlString = urlString.slice(0, length = index);\n  }\n\n  // 7. url.host\n  if (urlString) {\n    url.host.value = urlString.split(DOMAIN_SEPARATOR);\n    url.host.beginIndex = pointer;\n    url.host.endIndex = pointer + length;\n  }\n\n  // apply replacements back, if any\n  replacements.count() && applyReplacements(url, replacements);\n\n  // finally, prepare parsed url\n  parsedUrl.protocol = url.protocol.value;\n  parsedUrl.auth = url.auth.value;\n  parsedUrl.host = url.host.value;\n  parsedUrl.port = url.port.value;\n  parsedUrl.path = url.path.value;\n  parsedUrl.query = url.query.value;\n  parsedUrl.hash = url.hash.value;\n  return parsedUrl;\n}\n\n/* eslint-disable object-shorthand */\nmodule.exports = {\n  parse: function (url) {\n    if (typeof url !== STRING) {\n      url = '';\n    }\n    url = url_parse(url);\n    var pathVariables,\n      pathVariableKeys = {};\n    if (url.auth) {\n      url.auth = {\n        user: url.auth[0],\n        password: url.auth[1]\n      };\n    }\n    if (url.query) {\n      url.query = url.query.map(parseQueryParam);\n    }\n\n    // extract path variables\n    pathVariables = _.transform(url.path, function (res, segment) {\n      // check if the segment has path variable prefix followed by the variable name and\n      // the variable is not already added in the list.\n      if (_.startsWith(segment, COLON) && segment !== COLON && !pathVariableKeys[segment]) {\n        pathVariableKeys[segment] = true;\n        res.push({\n          key: segment.slice(1)\n        }); // remove path variable prefix.\n      }\n    }, []);\n    url.variable = pathVariables.length ? pathVariables : undefined;\n    return url;\n  },\n  unparse: function (urlObj) {\n    var rawUrl = E,\n      path,\n      queryString,\n      authString,\n      firstEnabledParam = true;\n    if (urlObj.protocol) {\n      rawUrl += _.endsWith(urlObj.protocol, PROTOCOL_SEPARATOR) ? urlObj.protocol : urlObj.protocol + PROTOCOL_SEPARATOR;\n    }\n    if (urlObj.auth) {\n      if (typeof urlObj.auth.user === STRING) {\n        authString = urlObj.auth.user;\n      }\n      if (typeof urlObj.auth.password === STRING) {\n        !authString && (authString = E);\n        authString += COLON + urlObj.auth.password;\n      }\n      if (typeof authString === STRING) {\n        rawUrl += authString + AUTH_SEPARATOR;\n      }\n    }\n    if (urlObj.host) {\n      rawUrl += _.isArray(urlObj.host) ? urlObj.host.join(DOMAIN_SEPARATOR) : urlObj.host.toString();\n    }\n    if (typeof _.get(urlObj.port, 'toString') === FUNCTION) {\n      rawUrl += COLON + urlObj.port.toString();\n    }\n    if (urlObj.path) {\n      path = _.isArray(urlObj.path) ? urlObj.path.join(SLASH) : urlObj.path.toString();\n      rawUrl += _.startsWith(path, SLASH) ? path : SLASH + path;\n    }\n    if (urlObj.query && urlObj.query.length) {\n      queryString = _.reduce(urlObj.query, function (accumulator, param) {\n        // ignore disabled params\n        if (!param || param.disabled) {\n          return accumulator;\n        }\n\n        // don't add '&' for the very first enabled param\n        if (firstEnabledParam) {\n          firstEnabledParam = false;\n        }\n        // add '&' before concatenating param\n        else {\n          accumulator += AMPERSAND;\n        }\n        return accumulator + unparseQueryParam(param);\n      }, E);\n\n      // either all the params are disabled or a single param is like { key: '' } (http://localhost?)\n      // in that case, query separator ? must be included in the raw URL.\n      if (queryString === E && firstEnabledParam) {\n        // unset querystring if there are no enabled params\n        queryString = undefined;\n      }\n      if (typeof queryString === STRING) {\n        rawUrl += QUERY_SEPARATOR + queryString;\n      }\n    }\n    if (typeof urlObj.hash === STRING) {\n      rawUrl += HASH + urlObj.hash;\n    }\n    return rawUrl;\n  }\n};","map":{"version":3,"names":["_","require","noConflict","E","HASH","SLASH","COLON","EQUALS","AMPERSAND","AUTH_SEPARATOR","QUERY_SEPARATOR","DOMAIN_SEPARATOR","PROTOCOL_SEPARATOR","PROTOCOL_SEPARATOR_WITH_BACKSLASH","STRING","FUNCTION","SAFE_REPLACE_CHAR","CLOSING_SQUARE_BRACKET","URL_PROPERTIES_ORDER","REGEX_HASH","REGEX_EQUALS","REGEX_AMPERSAND","REGEX_EXTRACT_VARS","REGEX_EXTRACT_VARS_IN_PARAM","encodeReservedChars","str","encodeEquals","indexOf","replace","normalizeParam","normalizedString","pointer","variable","match","index","exec","slice","length","unparseQueryParam","obj","key","value","result","parseQueryParam","param","substr","ReplacementTracker","replacements","_offset","_length","prototype","add","push","count","_findLowerIndex","start","end","mid","_applyInString","input","beginIndex","endIndex","replacement","replacementIndex","replacementValue","offset","apply","i","ii","_endIndex","_beginIndex","normalizeVariables","applyReplacements","url","prop","url_parse","urlString","String","trimLeft","protocol","undefined","auth","host","port","path","query","hash","parsedUrl","raw","split","lastIndexOf","module","exports","parse","pathVariables","pathVariableKeys","user","password","map","transform","res","segment","startsWith","unparse","urlObj","rawUrl","queryString","authString","firstEnabledParam","endsWith","isArray","join","toString","get","reduce","accumulator","disabled"],"sources":["/Users/Qusai.Qishta/node_modules/postman-collection-transformer/lib/url.js"],"sourcesContent":["/**\n * @fileoverview\n *\n * Copied the URL parser and unparser from the SDK.\n * @todo Move this into it's own separate module, and make the SDK and transformer depend on it.\n */\n\nconst _ = require('lodash').noConflict(),\n\n    E = '',\n    HASH = '#',\n    SLASH = '/',\n    COLON = ':',\n    EQUALS = '=',\n    AMPERSAND = '&',\n    AUTH_SEPARATOR = '@',\n    QUERY_SEPARATOR = '?',\n    DOMAIN_SEPARATOR = '.',\n    PROTOCOL_SEPARATOR = '://',\n    PROTOCOL_SEPARATOR_WITH_BACKSLASH = ':\\\\\\\\',\n\n    STRING = 'string',\n    FUNCTION = 'function',\n    SAFE_REPLACE_CHAR = '_',\n    CLOSING_SQUARE_BRACKET = ']',\n    URL_PROPERTIES_ORDER = ['protocol', 'auth', 'host', 'port', 'path', 'query', 'hash'],\n\n    REGEX_HASH = /#/g,\n    REGEX_EQUALS = /=/g, // eslint-disable-line no-div-regex\n    REGEX_AMPERSAND = /&/g,\n    REGEX_EXTRACT_VARS = /{{[^{}]*[.:/?#@&\\]][^{}]*}}/g,\n    REGEX_EXTRACT_VARS_IN_PARAM = /{{[^{}]*[&#=][^{}]*}}/g,\n\n    /**\n     * Percent encode reserved chars (&, = and #) in the given string.\n     *\n     * @private\n     * @param {String} str - String to encode\n     * @param {Boolean} encodeEquals - Encode '=' if true\n     * @returns {String} - Encoded string\n     */\n    encodeReservedChars = function (str, encodeEquals) {\n        if (!str) {\n            return str;\n        }\n\n        // eslint-disable-next-line lodash/prefer-includes\n        str.indexOf(AMPERSAND) !== -1 && (str = str.replace(REGEX_AMPERSAND, '%26'));\n\n        // eslint-disable-next-line lodash/prefer-includes\n        str.indexOf(HASH) !== -1 && (str = str.replace(REGEX_HASH, '%23'));\n\n        // eslint-disable-next-line lodash/prefer-includes\n        encodeEquals && str.indexOf(EQUALS) !== -1 && (str = str.replace(REGEX_EQUALS, '%3D'));\n\n        return str;\n    },\n\n    /**\n     * Normalize the given param string by percent-encoding the reserved chars\n     * such that it won't affect the re-parsing.\n     *\n     * @note `&`, `=` and `#` needs to be percent-encoded otherwise re-parsing\n     * the same URL string will generate different output\n     *\n     * @private\n     * @param {String} str - Parameter string to normalize\n     * @param {Boolean} encodeEquals - If true, encode '=' while normalizing\n     * @returns {String} - Normalized param string\n     */\n    normalizeParam = function (str, encodeEquals) {\n        // bail out if the given sting is null or empty\n        if (!(str && typeof str === STRING)) {\n            return str;\n        }\n\n        // bail out if the given string does not include reserved chars\n        // eslint-disable-next-line lodash/prefer-includes\n        if (str.indexOf(AMPERSAND) === -1 && str.indexOf(HASH) === -1) {\n            // eslint-disable-next-line lodash/prefer-includes\n            if (!(encodeEquals && str.indexOf(EQUALS) !== -1)) {\n                return str;\n            }\n        }\n\n        var normalizedString = '',\n            pointer = 0,\n            variable,\n            match,\n            index;\n\n        // find all the instances of {{<variable>}} which includes reserved chars\n        while ((match = REGEX_EXTRACT_VARS_IN_PARAM.exec(str)) !== null) {\n            variable = match[0];\n            index = match.index;\n\n            // [pointer, index) string is normalized + the matched variable\n            normalizedString += encodeReservedChars(str.slice(pointer, index), encodeEquals) + variable;\n\n            // update the pointer\n            pointer = index + variable.length;\n        }\n\n        // whatever left in the string is normalized as well\n        if (pointer < str.length) {\n            normalizedString += encodeReservedChars(str.slice(pointer), encodeEquals);\n        }\n\n        return normalizedString;\n    },\n\n    /**\n     * Unparses a single query param into a string.\n     *\n     * @private\n     * @param {Object} obj - The query parameter object to be unparsed.\n     * @returns {String} - The unparsed query string.\n     */\n    unparseQueryParam = function (obj) {\n        if (!obj) { return E; }\n\n        var key = obj.key,\n            value = obj.value,\n            result;\n\n        if (typeof key === STRING) {\n            result = normalizeParam(key, true);\n        }\n        else {\n            result = E;\n        }\n\n        if (typeof value === STRING) {\n            result += EQUALS + normalizeParam(value);\n        }\n\n        return result;\n    },\n\n    /**\n     * Parses a single query param string into an object.\n     *\n     * @private\n     * @param {String} param - The query parameter string to be parsed.\n     * @returns {Object} - The parsed query object.\n     */\n    parseQueryParam = function (param) {\n        if (param === E) {\n            return { key: null, value: null };\n        }\n\n        var index = _.indexOf(param, EQUALS);\n\n        if (index < 0) {\n            return { key: param, value: null };\n        }\n\n        return {\n            key: param.substr(0, index),\n            value: param.substr(index + 1)\n        };\n    };\n\n/**\n * Tracks replacements done on a string and expose utility to patch replacements.\n *\n * @note due to performance reasons, it doesn't store the original string or\n * perform ops on the string.\n *\n * @private\n * @constructor\n */\nfunction ReplacementTracker () {\n    this.replacements = [];\n    this._offset = 0;\n    this._length = 0;\n}\n\n/**\n * Add new replacement to track.\n *\n * @param {String} value - value being replaced\n * @param {Number} index - index of replacement\n */\nReplacementTracker.prototype.add = function (value, index) {\n    this.replacements.push({\n        value: value,\n        index: index - this._offset\n    });\n\n    this._offset += value.length - 1; // - 1 replaced character\n    this._length++;\n};\n\n/**\n * Returns the total number of replacements.\n *\n * @returns {Number}\n */\nReplacementTracker.prototype.count = function () {\n    return this._length;\n};\n\n/**\n * Finds the lower index of replacement position for a given value using inexact\n * binary search.\n *\n * @param {Number} index - index to search in replacements\n * @returns {Number}\n */\nReplacementTracker.prototype._findLowerIndex = function (index) {\n    var length = this.count(),\n        start = 0,\n        end = length - 1,\n        mid;\n\n    while (start <= end) {\n        mid = (start + end) >> 1; // divide by 2\n\n        if (this.replacements[mid].index >= index) {\n            end = mid - 1;\n        }\n        else {\n            start = mid + 1;\n        }\n    }\n\n    return start >= length ? -1 : start;\n};\n\n/**\n * Patches a given string by apply all the applicable replacements done in the\n * given range.\n *\n * @param {String} input - string to apply replacements on\n * @param {Number} beginIndex - index from where to apply replacements in input\n * @param {Number} endIndex - index until where to apply replacements in input\n * @returns {String}\n */\nReplacementTracker.prototype._applyInString = function (input, beginIndex, endIndex) {\n    var index,\n        replacement,\n        replacementIndex,\n        replacementValue,\n        offset = 0,\n        length = this.count();\n\n    // bail out if no replacements are done in the given range OR empty string\n    if (!input || (index = this._findLowerIndex(beginIndex)) === -1) {\n        return input;\n    }\n\n    do {\n        replacement = this.replacements[index];\n        replacementIndex = replacement.index;\n        replacementValue = replacement.value;\n\n        // bail out if all the replacements are done in the given range\n        if (replacementIndex >= endIndex) {\n            break;\n        }\n\n        replacementIndex = offset + replacementIndex - beginIndex;\n        input = input.slice(0, replacementIndex) + replacementValue + input.slice(replacementIndex + 1);\n        offset += replacementValue.length - 1;\n    } while (++index < length);\n\n    return input;\n};\n\n/**\n * Patches a given string or array of strings by apply all the applicable\n * replacements done in the given range.\n *\n * @param {String|String[]} input - string or splitted string to apply replacements on\n * @param {Number} beginIndex - index from where to apply replacements in input\n * @param {Number} endIndex - index until where to apply replacements in input\n * @returns {String|String[]}\n */\nReplacementTracker.prototype.apply = function (input, beginIndex, endIndex) {\n    var i,\n        ii,\n        length,\n        _endIndex,\n        _beginIndex,\n        value = input;\n\n    // apply replacements in string\n    if (typeof input === STRING) {\n        return this._applyInString(input, beginIndex, endIndex);\n    }\n\n    // apply replacements in the splitted string (Array)\n    _beginIndex = beginIndex;\n\n    // traverse all the segments until all the replacements are patched\n    for (i = 0, ii = input.length; i < ii; ++i) {\n        value = input[i];\n        _endIndex = _beginIndex + (length = value.length);\n\n        // apply replacements applicable for individual segment\n        input[i] = this._applyInString(value, _beginIndex, _endIndex);\n        _beginIndex += length + 1; // + 1 separator\n    }\n\n    return input;\n};\n\n/**\n * Normalize the given string by replacing the variables which includes\n * reserved characters in its name.\n * The replaced characters are added to the given replacement tracker instance.\n *\n * @private\n * @param {String} str - string to normalize\n * @param {ReplacementTracker} replacements - tracker to store replacements\n * @returns {String}\n */\nfunction normalizeVariables (str, replacements) {\n    var normalizedString = E,\n        pointer = 0, // pointer till witch the string is normalized\n        variable,\n        match,\n        index;\n\n    // find all the instances of {{<variable>}} which includes reserved chars\n    // \"Hello {{user#name}}!!!\"\n    //  ↑ (pointer = 0)\n    while ((match = REGEX_EXTRACT_VARS.exec(str)) !== null) {\n        // {{user#name}}\n        variable = match[0];\n\n        // starting index of the {{variable}} in the string\n        // \"Hello {{user#name}}!!!\"\n        //        ↑ (index = 6)\n        index = match.index;\n\n        // [pointer, index) string is normalized + the safe replacement character\n        // \"Hello \" + \"_\"\n        normalizedString += str.slice(pointer, index) + SAFE_REPLACE_CHAR;\n\n        // track the replacement done for the {{variable}}\n        replacements.add(variable, index);\n\n        // update the pointer\n        // \"Hello {{user#name}}!!!\"\n        //                     ↑ (pointer = 19)\n        pointer = index + variable.length;\n    }\n\n    // avoid slicing the string in case of no matches\n    if (pointer === 0) {\n        return str;\n    }\n\n    // whatever left in the string is normalized as well\n    if (pointer < str.length) {\n        // \"Hello _\" + \"!!!\"\n        normalizedString += str.slice(pointer);\n    }\n\n    return normalizedString;\n}\n\n/**\n * Update replaced characters in the URL object with its original value.\n *\n * @private\n * @param {Object} url - url to apply replacements on\n * @param {ReplacementTracker} replacements - tracked replacements\n */\nfunction applyReplacements (url, replacements) {\n    var i,\n        ii,\n        prop;\n\n    // traverse each URL property in the given order\n    for (i = 0, ii = URL_PROPERTIES_ORDER.length; i < ii; ++i) {\n        prop = url[URL_PROPERTIES_ORDER[i]];\n\n        // bail out if the given property is not set (undefined or E)\n        if (!(prop && prop.value)) {\n            continue;\n        }\n\n        prop.value = replacements.apply(prop.value, prop.beginIndex, prop.endIndex);\n    }\n\n    return url;\n}\n\n/**\n * Parses the input string by decomposing the URL into constituent parts,\n * such as path, host, port, etc.\n *\n * @private\n * @param {String} urlString - url string to parse\n * @returns {Object}\n */\nfunction url_parse (urlString) {\n    // trim leading whitespace characters\n    urlString = String(urlString).trimLeft();\n\n    var url = {\n            protocol: { value: undefined, beginIndex: 0, endIndex: 0 },\n            auth: { value: undefined, beginIndex: 0, endIndex: 0 },\n            host: { value: undefined, beginIndex: 0, endIndex: 0 },\n            port: { value: undefined, beginIndex: 0, endIndex: 0 },\n            path: { value: undefined, beginIndex: 0, endIndex: 0 },\n            query: { value: undefined, beginIndex: 0, endIndex: 0 },\n            hash: { value: undefined, beginIndex: 0, endIndex: 0 }\n        },\n        parsedUrl = {\n            raw: urlString,\n            protocol: undefined,\n            auth: undefined,\n            host: undefined,\n            port: undefined,\n            path: undefined,\n            query: undefined,\n            hash: undefined\n        },\n        replacements = new ReplacementTracker(),\n        pointer = 0,\n        length,\n        index,\n        port;\n\n    // bail out if input string is empty\n    if (!urlString) {\n        return parsedUrl;\n    }\n\n    // normalize the given string\n    urlString = normalizeVariables(urlString, replacements);\n    length = urlString.length;\n\n    // 1. url.hash\n    if ((index = urlString.indexOf(HASH)) !== -1) {\n        // extract from the back\n        url.hash.value = urlString.slice(index + 1);\n        url.hash.beginIndex = pointer + index + 1;\n        url.hash.endIndex = pointer + length;\n\n        urlString = urlString.slice(0, (length = index));\n    }\n\n    // 2. url.query\n    if ((index = urlString.indexOf(QUERY_SEPARATOR)) !== -1) {\n        // extract from the back\n        url.query.value = urlString.slice(index + 1).split(AMPERSAND);\n        url.query.beginIndex = pointer + index + 1;\n        url.query.endIndex = pointer + length;\n\n        urlString = urlString.slice(0, (length = index));\n    }\n\n    // 3. url.protocol\n    if ((index = urlString.indexOf(PROTOCOL_SEPARATOR)) !== -1) {\n        // extract from the front\n        url.protocol.value = urlString.slice(0, index);\n        url.protocol.beginIndex = pointer;\n        url.protocol.endIndex = pointer + index;\n\n        urlString = urlString.slice(index + 3);\n        length -= index + 3;\n        pointer += index + 3;\n    }\n    // protocol can be separated using :\\\\ as well\n    else if ((index = urlString.indexOf(PROTOCOL_SEPARATOR_WITH_BACKSLASH)) !== -1) {\n        // extract from the front\n        url.protocol.value = urlString.slice(0, index);\n        url.protocol.beginIndex = pointer;\n        url.protocol.endIndex = pointer + index;\n\n        urlString = urlString.slice(index + 3);\n        length -= index + 3;\n        pointer += index + 3;\n    }\n\n    // 4. url.path\n    urlString = urlString.replace(/\\\\/g, '/'); // sanitize path\n    if ((index = urlString.indexOf(SLASH)) !== -1) {\n        // extract from the back\n        url.path.value = urlString.slice(index + 1).split(SLASH);\n        url.path.beginIndex = pointer + index + 1;\n        url.path.endIndex = pointer + length;\n\n        urlString = urlString.slice(0, (length = index));\n    }\n\n    // 5. url.auth\n    if ((index = urlString.lastIndexOf(AUTH_SEPARATOR)) !== -1) {\n        // extract from the front\n        url.auth.value = urlString.slice(0, index);\n        url.auth.beginIndex = pointer;\n        url.auth.endIndex = pointer + index;\n\n        urlString = urlString.slice(index + 1);\n        length -= index + 1;\n        pointer += index + 1;\n\n        // separate username:password\n        if ((index = url.auth.value.indexOf(COLON)) === -1) {\n            url.auth.value = [url.auth.value];\n        }\n        else {\n            url.auth.value = [url.auth.value.slice(0, index), url.auth.value.slice(index + 1)];\n        }\n    }\n\n    // 6. url.port\n    if ((index = urlString.lastIndexOf(COLON)) !== -1 &&\n        // eslint-disable-next-line lodash/prefer-includes\n        (port = urlString.slice(index + 1)).indexOf(CLOSING_SQUARE_BRACKET) === -1\n    ) {\n        // extract from the back\n        url.port.value = port;\n        url.port.beginIndex = pointer + index + 1;\n        url.port.endIndex = pointer + length;\n\n        urlString = urlString.slice(0, (length = index));\n    }\n\n    // 7. url.host\n    if (urlString) {\n        url.host.value = urlString.split(DOMAIN_SEPARATOR);\n        url.host.beginIndex = pointer;\n        url.host.endIndex = pointer + length;\n    }\n\n    // apply replacements back, if any\n    replacements.count() && applyReplacements(url, replacements);\n\n    // finally, prepare parsed url\n    parsedUrl.protocol = url.protocol.value;\n    parsedUrl.auth = url.auth.value;\n    parsedUrl.host = url.host.value;\n    parsedUrl.port = url.port.value;\n    parsedUrl.path = url.path.value;\n    parsedUrl.query = url.query.value;\n    parsedUrl.hash = url.hash.value;\n\n    return parsedUrl;\n}\n\n/* eslint-disable object-shorthand */\nmodule.exports = {\n    parse: function (url) {\n        if (typeof url !== STRING) {\n            url = '';\n        }\n\n        url = url_parse(url);\n\n        var pathVariables,\n            pathVariableKeys = {};\n\n        if (url.auth) {\n            url.auth = {\n                user: url.auth[0],\n                password: url.auth[1]\n            };\n        }\n\n        if (url.query) {\n            url.query = url.query.map(parseQueryParam);\n        }\n\n        // extract path variables\n        pathVariables = _.transform(url.path, function (res, segment) {\n            // check if the segment has path variable prefix followed by the variable name and\n            // the variable is not already added in the list.\n            if (_.startsWith(segment, COLON) &&\n                segment !== COLON &&\n                !pathVariableKeys[segment]) {\n                pathVariableKeys[segment] = true;\n                res.push({ key: segment.slice(1) }); // remove path variable prefix.\n            }\n        }, []);\n        url.variable = pathVariables.length ? pathVariables : undefined;\n\n        return url;\n    },\n\n    unparse: function (urlObj) {\n        var rawUrl = E,\n            path,\n            queryString,\n            authString,\n            firstEnabledParam = true;\n\n        if (urlObj.protocol) {\n            rawUrl += (_.endsWith(urlObj.protocol, PROTOCOL_SEPARATOR) ?\n                urlObj.protocol : urlObj.protocol + PROTOCOL_SEPARATOR);\n        }\n\n        if (urlObj.auth) {\n            if (typeof urlObj.auth.user === STRING) {\n                authString = urlObj.auth.user;\n            }\n\n            if (typeof urlObj.auth.password === STRING) {\n                !authString && (authString = E);\n                authString += COLON + urlObj.auth.password;\n            }\n\n            if (typeof authString === STRING) {\n                rawUrl += authString + AUTH_SEPARATOR;\n            }\n        }\n\n        if (urlObj.host) {\n            rawUrl += (_.isArray(urlObj.host) ? urlObj.host.join(DOMAIN_SEPARATOR) : urlObj.host.toString());\n        }\n\n        if (typeof _.get(urlObj.port, 'toString') === FUNCTION) {\n            rawUrl += COLON + urlObj.port.toString();\n        }\n\n        if (urlObj.path) {\n            path = (_.isArray(urlObj.path) ? urlObj.path.join(SLASH) : urlObj.path.toString());\n            rawUrl += (_.startsWith(path, SLASH) ? path : SLASH + path);\n        }\n\n        if (urlObj.query && urlObj.query.length) {\n            queryString = _.reduce(urlObj.query, function (accumulator, param) {\n                // ignore disabled params\n                if (!param || param.disabled) {\n                    return accumulator;\n                }\n\n                // don't add '&' for the very first enabled param\n                if (firstEnabledParam) {\n                    firstEnabledParam = false;\n                }\n                // add '&' before concatenating param\n                else {\n                    accumulator += AMPERSAND;\n                }\n\n                return accumulator + unparseQueryParam(param);\n            }, E);\n\n            // either all the params are disabled or a single param is like { key: '' } (http://localhost?)\n            // in that case, query separator ? must be included in the raw URL.\n            if (queryString === E && firstEnabledParam) {\n                // unset querystring if there are no enabled params\n                queryString = undefined;\n            }\n\n            if (typeof queryString === STRING) {\n                rawUrl += QUERY_SEPARATOR + queryString;\n            }\n        }\n\n        if (typeof urlObj.hash === STRING) {\n            rawUrl += HASH + urlObj.hash;\n        }\n\n        return rawUrl;\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,CAAC,GAAGC,OAAO,CAAC,QAAQ,CAAC,CAACC,UAAU,EAAE;EAEpCC,CAAC,GAAG,EAAE;EACNC,IAAI,GAAG,GAAG;EACVC,KAAK,GAAG,GAAG;EACXC,KAAK,GAAG,GAAG;EACXC,MAAM,GAAG,GAAG;EACZC,SAAS,GAAG,GAAG;EACfC,cAAc,GAAG,GAAG;EACpBC,eAAe,GAAG,GAAG;EACrBC,gBAAgB,GAAG,GAAG;EACtBC,kBAAkB,GAAG,KAAK;EAC1BC,iCAAiC,GAAG,OAAO;EAE3CC,MAAM,GAAG,QAAQ;EACjBC,QAAQ,GAAG,UAAU;EACrBC,iBAAiB,GAAG,GAAG;EACvBC,sBAAsB,GAAG,GAAG;EAC5BC,oBAAoB,GAAG,CAAC,UAAU,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,CAAC;EAEpFC,UAAU,GAAG,IAAI;EACjBC,YAAY,GAAG,IAAI;EAAE;EACrBC,eAAe,GAAG,IAAI;EACtBC,kBAAkB,GAAG,8BAA8B;EACnDC,2BAA2B,GAAG,wBAAwB;EAEtD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,mBAAmB,GAAG,UAAUC,GAAG,EAAEC,YAAY,EAAE;IAC/C,IAAI,CAACD,GAAG,EAAE;MACN,OAAOA,GAAG;IACd;;IAEA;IACAA,GAAG,CAACE,OAAO,CAACnB,SAAS,CAAC,KAAK,CAAC,CAAC,KAAKiB,GAAG,GAAGA,GAAG,CAACG,OAAO,CAACP,eAAe,EAAE,KAAK,CAAC,CAAC;;IAE5E;IACAI,GAAG,CAACE,OAAO,CAACvB,IAAI,CAAC,KAAK,CAAC,CAAC,KAAKqB,GAAG,GAAGA,GAAG,CAACG,OAAO,CAACT,UAAU,EAAE,KAAK,CAAC,CAAC;;IAElE;IACAO,YAAY,IAAID,GAAG,CAACE,OAAO,CAACpB,MAAM,CAAC,KAAK,CAAC,CAAC,KAAKkB,GAAG,GAAGA,GAAG,CAACG,OAAO,CAACR,YAAY,EAAE,KAAK,CAAC,CAAC;IAEtF,OAAOK,GAAG;EACd,CAAC;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACII,cAAc,GAAG,UAAUJ,GAAG,EAAEC,YAAY,EAAE;IAC1C;IACA,IAAI,EAAED,GAAG,IAAI,OAAOA,GAAG,KAAKX,MAAM,CAAC,EAAE;MACjC,OAAOW,GAAG;IACd;;IAEA;IACA;IACA,IAAIA,GAAG,CAACE,OAAO,CAACnB,SAAS,CAAC,KAAK,CAAC,CAAC,IAAIiB,GAAG,CAACE,OAAO,CAACvB,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;MAC3D;MACA,IAAI,EAAEsB,YAAY,IAAID,GAAG,CAACE,OAAO,CAACpB,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;QAC/C,OAAOkB,GAAG;MACd;IACJ;IAEA,IAAIK,gBAAgB,GAAG,EAAE;MACrBC,OAAO,GAAG,CAAC;MACXC,QAAQ;MACRC,KAAK;MACLC,KAAK;;IAET;IACA,OAAO,CAACD,KAAK,GAAGV,2BAA2B,CAACY,IAAI,CAACV,GAAG,CAAC,MAAM,IAAI,EAAE;MAC7DO,QAAQ,GAAGC,KAAK,CAAC,CAAC,CAAC;MACnBC,KAAK,GAAGD,KAAK,CAACC,KAAK;;MAEnB;MACAJ,gBAAgB,IAAIN,mBAAmB,CAACC,GAAG,CAACW,KAAK,CAACL,OAAO,EAAEG,KAAK,CAAC,EAAER,YAAY,CAAC,GAAGM,QAAQ;;MAE3F;MACAD,OAAO,GAAGG,KAAK,GAAGF,QAAQ,CAACK,MAAM;IACrC;;IAEA;IACA,IAAIN,OAAO,GAAGN,GAAG,CAACY,MAAM,EAAE;MACtBP,gBAAgB,IAAIN,mBAAmB,CAACC,GAAG,CAACW,KAAK,CAACL,OAAO,CAAC,EAAEL,YAAY,CAAC;IAC7E;IAEA,OAAOI,gBAAgB;EAC3B,CAAC;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;EACIQ,iBAAiB,GAAG,UAAUC,GAAG,EAAE;IAC/B,IAAI,CAACA,GAAG,EAAE;MAAE,OAAOpC,CAAC;IAAE;IAEtB,IAAIqC,GAAG,GAAGD,GAAG,CAACC,GAAG;MACbC,KAAK,GAAGF,GAAG,CAACE,KAAK;MACjBC,MAAM;IAEV,IAAI,OAAOF,GAAG,KAAK1B,MAAM,EAAE;MACvB4B,MAAM,GAAGb,cAAc,CAACW,GAAG,EAAE,IAAI,CAAC;IACtC,CAAC,MACI;MACDE,MAAM,GAAGvC,CAAC;IACd;IAEA,IAAI,OAAOsC,KAAK,KAAK3B,MAAM,EAAE;MACzB4B,MAAM,IAAInC,MAAM,GAAGsB,cAAc,CAACY,KAAK,CAAC;IAC5C;IAEA,OAAOC,MAAM;EACjB,CAAC;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;EACIC,eAAe,GAAG,UAAUC,KAAK,EAAE;IAC/B,IAAIA,KAAK,KAAKzC,CAAC,EAAE;MACb,OAAO;QAAEqC,GAAG,EAAE,IAAI;QAAEC,KAAK,EAAE;MAAK,CAAC;IACrC;IAEA,IAAIP,KAAK,GAAGlC,CAAC,CAAC2B,OAAO,CAACiB,KAAK,EAAErC,MAAM,CAAC;IAEpC,IAAI2B,KAAK,GAAG,CAAC,EAAE;MACX,OAAO;QAAEM,GAAG,EAAEI,KAAK;QAAEH,KAAK,EAAE;MAAK,CAAC;IACtC;IAEA,OAAO;MACHD,GAAG,EAAEI,KAAK,CAACC,MAAM,CAAC,CAAC,EAAEX,KAAK,CAAC;MAC3BO,KAAK,EAAEG,KAAK,CAACC,MAAM,CAACX,KAAK,GAAG,CAAC;IACjC,CAAC;EACL,CAAC;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASY,kBAAkB,GAAI;EAC3B,IAAI,CAACC,YAAY,GAAG,EAAE;EACtB,IAAI,CAACC,OAAO,GAAG,CAAC;EAChB,IAAI,CAACC,OAAO,GAAG,CAAC;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACAH,kBAAkB,CAACI,SAAS,CAACC,GAAG,GAAG,UAAUV,KAAK,EAAEP,KAAK,EAAE;EACvD,IAAI,CAACa,YAAY,CAACK,IAAI,CAAC;IACnBX,KAAK,EAAEA,KAAK;IACZP,KAAK,EAAEA,KAAK,GAAG,IAAI,CAACc;EACxB,CAAC,CAAC;EAEF,IAAI,CAACA,OAAO,IAAIP,KAAK,CAACJ,MAAM,GAAG,CAAC,CAAC,CAAC;EAClC,IAAI,CAACY,OAAO,EAAE;AAClB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAH,kBAAkB,CAACI,SAAS,CAACG,KAAK,GAAG,YAAY;EAC7C,OAAO,IAAI,CAACJ,OAAO;AACvB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAH,kBAAkB,CAACI,SAAS,CAACI,eAAe,GAAG,UAAUpB,KAAK,EAAE;EAC5D,IAAIG,MAAM,GAAG,IAAI,CAACgB,KAAK,EAAE;IACrBE,KAAK,GAAG,CAAC;IACTC,GAAG,GAAGnB,MAAM,GAAG,CAAC;IAChBoB,GAAG;EAEP,OAAOF,KAAK,IAAIC,GAAG,EAAE;IACjBC,GAAG,GAAIF,KAAK,GAAGC,GAAG,IAAK,CAAC,CAAC,CAAC;;IAE1B,IAAI,IAAI,CAACT,YAAY,CAACU,GAAG,CAAC,CAACvB,KAAK,IAAIA,KAAK,EAAE;MACvCsB,GAAG,GAAGC,GAAG,GAAG,CAAC;IACjB,CAAC,MACI;MACDF,KAAK,GAAGE,GAAG,GAAG,CAAC;IACnB;EACJ;EAEA,OAAOF,KAAK,IAAIlB,MAAM,GAAG,CAAC,CAAC,GAAGkB,KAAK;AACvC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAT,kBAAkB,CAACI,SAAS,CAACQ,cAAc,GAAG,UAAUC,KAAK,EAAEC,UAAU,EAAEC,QAAQ,EAAE;EACjF,IAAI3B,KAAK;IACL4B,WAAW;IACXC,gBAAgB;IAChBC,gBAAgB;IAChBC,MAAM,GAAG,CAAC;IACV5B,MAAM,GAAG,IAAI,CAACgB,KAAK,EAAE;;EAEzB;EACA,IAAI,CAACM,KAAK,IAAI,CAACzB,KAAK,GAAG,IAAI,CAACoB,eAAe,CAACM,UAAU,CAAC,MAAM,CAAC,CAAC,EAAE;IAC7D,OAAOD,KAAK;EAChB;EAEA,GAAG;IACCG,WAAW,GAAG,IAAI,CAACf,YAAY,CAACb,KAAK,CAAC;IACtC6B,gBAAgB,GAAGD,WAAW,CAAC5B,KAAK;IACpC8B,gBAAgB,GAAGF,WAAW,CAACrB,KAAK;;IAEpC;IACA,IAAIsB,gBAAgB,IAAIF,QAAQ,EAAE;MAC9B;IACJ;IAEAE,gBAAgB,GAAGE,MAAM,GAAGF,gBAAgB,GAAGH,UAAU;IACzDD,KAAK,GAAGA,KAAK,CAACvB,KAAK,CAAC,CAAC,EAAE2B,gBAAgB,CAAC,GAAGC,gBAAgB,GAAGL,KAAK,CAACvB,KAAK,CAAC2B,gBAAgB,GAAG,CAAC,CAAC;IAC/FE,MAAM,IAAID,gBAAgB,CAAC3B,MAAM,GAAG,CAAC;EACzC,CAAC,QAAQ,EAAEH,KAAK,GAAGG,MAAM;EAEzB,OAAOsB,KAAK;AAChB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAb,kBAAkB,CAACI,SAAS,CAACgB,KAAK,GAAG,UAAUP,KAAK,EAAEC,UAAU,EAAEC,QAAQ,EAAE;EACxE,IAAIM,CAAC;IACDC,EAAE;IACF/B,MAAM;IACNgC,SAAS;IACTC,WAAW;IACX7B,KAAK,GAAGkB,KAAK;;EAEjB;EACA,IAAI,OAAOA,KAAK,KAAK7C,MAAM,EAAE;IACzB,OAAO,IAAI,CAAC4C,cAAc,CAACC,KAAK,EAAEC,UAAU,EAAEC,QAAQ,CAAC;EAC3D;;EAEA;EACAS,WAAW,GAAGV,UAAU;;EAExB;EACA,KAAKO,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGT,KAAK,CAACtB,MAAM,EAAE8B,CAAC,GAAGC,EAAE,EAAE,EAAED,CAAC,EAAE;IACxC1B,KAAK,GAAGkB,KAAK,CAACQ,CAAC,CAAC;IAChBE,SAAS,GAAGC,WAAW,IAAIjC,MAAM,GAAGI,KAAK,CAACJ,MAAM,CAAC;;IAEjD;IACAsB,KAAK,CAACQ,CAAC,CAAC,GAAG,IAAI,CAACT,cAAc,CAACjB,KAAK,EAAE6B,WAAW,EAAED,SAAS,CAAC;IAC7DC,WAAW,IAAIjC,MAAM,GAAG,CAAC,CAAC,CAAC;EAC/B;;EAEA,OAAOsB,KAAK;AAChB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASY,kBAAkB,CAAE9C,GAAG,EAAEsB,YAAY,EAAE;EAC5C,IAAIjB,gBAAgB,GAAG3B,CAAC;IACpB4B,OAAO,GAAG,CAAC;IAAE;IACbC,QAAQ;IACRC,KAAK;IACLC,KAAK;;EAET;EACA;EACA;EACA,OAAO,CAACD,KAAK,GAAGX,kBAAkB,CAACa,IAAI,CAACV,GAAG,CAAC,MAAM,IAAI,EAAE;IACpD;IACAO,QAAQ,GAAGC,KAAK,CAAC,CAAC,CAAC;;IAEnB;IACA;IACA;IACAC,KAAK,GAAGD,KAAK,CAACC,KAAK;;IAEnB;IACA;IACAJ,gBAAgB,IAAIL,GAAG,CAACW,KAAK,CAACL,OAAO,EAAEG,KAAK,CAAC,GAAGlB,iBAAiB;;IAEjE;IACA+B,YAAY,CAACI,GAAG,CAACnB,QAAQ,EAAEE,KAAK,CAAC;;IAEjC;IACA;IACA;IACAH,OAAO,GAAGG,KAAK,GAAGF,QAAQ,CAACK,MAAM;EACrC;;EAEA;EACA,IAAIN,OAAO,KAAK,CAAC,EAAE;IACf,OAAON,GAAG;EACd;;EAEA;EACA,IAAIM,OAAO,GAAGN,GAAG,CAACY,MAAM,EAAE;IACtB;IACAP,gBAAgB,IAAIL,GAAG,CAACW,KAAK,CAACL,OAAO,CAAC;EAC1C;EAEA,OAAOD,gBAAgB;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS0C,iBAAiB,CAAEC,GAAG,EAAE1B,YAAY,EAAE;EAC3C,IAAIoB,CAAC,EACDC,EAAE,EACFM,IAAI;;EAER;EACA,KAAKP,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGlD,oBAAoB,CAACmB,MAAM,EAAE8B,CAAC,GAAGC,EAAE,EAAE,EAAED,CAAC,EAAE;IACvDO,IAAI,GAAGD,GAAG,CAACvD,oBAAoB,CAACiD,CAAC,CAAC,CAAC;;IAEnC;IACA,IAAI,EAAEO,IAAI,IAAIA,IAAI,CAACjC,KAAK,CAAC,EAAE;MACvB;IACJ;IAEAiC,IAAI,CAACjC,KAAK,GAAGM,YAAY,CAACmB,KAAK,CAACQ,IAAI,CAACjC,KAAK,EAAEiC,IAAI,CAACd,UAAU,EAAEc,IAAI,CAACb,QAAQ,CAAC;EAC/E;EAEA,OAAOY,GAAG;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,SAAS,CAAEC,SAAS,EAAE;EAC3B;EACAA,SAAS,GAAGC,MAAM,CAACD,SAAS,CAAC,CAACE,QAAQ,EAAE;EAExC,IAAIL,GAAG,GAAG;MACFM,QAAQ,EAAE;QAAEtC,KAAK,EAAEuC,SAAS;QAAEpB,UAAU,EAAE,CAAC;QAAEC,QAAQ,EAAE;MAAE,CAAC;MAC1DoB,IAAI,EAAE;QAAExC,KAAK,EAAEuC,SAAS;QAAEpB,UAAU,EAAE,CAAC;QAAEC,QAAQ,EAAE;MAAE,CAAC;MACtDqB,IAAI,EAAE;QAAEzC,KAAK,EAAEuC,SAAS;QAAEpB,UAAU,EAAE,CAAC;QAAEC,QAAQ,EAAE;MAAE,CAAC;MACtDsB,IAAI,EAAE;QAAE1C,KAAK,EAAEuC,SAAS;QAAEpB,UAAU,EAAE,CAAC;QAAEC,QAAQ,EAAE;MAAE,CAAC;MACtDuB,IAAI,EAAE;QAAE3C,KAAK,EAAEuC,SAAS;QAAEpB,UAAU,EAAE,CAAC;QAAEC,QAAQ,EAAE;MAAE,CAAC;MACtDwB,KAAK,EAAE;QAAE5C,KAAK,EAAEuC,SAAS;QAAEpB,UAAU,EAAE,CAAC;QAAEC,QAAQ,EAAE;MAAE,CAAC;MACvDyB,IAAI,EAAE;QAAE7C,KAAK,EAAEuC,SAAS;QAAEpB,UAAU,EAAE,CAAC;QAAEC,QAAQ,EAAE;MAAE;IACzD,CAAC;IACD0B,SAAS,GAAG;MACRC,GAAG,EAAEZ,SAAS;MACdG,QAAQ,EAAEC,SAAS;MACnBC,IAAI,EAAED,SAAS;MACfE,IAAI,EAAEF,SAAS;MACfG,IAAI,EAAEH,SAAS;MACfI,IAAI,EAAEJ,SAAS;MACfK,KAAK,EAAEL,SAAS;MAChBM,IAAI,EAAEN;IACV,CAAC;IACDjC,YAAY,GAAG,IAAID,kBAAkB,EAAE;IACvCf,OAAO,GAAG,CAAC;IACXM,MAAM;IACNH,KAAK;IACLiD,IAAI;;EAER;EACA,IAAI,CAACP,SAAS,EAAE;IACZ,OAAOW,SAAS;EACpB;;EAEA;EACAX,SAAS,GAAGL,kBAAkB,CAACK,SAAS,EAAE7B,YAAY,CAAC;EACvDV,MAAM,GAAGuC,SAAS,CAACvC,MAAM;;EAEzB;EACA,IAAI,CAACH,KAAK,GAAG0C,SAAS,CAACjD,OAAO,CAACvB,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE;IAC1C;IACAqE,GAAG,CAACa,IAAI,CAAC7C,KAAK,GAAGmC,SAAS,CAACxC,KAAK,CAACF,KAAK,GAAG,CAAC,CAAC;IAC3CuC,GAAG,CAACa,IAAI,CAAC1B,UAAU,GAAG7B,OAAO,GAAGG,KAAK,GAAG,CAAC;IACzCuC,GAAG,CAACa,IAAI,CAACzB,QAAQ,GAAG9B,OAAO,GAAGM,MAAM;IAEpCuC,SAAS,GAAGA,SAAS,CAACxC,KAAK,CAAC,CAAC,EAAGC,MAAM,GAAGH,KAAK,CAAE;EACpD;;EAEA;EACA,IAAI,CAACA,KAAK,GAAG0C,SAAS,CAACjD,OAAO,CAACjB,eAAe,CAAC,MAAM,CAAC,CAAC,EAAE;IACrD;IACA+D,GAAG,CAACY,KAAK,CAAC5C,KAAK,GAAGmC,SAAS,CAACxC,KAAK,CAACF,KAAK,GAAG,CAAC,CAAC,CAACuD,KAAK,CAACjF,SAAS,CAAC;IAC7DiE,GAAG,CAACY,KAAK,CAACzB,UAAU,GAAG7B,OAAO,GAAGG,KAAK,GAAG,CAAC;IAC1CuC,GAAG,CAACY,KAAK,CAACxB,QAAQ,GAAG9B,OAAO,GAAGM,MAAM;IAErCuC,SAAS,GAAGA,SAAS,CAACxC,KAAK,CAAC,CAAC,EAAGC,MAAM,GAAGH,KAAK,CAAE;EACpD;;EAEA;EACA,IAAI,CAACA,KAAK,GAAG0C,SAAS,CAACjD,OAAO,CAACf,kBAAkB,CAAC,MAAM,CAAC,CAAC,EAAE;IACxD;IACA6D,GAAG,CAACM,QAAQ,CAACtC,KAAK,GAAGmC,SAAS,CAACxC,KAAK,CAAC,CAAC,EAAEF,KAAK,CAAC;IAC9CuC,GAAG,CAACM,QAAQ,CAACnB,UAAU,GAAG7B,OAAO;IACjC0C,GAAG,CAACM,QAAQ,CAAClB,QAAQ,GAAG9B,OAAO,GAAGG,KAAK;IAEvC0C,SAAS,GAAGA,SAAS,CAACxC,KAAK,CAACF,KAAK,GAAG,CAAC,CAAC;IACtCG,MAAM,IAAIH,KAAK,GAAG,CAAC;IACnBH,OAAO,IAAIG,KAAK,GAAG,CAAC;EACxB;EACA;EAAA,KACK,IAAI,CAACA,KAAK,GAAG0C,SAAS,CAACjD,OAAO,CAACd,iCAAiC,CAAC,MAAM,CAAC,CAAC,EAAE;IAC5E;IACA4D,GAAG,CAACM,QAAQ,CAACtC,KAAK,GAAGmC,SAAS,CAACxC,KAAK,CAAC,CAAC,EAAEF,KAAK,CAAC;IAC9CuC,GAAG,CAACM,QAAQ,CAACnB,UAAU,GAAG7B,OAAO;IACjC0C,GAAG,CAACM,QAAQ,CAAClB,QAAQ,GAAG9B,OAAO,GAAGG,KAAK;IAEvC0C,SAAS,GAAGA,SAAS,CAACxC,KAAK,CAACF,KAAK,GAAG,CAAC,CAAC;IACtCG,MAAM,IAAIH,KAAK,GAAG,CAAC;IACnBH,OAAO,IAAIG,KAAK,GAAG,CAAC;EACxB;;EAEA;EACA0C,SAAS,GAAGA,SAAS,CAAChD,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC,CAAC;EAC3C,IAAI,CAACM,KAAK,GAAG0C,SAAS,CAACjD,OAAO,CAACtB,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE;IAC3C;IACAoE,GAAG,CAACW,IAAI,CAAC3C,KAAK,GAAGmC,SAAS,CAACxC,KAAK,CAACF,KAAK,GAAG,CAAC,CAAC,CAACuD,KAAK,CAACpF,KAAK,CAAC;IACxDoE,GAAG,CAACW,IAAI,CAACxB,UAAU,GAAG7B,OAAO,GAAGG,KAAK,GAAG,CAAC;IACzCuC,GAAG,CAACW,IAAI,CAACvB,QAAQ,GAAG9B,OAAO,GAAGM,MAAM;IAEpCuC,SAAS,GAAGA,SAAS,CAACxC,KAAK,CAAC,CAAC,EAAGC,MAAM,GAAGH,KAAK,CAAE;EACpD;;EAEA;EACA,IAAI,CAACA,KAAK,GAAG0C,SAAS,CAACc,WAAW,CAACjF,cAAc,CAAC,MAAM,CAAC,CAAC,EAAE;IACxD;IACAgE,GAAG,CAACQ,IAAI,CAACxC,KAAK,GAAGmC,SAAS,CAACxC,KAAK,CAAC,CAAC,EAAEF,KAAK,CAAC;IAC1CuC,GAAG,CAACQ,IAAI,CAACrB,UAAU,GAAG7B,OAAO;IAC7B0C,GAAG,CAACQ,IAAI,CAACpB,QAAQ,GAAG9B,OAAO,GAAGG,KAAK;IAEnC0C,SAAS,GAAGA,SAAS,CAACxC,KAAK,CAACF,KAAK,GAAG,CAAC,CAAC;IACtCG,MAAM,IAAIH,KAAK,GAAG,CAAC;IACnBH,OAAO,IAAIG,KAAK,GAAG,CAAC;;IAEpB;IACA,IAAI,CAACA,KAAK,GAAGuC,GAAG,CAACQ,IAAI,CAACxC,KAAK,CAACd,OAAO,CAACrB,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE;MAChDmE,GAAG,CAACQ,IAAI,CAACxC,KAAK,GAAG,CAACgC,GAAG,CAACQ,IAAI,CAACxC,KAAK,CAAC;IACrC,CAAC,MACI;MACDgC,GAAG,CAACQ,IAAI,CAACxC,KAAK,GAAG,CAACgC,GAAG,CAACQ,IAAI,CAACxC,KAAK,CAACL,KAAK,CAAC,CAAC,EAAEF,KAAK,CAAC,EAAEuC,GAAG,CAACQ,IAAI,CAACxC,KAAK,CAACL,KAAK,CAACF,KAAK,GAAG,CAAC,CAAC,CAAC;IACtF;EACJ;;EAEA;EACA,IAAI,CAACA,KAAK,GAAG0C,SAAS,CAACc,WAAW,CAACpF,KAAK,CAAC,MAAM,CAAC,CAAC;EAC7C;EACA,CAAC6E,IAAI,GAAGP,SAAS,CAACxC,KAAK,CAACF,KAAK,GAAG,CAAC,CAAC,EAAEP,OAAO,CAACV,sBAAsB,CAAC,KAAK,CAAC,CAAC,EAC5E;IACE;IACAwD,GAAG,CAACU,IAAI,CAAC1C,KAAK,GAAG0C,IAAI;IACrBV,GAAG,CAACU,IAAI,CAACvB,UAAU,GAAG7B,OAAO,GAAGG,KAAK,GAAG,CAAC;IACzCuC,GAAG,CAACU,IAAI,CAACtB,QAAQ,GAAG9B,OAAO,GAAGM,MAAM;IAEpCuC,SAAS,GAAGA,SAAS,CAACxC,KAAK,CAAC,CAAC,EAAGC,MAAM,GAAGH,KAAK,CAAE;EACpD;;EAEA;EACA,IAAI0C,SAAS,EAAE;IACXH,GAAG,CAACS,IAAI,CAACzC,KAAK,GAAGmC,SAAS,CAACa,KAAK,CAAC9E,gBAAgB,CAAC;IAClD8D,GAAG,CAACS,IAAI,CAACtB,UAAU,GAAG7B,OAAO;IAC7B0C,GAAG,CAACS,IAAI,CAACrB,QAAQ,GAAG9B,OAAO,GAAGM,MAAM;EACxC;;EAEA;EACAU,YAAY,CAACM,KAAK,EAAE,IAAImB,iBAAiB,CAACC,GAAG,EAAE1B,YAAY,CAAC;;EAE5D;EACAwC,SAAS,CAACR,QAAQ,GAAGN,GAAG,CAACM,QAAQ,CAACtC,KAAK;EACvC8C,SAAS,CAACN,IAAI,GAAGR,GAAG,CAACQ,IAAI,CAACxC,KAAK;EAC/B8C,SAAS,CAACL,IAAI,GAAGT,GAAG,CAACS,IAAI,CAACzC,KAAK;EAC/B8C,SAAS,CAACJ,IAAI,GAAGV,GAAG,CAACU,IAAI,CAAC1C,KAAK;EAC/B8C,SAAS,CAACH,IAAI,GAAGX,GAAG,CAACW,IAAI,CAAC3C,KAAK;EAC/B8C,SAAS,CAACF,KAAK,GAAGZ,GAAG,CAACY,KAAK,CAAC5C,KAAK;EACjC8C,SAAS,CAACD,IAAI,GAAGb,GAAG,CAACa,IAAI,CAAC7C,KAAK;EAE/B,OAAO8C,SAAS;AACpB;;AAEA;AACAI,MAAM,CAACC,OAAO,GAAG;EACbC,KAAK,EAAE,UAAUpB,GAAG,EAAE;IAClB,IAAI,OAAOA,GAAG,KAAK3D,MAAM,EAAE;MACvB2D,GAAG,GAAG,EAAE;IACZ;IAEAA,GAAG,GAAGE,SAAS,CAACF,GAAG,CAAC;IAEpB,IAAIqB,aAAa;MACbC,gBAAgB,GAAG,CAAC,CAAC;IAEzB,IAAItB,GAAG,CAACQ,IAAI,EAAE;MACVR,GAAG,CAACQ,IAAI,GAAG;QACPe,IAAI,EAAEvB,GAAG,CAACQ,IAAI,CAAC,CAAC,CAAC;QACjBgB,QAAQ,EAAExB,GAAG,CAACQ,IAAI,CAAC,CAAC;MACxB,CAAC;IACL;IAEA,IAAIR,GAAG,CAACY,KAAK,EAAE;MACXZ,GAAG,CAACY,KAAK,GAAGZ,GAAG,CAACY,KAAK,CAACa,GAAG,CAACvD,eAAe,CAAC;IAC9C;;IAEA;IACAmD,aAAa,GAAG9F,CAAC,CAACmG,SAAS,CAAC1B,GAAG,CAACW,IAAI,EAAE,UAAUgB,GAAG,EAAEC,OAAO,EAAE;MAC1D;MACA;MACA,IAAIrG,CAAC,CAACsG,UAAU,CAACD,OAAO,EAAE/F,KAAK,CAAC,IAC5B+F,OAAO,KAAK/F,KAAK,IACjB,CAACyF,gBAAgB,CAACM,OAAO,CAAC,EAAE;QAC5BN,gBAAgB,CAACM,OAAO,CAAC,GAAG,IAAI;QAChCD,GAAG,CAAChD,IAAI,CAAC;UAAEZ,GAAG,EAAE6D,OAAO,CAACjE,KAAK,CAAC,CAAC;QAAE,CAAC,CAAC,CAAC,CAAC;MACzC;IACJ,CAAC,EAAE,EAAE,CAAC;IACNqC,GAAG,CAACzC,QAAQ,GAAG8D,aAAa,CAACzD,MAAM,GAAGyD,aAAa,GAAGd,SAAS;IAE/D,OAAOP,GAAG;EACd,CAAC;EAED8B,OAAO,EAAE,UAAUC,MAAM,EAAE;IACvB,IAAIC,MAAM,GAAGtG,CAAC;MACViF,IAAI;MACJsB,WAAW;MACXC,UAAU;MACVC,iBAAiB,GAAG,IAAI;IAE5B,IAAIJ,MAAM,CAACzB,QAAQ,EAAE;MACjB0B,MAAM,IAAKzG,CAAC,CAAC6G,QAAQ,CAACL,MAAM,CAACzB,QAAQ,EAAEnE,kBAAkB,CAAC,GACtD4F,MAAM,CAACzB,QAAQ,GAAGyB,MAAM,CAACzB,QAAQ,GAAGnE,kBAAmB;IAC/D;IAEA,IAAI4F,MAAM,CAACvB,IAAI,EAAE;MACb,IAAI,OAAOuB,MAAM,CAACvB,IAAI,CAACe,IAAI,KAAKlF,MAAM,EAAE;QACpC6F,UAAU,GAAGH,MAAM,CAACvB,IAAI,CAACe,IAAI;MACjC;MAEA,IAAI,OAAOQ,MAAM,CAACvB,IAAI,CAACgB,QAAQ,KAAKnF,MAAM,EAAE;QACxC,CAAC6F,UAAU,KAAKA,UAAU,GAAGxG,CAAC,CAAC;QAC/BwG,UAAU,IAAIrG,KAAK,GAAGkG,MAAM,CAACvB,IAAI,CAACgB,QAAQ;MAC9C;MAEA,IAAI,OAAOU,UAAU,KAAK7F,MAAM,EAAE;QAC9B2F,MAAM,IAAIE,UAAU,GAAGlG,cAAc;MACzC;IACJ;IAEA,IAAI+F,MAAM,CAACtB,IAAI,EAAE;MACbuB,MAAM,IAAKzG,CAAC,CAAC8G,OAAO,CAACN,MAAM,CAACtB,IAAI,CAAC,GAAGsB,MAAM,CAACtB,IAAI,CAAC6B,IAAI,CAACpG,gBAAgB,CAAC,GAAG6F,MAAM,CAACtB,IAAI,CAAC8B,QAAQ,EAAG;IACpG;IAEA,IAAI,OAAOhH,CAAC,CAACiH,GAAG,CAACT,MAAM,CAACrB,IAAI,EAAE,UAAU,CAAC,KAAKpE,QAAQ,EAAE;MACpD0F,MAAM,IAAInG,KAAK,GAAGkG,MAAM,CAACrB,IAAI,CAAC6B,QAAQ,EAAE;IAC5C;IAEA,IAAIR,MAAM,CAACpB,IAAI,EAAE;MACbA,IAAI,GAAIpF,CAAC,CAAC8G,OAAO,CAACN,MAAM,CAACpB,IAAI,CAAC,GAAGoB,MAAM,CAACpB,IAAI,CAAC2B,IAAI,CAAC1G,KAAK,CAAC,GAAGmG,MAAM,CAACpB,IAAI,CAAC4B,QAAQ,EAAG;MAClFP,MAAM,IAAKzG,CAAC,CAACsG,UAAU,CAAClB,IAAI,EAAE/E,KAAK,CAAC,GAAG+E,IAAI,GAAG/E,KAAK,GAAG+E,IAAK;IAC/D;IAEA,IAAIoB,MAAM,CAACnB,KAAK,IAAImB,MAAM,CAACnB,KAAK,CAAChD,MAAM,EAAE;MACrCqE,WAAW,GAAG1G,CAAC,CAACkH,MAAM,CAACV,MAAM,CAACnB,KAAK,EAAE,UAAU8B,WAAW,EAAEvE,KAAK,EAAE;QAC/D;QACA,IAAI,CAACA,KAAK,IAAIA,KAAK,CAACwE,QAAQ,EAAE;UAC1B,OAAOD,WAAW;QACtB;;QAEA;QACA,IAAIP,iBAAiB,EAAE;UACnBA,iBAAiB,GAAG,KAAK;QAC7B;QACA;QAAA,KACK;UACDO,WAAW,IAAI3G,SAAS;QAC5B;QAEA,OAAO2G,WAAW,GAAG7E,iBAAiB,CAACM,KAAK,CAAC;MACjD,CAAC,EAAEzC,CAAC,CAAC;;MAEL;MACA;MACA,IAAIuG,WAAW,KAAKvG,CAAC,IAAIyG,iBAAiB,EAAE;QACxC;QACAF,WAAW,GAAG1B,SAAS;MAC3B;MAEA,IAAI,OAAO0B,WAAW,KAAK5F,MAAM,EAAE;QAC/B2F,MAAM,IAAI/F,eAAe,GAAGgG,WAAW;MAC3C;IACJ;IAEA,IAAI,OAAOF,MAAM,CAAClB,IAAI,KAAKxE,MAAM,EAAE;MAC/B2F,MAAM,IAAIrG,IAAI,GAAGoG,MAAM,CAAClB,IAAI;IAChC;IAEA,OAAOmB,MAAM;EACjB;AACJ,CAAC"},"metadata":{},"sourceType":"script"}