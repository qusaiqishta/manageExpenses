{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\nvar _exception = require('../exception');\nvar _exception2 = _interopRequireDefault(_exception);\nfunction Visitor() {\n  this.parents = [];\n}\nVisitor.prototype = {\n  constructor: Visitor,\n  mutating: false,\n  // Visits a given value. If mutating, will replace the value if necessary.\n  acceptKey: function acceptKey(node, name) {\n    var value = this.accept(node[name]);\n    if (this.mutating) {\n      // Hacky sanity check: This may have a few false positives for type for the helper\n      // methods but will generally do the right thing without a lot of overhead.\n      if (value && !Visitor.prototype[value.type]) {\n        throw new _exception2['default']('Unexpected node type \"' + value.type + '\" found when accepting ' + name + ' on ' + node.type);\n      }\n      node[name] = value;\n    }\n  },\n  // Performs an accept operation with added sanity check to ensure\n  // required keys are not removed.\n  acceptRequired: function acceptRequired(node, name) {\n    this.acceptKey(node, name);\n    if (!node[name]) {\n      throw new _exception2['default'](node.type + ' requires ' + name);\n    }\n  },\n  // Traverses a given array. If mutating, empty respnses will be removed\n  // for child elements.\n  acceptArray: function acceptArray(array) {\n    for (var i = 0, l = array.length; i < l; i++) {\n      this.acceptKey(array, i);\n      if (!array[i]) {\n        array.splice(i, 1);\n        i--;\n        l--;\n      }\n    }\n  },\n  accept: function accept(object) {\n    if (!object) {\n      return;\n    }\n\n    /* istanbul ignore next: Sanity code */\n    if (!this[object.type]) {\n      throw new _exception2['default']('Unknown type: ' + object.type, object);\n    }\n    if (this.current) {\n      this.parents.unshift(this.current);\n    }\n    this.current = object;\n    var ret = this[object.type](object);\n    this.current = this.parents.shift();\n    if (!this.mutating || ret) {\n      return ret;\n    } else if (ret !== false) {\n      return object;\n    }\n  },\n  Program: function Program(program) {\n    this.acceptArray(program.body);\n  },\n  MustacheStatement: visitSubExpression,\n  Decorator: visitSubExpression,\n  BlockStatement: visitBlock,\n  DecoratorBlock: visitBlock,\n  PartialStatement: visitPartial,\n  PartialBlockStatement: function PartialBlockStatement(partial) {\n    visitPartial.call(this, partial);\n    this.acceptKey(partial, 'program');\n  },\n  ContentStatement: function ContentStatement() /* content */{},\n  CommentStatement: function CommentStatement() /* comment */{},\n  SubExpression: visitSubExpression,\n  PathExpression: function PathExpression() /* path */{},\n  StringLiteral: function StringLiteral() /* string */{},\n  NumberLiteral: function NumberLiteral() /* number */{},\n  BooleanLiteral: function BooleanLiteral() /* bool */{},\n  UndefinedLiteral: function UndefinedLiteral() /* literal */{},\n  NullLiteral: function NullLiteral() /* literal */{},\n  Hash: function Hash(hash) {\n    this.acceptArray(hash.pairs);\n  },\n  HashPair: function HashPair(pair) {\n    this.acceptRequired(pair, 'value');\n  }\n};\nfunction visitSubExpression(mustache) {\n  this.acceptRequired(mustache, 'path');\n  this.acceptArray(mustache.params);\n  this.acceptKey(mustache, 'hash');\n}\nfunction visitBlock(block) {\n  visitSubExpression.call(this, block);\n  this.acceptKey(block, 'program');\n  this.acceptKey(block, 'inverse');\n}\nfunction visitPartial(partial) {\n  this.acceptRequired(partial, 'name');\n  this.acceptArray(partial.params);\n  this.acceptKey(partial, 'hash');\n}\nexports['default'] = Visitor;\nmodule.exports = exports['default'];","map":{"version":3,"mappings":";;;;;;;;;;yBAAsB,cAAc;;AAEpC,SAASA,OAAO,GAAG;EACjB,IAAI,CAACC,OAAO,GAAG,EAAE;;AAGnBD,OAAO,CAACE,SAAS,GAAG;EAClBC,WAAW,EAAEH,OAAO;EACpBI,QAAQ,EAAE,KAAK;;EAGfC,SAAS,EAAE,mBAASC,IAAI,EAAEC,IAAI,EAAE;IAC9B,IAAIC,KAAK,GAAG,IAAI,CAACC,MAAM,CAACH,IAAI,CAACC,IAAI,CAAC,CAAC;IACnC,IAAI,IAAI,CAACH,QAAQ,EAAE;;;MAGjB,IAAII,KAAK,IAAI,CAACR,OAAO,CAACE,SAAS,CAACM,KAAK,CAACE,IAAI,CAAC,EAAE;QAC3C,MAAM,2BACJ,wBAAwB,GACtBF,KAAK,CAACE,IAAI,GACV,yBAAyB,GACzBH,IAAI,GACJ,MAAM,GACND,IAAI,CAACI,IAAI,CACZ;;MAEHJ,IAAI,CAACC,IAAI,CAAC,GAAGC,KAAK;;GAErB;;;EAIDG,cAAc,EAAE,wBAASL,IAAI,EAAEC,IAAI,EAAE;IACnC,IAAI,CAACF,SAAS,CAACC,IAAI,EAAEC,IAAI,CAAC;IAE1B,IAAI,CAACD,IAAI,CAACC,IAAI,CAAC,EAAE;MACf,MAAM,2BAAcD,IAAI,CAACI,IAAI,GAAG,YAAY,GAAGH,IAAI,CAAC;;GAEvD;;;EAIDK,WAAW,EAAE,qBAASC,KAAK,EAAE;IAC3B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGF,KAAK,CAACG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;MAC5C,IAAI,CAACT,SAAS,CAACQ,KAAK,EAAEC,CAAC,CAAC;MAExB,IAAI,CAACD,KAAK,CAACC,CAAC,CAAC,EAAE;QACbD,KAAK,CAACI,MAAM,CAACH,CAAC,EAAE,CAAC,CAAC;QAClBA,CAAC,EAAE;QACHC,CAAC,EAAE;;;GAGR;EAEDN,MAAM,EAAE,gBAASS,MAAM,EAAE;IACvB,IAAI,CAACA,MAAM,EAAE;MACX;;;;IAIF,IAAI,CAAC,IAAI,CAACA,MAAM,CAACR,IAAI,CAAC,EAAE;MACtB,MAAM,2BAAc,gBAAgB,GAAGQ,MAAM,CAACR,IAAI,EAAEQ,MAAM,CAAC;;IAG7D,IAAI,IAAI,CAACC,OAAO,EAAE;MAChB,IAAI,CAAClB,OAAO,CAACmB,OAAO,CAAC,IAAI,CAACD,OAAO,CAAC;;IAEpC,IAAI,CAACA,OAAO,GAAGD,MAAM;IAErB,IAAIG,GAAG,GAAG,IAAI,CAACH,MAAM,CAACR,IAAI,CAAC,CAACQ,MAAM,CAAC;IAEnC,IAAI,CAACC,OAAO,GAAG,IAAI,CAAClB,OAAO,CAACqB,KAAK,EAAE;IAEnC,IAAI,CAAC,IAAI,CAAClB,QAAQ,IAAIiB,GAAG,EAAE;MACzB,OAAOA,GAAG;KACX,MAAM,IAAIA,GAAG,KAAK,KAAK,EAAE;MACxB,OAAOH,MAAM;;GAEhB;EAEDK,OAAO,EAAE,iBAASC,OAAO,EAAE;IACzB,IAAI,CAACZ,WAAW,CAACY,OAAO,CAACC,IAAI,CAAC;GAC/B;EAEDC,iBAAiB,EAAEC,kBAAkB;EACrCC,SAAS,EAAED,kBAAkB;EAE7BE,cAAc,EAAEC,UAAU;EAC1BC,cAAc,EAAED,UAAU;EAE1BE,gBAAgB,EAAEC,YAAY;EAC9BC,qBAAqB,EAAE,+BAASC,OAAO,EAAE;IACvCF,YAAY,CAACG,IAAI,CAAC,IAAI,EAAED,OAAO,CAAC;IAEhC,IAAI,CAAC9B,SAAS,CAAC8B,OAAO,EAAE,SAAS,CAAC;GACnC;EAEDE,gBAAgB,EAAE,yCAAwB,EAAE;EAC5CC,gBAAgB,EAAE,yCAAwB,EAAE;EAE5CC,aAAa,EAAEZ,kBAAkB;EAEjCa,cAAc,EAAE,oCAAqB,EAAE;EAEvCC,aAAa,EAAE,qCAAuB,EAAE;EACxCC,aAAa,EAAE,qCAAuB,EAAE;EACxCC,cAAc,EAAE,oCAAqB,EAAE;EACvCC,gBAAgB,EAAE,yCAAwB,EAAE;EAC5CC,WAAW,EAAE,oCAAwB,EAAE;EAEvCC,IAAI,EAAE,cAASC,IAAI,EAAE;IACnB,IAAI,CAACnC,WAAW,CAACmC,IAAI,CAACC,KAAK,CAAC;GAC7B;EACDC,QAAQ,EAAE,kBAASC,IAAI,EAAE;IACvB,IAAI,CAACvC,cAAc,CAACuC,IAAI,EAAE,OAAO,CAAC;;CAErC;AAED,SAASvB,kBAAkB,CAACwB,QAAQ,EAAE;EACpC,IAAI,CAACxC,cAAc,CAACwC,QAAQ,EAAE,MAAM,CAAC;EACrC,IAAI,CAACvC,WAAW,CAACuC,QAAQ,CAACC,MAAM,CAAC;EACjC,IAAI,CAAC/C,SAAS,CAAC8C,QAAQ,EAAE,MAAM,CAAC;;AAElC,SAASrB,UAAU,CAACuB,KAAK,EAAE;EACzB1B,kBAAkB,CAACS,IAAI,CAAC,IAAI,EAAEiB,KAAK,CAAC;EAEpC,IAAI,CAAChD,SAAS,CAACgD,KAAK,EAAE,SAAS,CAAC;EAChC,IAAI,CAAChD,SAAS,CAACgD,KAAK,EAAE,SAAS,CAAC;;AAElC,SAASpB,YAAY,CAACE,OAAO,EAAE;EAC7B,IAAI,CAACxB,cAAc,CAACwB,OAAO,EAAE,MAAM,CAAC;EACpC,IAAI,CAACvB,WAAW,CAACuB,OAAO,CAACiB,MAAM,CAAC;EAChC,IAAI,CAAC/C,SAAS,CAAC8B,OAAO,EAAE,MAAM,CAAC;;qBAGlBnC,OAAO","names":["Visitor","parents","prototype","constructor","mutating","acceptKey","node","name","value","accept","type","acceptRequired","acceptArray","array","i","l","length","splice","object","current","unshift","ret","shift","Program","program","body","MustacheStatement","visitSubExpression","Decorator","BlockStatement","visitBlock","DecoratorBlock","PartialStatement","visitPartial","PartialBlockStatement","partial","call","ContentStatement","CommentStatement","SubExpression","PathExpression","StringLiteral","NumberLiteral","BooleanLiteral","UndefinedLiteral","NullLiteral","Hash","hash","pairs","HashPair","pair","mustache","params","block"],"sources":["../../../../lib/handlebars/compiler/visitor.js"],"sourcesContent":["import Exception from '../exception';\n\nfunction Visitor() {\n  this.parents = [];\n}\n\nVisitor.prototype = {\n  constructor: Visitor,\n  mutating: false,\n\n  // Visits a given value. If mutating, will replace the value if necessary.\n  acceptKey: function(node, name) {\n    let value = this.accept(node[name]);\n    if (this.mutating) {\n      // Hacky sanity check: This may have a few false positives for type for the helper\n      // methods but will generally do the right thing without a lot of overhead.\n      if (value && !Visitor.prototype[value.type]) {\n        throw new Exception(\n          'Unexpected node type \"' +\n            value.type +\n            '\" found when accepting ' +\n            name +\n            ' on ' +\n            node.type\n        );\n      }\n      node[name] = value;\n    }\n  },\n\n  // Performs an accept operation with added sanity check to ensure\n  // required keys are not removed.\n  acceptRequired: function(node, name) {\n    this.acceptKey(node, name);\n\n    if (!node[name]) {\n      throw new Exception(node.type + ' requires ' + name);\n    }\n  },\n\n  // Traverses a given array. If mutating, empty respnses will be removed\n  // for child elements.\n  acceptArray: function(array) {\n    for (let i = 0, l = array.length; i < l; i++) {\n      this.acceptKey(array, i);\n\n      if (!array[i]) {\n        array.splice(i, 1);\n        i--;\n        l--;\n      }\n    }\n  },\n\n  accept: function(object) {\n    if (!object) {\n      return;\n    }\n\n    /* istanbul ignore next: Sanity code */\n    if (!this[object.type]) {\n      throw new Exception('Unknown type: ' + object.type, object);\n    }\n\n    if (this.current) {\n      this.parents.unshift(this.current);\n    }\n    this.current = object;\n\n    let ret = this[object.type](object);\n\n    this.current = this.parents.shift();\n\n    if (!this.mutating || ret) {\n      return ret;\n    } else if (ret !== false) {\n      return object;\n    }\n  },\n\n  Program: function(program) {\n    this.acceptArray(program.body);\n  },\n\n  MustacheStatement: visitSubExpression,\n  Decorator: visitSubExpression,\n\n  BlockStatement: visitBlock,\n  DecoratorBlock: visitBlock,\n\n  PartialStatement: visitPartial,\n  PartialBlockStatement: function(partial) {\n    visitPartial.call(this, partial);\n\n    this.acceptKey(partial, 'program');\n  },\n\n  ContentStatement: function(/* content */) {},\n  CommentStatement: function(/* comment */) {},\n\n  SubExpression: visitSubExpression,\n\n  PathExpression: function(/* path */) {},\n\n  StringLiteral: function(/* string */) {},\n  NumberLiteral: function(/* number */) {},\n  BooleanLiteral: function(/* bool */) {},\n  UndefinedLiteral: function(/* literal */) {},\n  NullLiteral: function(/* literal */) {},\n\n  Hash: function(hash) {\n    this.acceptArray(hash.pairs);\n  },\n  HashPair: function(pair) {\n    this.acceptRequired(pair, 'value');\n  }\n};\n\nfunction visitSubExpression(mustache) {\n  this.acceptRequired(mustache, 'path');\n  this.acceptArray(mustache.params);\n  this.acceptKey(mustache, 'hash');\n}\nfunction visitBlock(block) {\n  visitSubExpression.call(this, block);\n\n  this.acceptKey(block, 'program');\n  this.acceptKey(block, 'inverse');\n}\nfunction visitPartial(partial) {\n  this.acceptRequired(partial, 'name');\n  this.acceptArray(partial.params);\n  this.acceptKey(partial, 'hash');\n}\n\nexport default Visitor;\n"]},"metadata":{},"sourceType":"script"}