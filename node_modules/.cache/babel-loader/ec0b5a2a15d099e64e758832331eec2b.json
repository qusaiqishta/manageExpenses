{"ast":null,"code":"/* eslint-disable no-process-env */\nvar _ = require('lodash'),\n  fs = require('fs'),\n  join = require('path').join,\n  async = require('async'),\n  util = require('../util'),\n  liquidJSON = require('liquid-json'),\n  /**\n   * Name of the directory that contains the file denoted by FILE_NAME.\n   *\n   * @type {String}\n   */\n  POSTMAN_CONFIG_DIR = 'postman',\n  /**\n   * Name of the file that contains Newman compliant confguration information.\n   *\n   * @type {String}\n   */\n  FILE_NAME = 'newmanrc';\n\n/**\n * Configuration loader to acquire run settings from a file present in the home directory: POSTMAN_CONFIG_DIR/FILE_NAME.\n *\n * @param {Function} callback - The callback function invoked to mark the completion of the config loading routine.\n * @returns {*}\n */\nmodule.exports.load = callback => {\n  var iswin = /^win/.test(process.platform),\n    home = iswin ? process.env.USERPROFILE : process.env.HOME,\n    configFiles = [];\n  !iswin && configFiles.push(join('/etc', POSTMAN_CONFIG_DIR, FILE_NAME));\n  home && configFiles.push(join(home, '.' + POSTMAN_CONFIG_DIR, FILE_NAME));\n  configFiles.push(join(process.cwd(), '.' + FILE_NAME));\n  async.mapSeries(configFiles, (path, cb) => {\n    fs.readFile(path, (err, data) => {\n      if (err) {\n        return cb(null, {}); // err masked to avoid overpopulating terminal with missing .newmanrc messages\n      }\n\n      data && data.toString && (data = data.toString(util.detectEncoding(data)).trim());\n      try {\n        return cb(null, liquidJSON.parse(data));\n      } catch (e) {\n        return cb(_.set(e, 'help', `The file at ${path} contains invalid data.`));\n      }\n    });\n  }, (err, files) => {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, _.merge.apply(this, files));\n  });\n};","map":{"version":3,"names":["_","require","fs","join","async","util","liquidJSON","POSTMAN_CONFIG_DIR","FILE_NAME","module","exports","load","callback","iswin","test","process","platform","home","env","USERPROFILE","HOME","configFiles","push","cwd","mapSeries","path","cb","readFile","err","data","toString","detectEncoding","trim","parse","e","set","files","merge","apply"],"sources":["/Users/Qusai.Qishta/node_modules/newman/lib/config/rc-file.js"],"sourcesContent":["/* eslint-disable no-process-env */\nvar _ = require('lodash'),\n    fs = require('fs'),\n    join = require('path').join,\n    async = require('async'),\n    util = require('../util'),\n    liquidJSON = require('liquid-json'),\n\n    /**\n     * Name of the directory that contains the file denoted by FILE_NAME.\n     *\n     * @type {String}\n     */\n    POSTMAN_CONFIG_DIR = 'postman',\n\n    /**\n     * Name of the file that contains Newman compliant confguration information.\n     *\n     * @type {String}\n     */\n    FILE_NAME = 'newmanrc';\n\n/**\n * Configuration loader to acquire run settings from a file present in the home directory: POSTMAN_CONFIG_DIR/FILE_NAME.\n *\n * @param {Function} callback - The callback function invoked to mark the completion of the config loading routine.\n * @returns {*}\n */\nmodule.exports.load = (callback) => {\n    var iswin = (/^win/).test(process.platform),\n        home = iswin ? process.env.USERPROFILE : process.env.HOME,\n\n        configFiles = [];\n\n    !iswin && configFiles.push(join('/etc', POSTMAN_CONFIG_DIR, FILE_NAME));\n    home && configFiles.push(join(home, '.' + POSTMAN_CONFIG_DIR, FILE_NAME));\n    configFiles.push(join(process.cwd(), '.' + FILE_NAME));\n\n    async.mapSeries(configFiles, (path, cb) => {\n        fs.readFile(path, (err, data) => {\n            if (err) {\n                return cb(null, {}); // err masked to avoid overpopulating terminal with missing .newmanrc messages\n            }\n            data && data.toString && (data = data.toString(util.detectEncoding(data)).trim());\n            try {\n                return cb(null, liquidJSON.parse(data));\n            }\n            catch (e) {\n                return cb(_.set(e, 'help', `The file at ${path} contains invalid data.`));\n            }\n        });\n    }, (err, files) => {\n        if (err) {\n            return callback(err);\n        }\n\n        return callback(null, _.merge.apply(this, files));\n    });\n};\n"],"mappings":"AAAA;AACA,IAAIA,CAAC,GAAGC,OAAO,CAAC,QAAQ,CAAC;EACrBC,EAAE,GAAGD,OAAO,CAAC,IAAI,CAAC;EAClBE,IAAI,GAAGF,OAAO,CAAC,MAAM,CAAC,CAACE,IAAI;EAC3BC,KAAK,GAAGH,OAAO,CAAC,OAAO,CAAC;EACxBI,IAAI,GAAGJ,OAAO,CAAC,SAAS,CAAC;EACzBK,UAAU,GAAGL,OAAO,CAAC,aAAa,CAAC;EAEnC;AACJ;AACA;AACA;AACA;EACIM,kBAAkB,GAAG,SAAS;EAE9B;AACJ;AACA;AACA;AACA;EACIC,SAAS,GAAG,UAAU;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACAC,MAAM,CAACC,OAAO,CAACC,IAAI,GAAIC,QAAQ,IAAK;EAChC,IAAIC,KAAK,GAAI,MAAM,CAAEC,IAAI,CAACC,OAAO,CAACC,QAAQ,CAAC;IACvCC,IAAI,GAAGJ,KAAK,GAAGE,OAAO,CAACG,GAAG,CAACC,WAAW,GAAGJ,OAAO,CAACG,GAAG,CAACE,IAAI;IAEzDC,WAAW,GAAG,EAAE;EAEpB,CAACR,KAAK,IAAIQ,WAAW,CAACC,IAAI,CAACnB,IAAI,CAAC,MAAM,EAAEI,kBAAkB,EAAEC,SAAS,CAAC,CAAC;EACvES,IAAI,IAAII,WAAW,CAACC,IAAI,CAACnB,IAAI,CAACc,IAAI,EAAE,GAAG,GAAGV,kBAAkB,EAAEC,SAAS,CAAC,CAAC;EACzEa,WAAW,CAACC,IAAI,CAACnB,IAAI,CAACY,OAAO,CAACQ,GAAG,EAAE,EAAE,GAAG,GAAGf,SAAS,CAAC,CAAC;EAEtDJ,KAAK,CAACoB,SAAS,CAACH,WAAW,EAAE,CAACI,IAAI,EAAEC,EAAE,KAAK;IACvCxB,EAAE,CAACyB,QAAQ,CAACF,IAAI,EAAE,CAACG,GAAG,EAAEC,IAAI,KAAK;MAC7B,IAAID,GAAG,EAAE;QACL,OAAOF,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;MACzB;;MACAG,IAAI,IAAIA,IAAI,CAACC,QAAQ,KAAKD,IAAI,GAAGA,IAAI,CAACC,QAAQ,CAACzB,IAAI,CAAC0B,cAAc,CAACF,IAAI,CAAC,CAAC,CAACG,IAAI,EAAE,CAAC;MACjF,IAAI;QACA,OAAON,EAAE,CAAC,IAAI,EAAEpB,UAAU,CAAC2B,KAAK,CAACJ,IAAI,CAAC,CAAC;MAC3C,CAAC,CACD,OAAOK,CAAC,EAAE;QACN,OAAOR,EAAE,CAAC1B,CAAC,CAACmC,GAAG,CAACD,CAAC,EAAE,MAAM,EAAG,eAAcT,IAAK,yBAAwB,CAAC,CAAC;MAC7E;IACJ,CAAC,CAAC;EACN,CAAC,EAAE,CAACG,GAAG,EAAEQ,KAAK,KAAK;IACf,IAAIR,GAAG,EAAE;MACL,OAAOhB,QAAQ,CAACgB,GAAG,CAAC;IACxB;IAEA,OAAOhB,QAAQ,CAAC,IAAI,EAAEZ,CAAC,CAACqC,KAAK,CAACC,KAAK,CAAC,IAAI,EAAEF,KAAK,CAAC,CAAC;EACrD,CAAC,CAAC;AACN,CAAC"},"metadata":{},"sourceType":"script"}