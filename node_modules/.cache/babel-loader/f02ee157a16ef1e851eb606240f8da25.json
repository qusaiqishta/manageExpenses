{"ast":null,"code":"var fs = require('fs'),\n  nodePath = require('path'),\n  _ = require('lodash'),\n  async = require('async'),\n  mkdirp = require('mkdirp'),\n  // @todo: ES6: Change the sequence below to use object destructuring when Node v4 support is dropped\n  joinPath = nodePath.join,\n  parsePath = nodePath.parse,\n  resolvePath = nodePath.resolve,\n  /**\n   * The root path specifier\n   *\n   * @const\n   * @private\n   * @type {string}\n   */\n  E = '',\n  /**\n   * Default timestamp separator.\n   *\n   * @const\n   * @private\n   * @type {string}\n   */\n  TS_SEP = '-',\n  /**\n   * Writes the specified content to a file at the provided path.\n   *\n   * @param {Object} path - A set of path details for file writing.\n   * @param {String|Buffer} content - The content to be written to the file.\n   * @param {Object} options - A set of options for the current file write.\n   * @param {Function} cb - The callback invoked when the file writing operation has completed, with/without errors.\n   */\n  writeFile = function (path, content, options, cb) {\n    fs.writeFile(path.unparsed, content, function (err) {\n      cb(_.set(err, 'help', `error writing file \"${path.unparsed}\" for ${options.name || 'unknown-source'}`), path);\n    });\n  },\n  /**\n   * Generate a timestamp from date\n   *\n   * @param {Date=} date - The timestamp used to mark the exported file.\n   * @param {String=} separator - The optional string with which to separate different sections of the timestamp,\n   * defaults to TS_SEP\n   * @returns {String} - yyyy-mm-dd-HH-MM-SS-MS-0\n   */\n  timestamp = function (date, separator) {\n    // use the iso string to ensure left padding and other stuff is taken care of\n    return (date || new Date()).toISOString().replace(/[^\\d]+/g, _.isString(separator) ? separator : TS_SEP);\n  };\n\n/**\n * Module whose job is to export a file which is in an export format.\n *\n * @param {Object} options - The set of file export options.\n * @param {String} options.path - The path to the exported file.\n * @param {String|Object} options.content - The JSON / stringified content that is to be written to the file.\n * @param {Function} done - The callback whose invocation marks the end of the file export routine.\n * @returns {*}\n */\nmodule.exports = function (options, done) {\n  // parse the path if one is available as string\n  var path = _.isString(options.path) && parsePath(resolvePath(options.path)),\n    content = _.isPlainObject(options.content) ? JSON.stringify(options.content, 0, 2) : options.content || E;\n\n  // if a path was not provided by user, we need to prepare the default path. but create the default path only if one\n  // is provided.\n  if (!path && _.isString(options.default)) {\n    path = parsePath(options.default);\n    // delete the path and directory if one is detected when parsing defaults\n    path.root = E;\n    path.dir = 'newman';\n\n    // append timestamp\n    path.name = `${path.name}-${timestamp()}0`; // @todo make -0 become incremental if file name exists\n    path.base = path.name + path.ext;\n  }\n  // final check that path is valid\n  if (!(path && path.base)) {\n    return;\n  }\n\n  // now sore the unparsed result back for quick re-use during writing and a single place for unparsing\n  path.unparsed = joinPath(path.dir, path.base);\n\n  // in case the path has a directory, ensure that the directory is available\n  if (path.dir) {\n    async.waterfall([function (next) {\n      mkdirp(path.dir).then(() => {\n        return next();\n      }).catch(err => {\n        return next(_.set(err, 'help', `error creating path for file \"${path.unparsed}\" for ${options.name || 'unknown-source'}`));\n      });\n    }, function (next) {\n      fs.stat(path.unparsed, function (err, stat) {\n        // eslint-disable-line handle-callback-err\n        next(null, stat);\n      });\n    }, function (stat, next) {\n      var target;\n\n      // handle cases where the specified export path is a pre-existing directory\n      if (stat && stat.isDirectory()) {\n        target = parsePath(options.default);\n\n        // append timestamp\n        // @todo make -0 become incremental if file name exists\n        target.name += '-' + timestamp() + '0';\n        target.base = target.name + target.ext;\n        path.unparsed = joinPath(path.unparsed, target.base);\n      }\n      next(null, path);\n    }, function (path, next) {\n      writeFile(path, content, options, next);\n    }], done);\n  } else {\n    writeFile(path, content, options, done);\n  }\n};","map":{"version":3,"names":["fs","require","nodePath","_","async","mkdirp","joinPath","join","parsePath","parse","resolvePath","resolve","E","TS_SEP","writeFile","path","content","options","cb","unparsed","err","set","name","timestamp","date","separator","Date","toISOString","replace","isString","module","exports","done","isPlainObject","JSON","stringify","default","root","dir","base","ext","waterfall","next","then","catch","stat","target","isDirectory"],"sources":["/Users/Qusai.Qishta/node_modules/newman/lib/run/export-file.js"],"sourcesContent":["var fs = require('fs'),\n    nodePath = require('path'),\n\n    _ = require('lodash'),\n    async = require('async'),\n    mkdirp = require('mkdirp'),\n\n    // @todo: ES6: Change the sequence below to use object destructuring when Node v4 support is dropped\n    joinPath = nodePath.join,\n    parsePath = nodePath.parse,\n    resolvePath = nodePath.resolve,\n\n    /**\n     * The root path specifier\n     *\n     * @const\n     * @private\n     * @type {string}\n     */\n    E = '',\n\n    /**\n     * Default timestamp separator.\n     *\n     * @const\n     * @private\n     * @type {string}\n     */\n    TS_SEP = '-',\n\n    /**\n     * Writes the specified content to a file at the provided path.\n     *\n     * @param {Object} path - A set of path details for file writing.\n     * @param {String|Buffer} content - The content to be written to the file.\n     * @param {Object} options - A set of options for the current file write.\n     * @param {Function} cb - The callback invoked when the file writing operation has completed, with/without errors.\n     */\n    writeFile = function (path, content, options, cb) {\n        fs.writeFile(path.unparsed, content, function (err) {\n            cb(_.set(err, 'help',\n                `error writing file \"${path.unparsed}\" for ${options.name || 'unknown-source'}`), path);\n        });\n    },\n\n    /**\n     * Generate a timestamp from date\n     *\n     * @param {Date=} date - The timestamp used to mark the exported file.\n     * @param {String=} separator - The optional string with which to separate different sections of the timestamp,\n     * defaults to TS_SEP\n     * @returns {String} - yyyy-mm-dd-HH-MM-SS-MS-0\n     */\n    timestamp = function (date, separator) {\n        // use the iso string to ensure left padding and other stuff is taken care of\n        return (date || new Date()).toISOString().replace(/[^\\d]+/g, _.isString(separator) ? separator : TS_SEP);\n    };\n\n/**\n * Module whose job is to export a file which is in an export format.\n *\n * @param {Object} options - The set of file export options.\n * @param {String} options.path - The path to the exported file.\n * @param {String|Object} options.content - The JSON / stringified content that is to be written to the file.\n * @param {Function} done - The callback whose invocation marks the end of the file export routine.\n * @returns {*}\n */\nmodule.exports = function (options, done) {\n    // parse the path if one is available as string\n    var path = _.isString(options.path) && parsePath(resolvePath(options.path)),\n        content = _.isPlainObject(options.content) ? JSON.stringify(options.content, 0, 2) : (options.content || E);\n\n    // if a path was not provided by user, we need to prepare the default path. but create the default path only if one\n    // is provided.\n    if (!path && _.isString(options.default)) {\n        path = parsePath(options.default);\n        // delete the path and directory if one is detected when parsing defaults\n        path.root = E;\n        path.dir = 'newman';\n\n        // append timestamp\n        path.name = `${path.name}-${timestamp()}0`; // @todo make -0 become incremental if file name exists\n        path.base = path.name + path.ext;\n    }\n    // final check that path is valid\n    if (!(path && path.base)) {\n        return;\n    }\n\n    // now sore the unparsed result back for quick re-use during writing and a single place for unparsing\n    path.unparsed = joinPath(path.dir, path.base);\n\n    // in case the path has a directory, ensure that the directory is available\n    if (path.dir) {\n        async.waterfall([\n            function (next) {\n                mkdirp(path.dir)\n                    .then(() => {\n                        return next();\n                    })\n                    .catch((err) => {\n                        return next(_.set(err, 'help',\n                            `error creating path for file \"${path.unparsed}\" for ${options.name || 'unknown-source'}`));\n                    });\n            },\n            function (next) {\n                fs.stat(path.unparsed, function (err, stat) { // eslint-disable-line handle-callback-err\n                    next(null, stat);\n                });\n            },\n            function (stat, next) {\n                var target;\n\n                // handle cases where the specified export path is a pre-existing directory\n                if (stat && stat.isDirectory()) {\n                    target = parsePath(options.default);\n\n                    // append timestamp\n                    // @todo make -0 become incremental if file name exists\n                    target.name += '-' + timestamp() + '0';\n                    target.base = target.name + target.ext;\n\n                    path.unparsed = joinPath(path.unparsed, target.base);\n                }\n\n                next(null, path);\n            },\n            function (path, next) {\n                writeFile(path, content, options, next);\n            }\n        ], done);\n    }\n    else {\n        writeFile(path, content, options, done);\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}