{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\nvar _visitor = require('./visitor');\nvar _visitor2 = _interopRequireDefault(_visitor);\nfunction WhitespaceControl() {\n  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n  this.options = options;\n}\nWhitespaceControl.prototype = new _visitor2['default']();\nWhitespaceControl.prototype.Program = function (program) {\n  var doStandalone = !this.options.ignoreStandalone;\n  var isRoot = !this.isRootSeen;\n  this.isRootSeen = true;\n  var body = program.body;\n  for (var i = 0, l = body.length; i < l; i++) {\n    var current = body[i],\n      strip = this.accept(current);\n    if (!strip) {\n      continue;\n    }\n    var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),\n      _isNextWhitespace = isNextWhitespace(body, i, isRoot),\n      openStandalone = strip.openStandalone && _isPrevWhitespace,\n      closeStandalone = strip.closeStandalone && _isNextWhitespace,\n      inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;\n    if (strip.close) {\n      omitRight(body, i, true);\n    }\n    if (strip.open) {\n      omitLeft(body, i, true);\n    }\n    if (doStandalone && inlineStandalone) {\n      omitRight(body, i);\n      if (omitLeft(body, i)) {\n        // If we are on a standalone node, save the indent info for partials\n        if (current.type === 'PartialStatement') {\n          // Pull out the whitespace from the final line\n          current.indent = /([ \\t]+$)/.exec(body[i - 1].original)[1];\n        }\n      }\n    }\n    if (doStandalone && openStandalone) {\n      omitRight((current.program || current.inverse).body);\n\n      // Strip out the previous content node if it's whitespace only\n      omitLeft(body, i);\n    }\n    if (doStandalone && closeStandalone) {\n      // Always strip the next node\n      omitRight(body, i);\n      omitLeft((current.inverse || current.program).body);\n    }\n  }\n  return program;\n};\nWhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function (block) {\n  this.accept(block.program);\n  this.accept(block.inverse);\n\n  // Find the inverse program that is involed with whitespace stripping.\n  var program = block.program || block.inverse,\n    inverse = block.program && block.inverse,\n    firstInverse = inverse,\n    lastInverse = inverse;\n  if (inverse && inverse.chained) {\n    firstInverse = inverse.body[0].program;\n\n    // Walk the inverse chain to find the last inverse that is actually in the chain.\n    while (lastInverse.chained) {\n      lastInverse = lastInverse.body[lastInverse.body.length - 1].program;\n    }\n  }\n  var strip = {\n    open: block.openStrip.open,\n    close: block.closeStrip.close,\n    // Determine the standalone candiacy. Basically flag our content as being possibly standalone\n    // so our parent can determine if we actually are standalone\n    openStandalone: isNextWhitespace(program.body),\n    closeStandalone: isPrevWhitespace((firstInverse || program).body)\n  };\n  if (block.openStrip.close) {\n    omitRight(program.body, null, true);\n  }\n  if (inverse) {\n    var inverseStrip = block.inverseStrip;\n    if (inverseStrip.open) {\n      omitLeft(program.body, null, true);\n    }\n    if (inverseStrip.close) {\n      omitRight(firstInverse.body, null, true);\n    }\n    if (block.closeStrip.open) {\n      omitLeft(lastInverse.body, null, true);\n    }\n\n    // Find standalone else statments\n    if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {\n      omitLeft(program.body);\n      omitRight(firstInverse.body);\n    }\n  } else if (block.closeStrip.open) {\n    omitLeft(program.body, null, true);\n  }\n  return strip;\n};\nWhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function (mustache) {\n  return mustache.strip;\n};\nWhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function (node) {\n  /* istanbul ignore next */\n  var strip = node.strip || {};\n  return {\n    inlineStandalone: true,\n    open: strip.open,\n    close: strip.close\n  };\n};\nfunction isPrevWhitespace(body, i, isRoot) {\n  if (i === undefined) {\n    i = body.length;\n  }\n\n  // Nodes that end with newlines are considered whitespace (but are special\n  // cased for strip operations)\n  var prev = body[i - 1],\n    sibling = body[i - 2];\n  if (!prev) {\n    return isRoot;\n  }\n  if (prev.type === 'ContentStatement') {\n    return (sibling || !isRoot ? /\\r?\\n\\s*?$/ : /(^|\\r?\\n)\\s*?$/).test(prev.original);\n  }\n}\nfunction isNextWhitespace(body, i, isRoot) {\n  if (i === undefined) {\n    i = -1;\n  }\n  var next = body[i + 1],\n    sibling = body[i + 2];\n  if (!next) {\n    return isRoot;\n  }\n  if (next.type === 'ContentStatement') {\n    return (sibling || !isRoot ? /^\\s*?\\r?\\n/ : /^\\s*?(\\r?\\n|$)/).test(next.original);\n  }\n}\n\n// Marks the node to the right of the position as omitted.\n// I.e. {{foo}}' ' will mark the ' ' node as omitted.\n//\n// If i is undefined, then the first child will be marked as such.\n//\n// If mulitple is truthy then all whitespace will be stripped out until non-whitespace\n// content is met.\nfunction omitRight(body, i, multiple) {\n  var current = body[i == null ? 0 : i + 1];\n  if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {\n    return;\n  }\n  var original = current.value;\n  current.value = current.value.replace(multiple ? /^\\s+/ : /^[ \\t]*\\r?\\n?/, '');\n  current.rightStripped = current.value !== original;\n}\n\n// Marks the node to the left of the position as omitted.\n// I.e. ' '{{foo}} will mark the ' ' node as omitted.\n//\n// If i is undefined then the last child will be marked as such.\n//\n// If mulitple is truthy then all whitespace will be stripped out until non-whitespace\n// content is met.\nfunction omitLeft(body, i, multiple) {\n  var current = body[i == null ? body.length - 1 : i - 1];\n  if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {\n    return;\n  }\n\n  // We omit the last node if it's whitespace only and not preceded by a non-content node.\n  var original = current.value;\n  current.value = current.value.replace(multiple ? /\\s+$/ : /[ \\t]+$/, '');\n  current.leftStripped = current.value !== original;\n  return current.leftStripped;\n}\nexports['default'] = WhitespaceControl;\nmodule.exports = exports['default'];","map":{"version":3,"mappings":"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","names":["WhitespaceControl","options","prototype","Program","program","doStandalone","ignoreStandalone","isRoot","isRootSeen","body","i","l","length","current","strip","accept","_isPrevWhitespace","isPrevWhitespace","_isNextWhitespace","isNextWhitespace","openStandalone","closeStandalone","inlineStandalone","close","omitRight","open","omitLeft","type","indent","exec","original","inverse","BlockStatement","DecoratorBlock","PartialBlockStatement","block","firstInverse","lastInverse","chained","openStrip","closeStrip","inverseStrip","Decorator","MustacheStatement","mustache","PartialStatement","CommentStatement","node","undefined","prev","sibling","test","next","multiple","rightStripped","value","replace","leftStripped"],"sources":["../../../../lib/handlebars/compiler/whitespace-control.js"],"sourcesContent":["import Visitor from './visitor';\n\nfunction WhitespaceControl(options = {}) {\n  this.options = options;\n}\nWhitespaceControl.prototype = new Visitor();\n\nWhitespaceControl.prototype.Program = function(program) {\n  const doStandalone = !this.options.ignoreStandalone;\n\n  let isRoot = !this.isRootSeen;\n  this.isRootSeen = true;\n\n  let body = program.body;\n  for (let i = 0, l = body.length; i < l; i++) {\n    let current = body[i],\n      strip = this.accept(current);\n\n    if (!strip) {\n      continue;\n    }\n\n    let _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),\n      _isNextWhitespace = isNextWhitespace(body, i, isRoot),\n      openStandalone = strip.openStandalone && _isPrevWhitespace,\n      closeStandalone = strip.closeStandalone && _isNextWhitespace,\n      inlineStandalone =\n        strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;\n\n    if (strip.close) {\n      omitRight(body, i, true);\n    }\n    if (strip.open) {\n      omitLeft(body, i, true);\n    }\n\n    if (doStandalone && inlineStandalone) {\n      omitRight(body, i);\n\n      if (omitLeft(body, i)) {\n        // If we are on a standalone node, save the indent info for partials\n        if (current.type === 'PartialStatement') {\n          // Pull out the whitespace from the final line\n          current.indent = /([ \\t]+$)/.exec(body[i - 1].original)[1];\n        }\n      }\n    }\n    if (doStandalone && openStandalone) {\n      omitRight((current.program || current.inverse).body);\n\n      // Strip out the previous content node if it's whitespace only\n      omitLeft(body, i);\n    }\n    if (doStandalone && closeStandalone) {\n      // Always strip the next node\n      omitRight(body, i);\n\n      omitLeft((current.inverse || current.program).body);\n    }\n  }\n\n  return program;\n};\n\nWhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function(\n  block\n) {\n  this.accept(block.program);\n  this.accept(block.inverse);\n\n  // Find the inverse program that is involed with whitespace stripping.\n  let program = block.program || block.inverse,\n    inverse = block.program && block.inverse,\n    firstInverse = inverse,\n    lastInverse = inverse;\n\n  if (inverse && inverse.chained) {\n    firstInverse = inverse.body[0].program;\n\n    // Walk the inverse chain to find the last inverse that is actually in the chain.\n    while (lastInverse.chained) {\n      lastInverse = lastInverse.body[lastInverse.body.length - 1].program;\n    }\n  }\n\n  let strip = {\n    open: block.openStrip.open,\n    close: block.closeStrip.close,\n\n    // Determine the standalone candiacy. Basically flag our content as being possibly standalone\n    // so our parent can determine if we actually are standalone\n    openStandalone: isNextWhitespace(program.body),\n    closeStandalone: isPrevWhitespace((firstInverse || program).body)\n  };\n\n  if (block.openStrip.close) {\n    omitRight(program.body, null, true);\n  }\n\n  if (inverse) {\n    let inverseStrip = block.inverseStrip;\n\n    if (inverseStrip.open) {\n      omitLeft(program.body, null, true);\n    }\n\n    if (inverseStrip.close) {\n      omitRight(firstInverse.body, null, true);\n    }\n    if (block.closeStrip.open) {\n      omitLeft(lastInverse.body, null, true);\n    }\n\n    // Find standalone else statments\n    if (\n      !this.options.ignoreStandalone &&\n      isPrevWhitespace(program.body) &&\n      isNextWhitespace(firstInverse.body)\n    ) {\n      omitLeft(program.body);\n      omitRight(firstInverse.body);\n    }\n  } else if (block.closeStrip.open) {\n    omitLeft(program.body, null, true);\n  }\n\n  return strip;\n};\n\nWhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function(\n  mustache\n) {\n  return mustache.strip;\n};\n\nWhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function(\n  node\n) {\n  /* istanbul ignore next */\n  let strip = node.strip || {};\n  return {\n    inlineStandalone: true,\n    open: strip.open,\n    close: strip.close\n  };\n};\n\nfunction isPrevWhitespace(body, i, isRoot) {\n  if (i === undefined) {\n    i = body.length;\n  }\n\n  // Nodes that end with newlines are considered whitespace (but are special\n  // cased for strip operations)\n  let prev = body[i - 1],\n    sibling = body[i - 2];\n  if (!prev) {\n    return isRoot;\n  }\n\n  if (prev.type === 'ContentStatement') {\n    return (sibling || !isRoot ? /\\r?\\n\\s*?$/ : /(^|\\r?\\n)\\s*?$/).test(\n      prev.original\n    );\n  }\n}\nfunction isNextWhitespace(body, i, isRoot) {\n  if (i === undefined) {\n    i = -1;\n  }\n\n  let next = body[i + 1],\n    sibling = body[i + 2];\n  if (!next) {\n    return isRoot;\n  }\n\n  if (next.type === 'ContentStatement') {\n    return (sibling || !isRoot ? /^\\s*?\\r?\\n/ : /^\\s*?(\\r?\\n|$)/).test(\n      next.original\n    );\n  }\n}\n\n// Marks the node to the right of the position as omitted.\n// I.e. {{foo}}' ' will mark the ' ' node as omitted.\n//\n// If i is undefined, then the first child will be marked as such.\n//\n// If mulitple is truthy then all whitespace will be stripped out until non-whitespace\n// content is met.\nfunction omitRight(body, i, multiple) {\n  let current = body[i == null ? 0 : i + 1];\n  if (\n    !current ||\n    current.type !== 'ContentStatement' ||\n    (!multiple && current.rightStripped)\n  ) {\n    return;\n  }\n\n  let original = current.value;\n  current.value = current.value.replace(\n    multiple ? /^\\s+/ : /^[ \\t]*\\r?\\n?/,\n    ''\n  );\n  current.rightStripped = current.value !== original;\n}\n\n// Marks the node to the left of the position as omitted.\n// I.e. ' '{{foo}} will mark the ' ' node as omitted.\n//\n// If i is undefined then the last child will be marked as such.\n//\n// If mulitple is truthy then all whitespace will be stripped out until non-whitespace\n// content is met.\nfunction omitLeft(body, i, multiple) {\n  let current = body[i == null ? body.length - 1 : i - 1];\n  if (\n    !current ||\n    current.type !== 'ContentStatement' ||\n    (!multiple && current.leftStripped)\n  ) {\n    return;\n  }\n\n  // We omit the last node if it's whitespace only and not preceded by a non-content node.\n  let original = current.value;\n  current.value = current.value.replace(multiple ? /\\s+$/ : /[ \\t]+$/, '');\n  current.leftStripped = current.value !== original;\n  return current.leftStripped;\n}\n\nexport default WhitespaceControl;\n"]},"metadata":{},"sourceType":"script"}