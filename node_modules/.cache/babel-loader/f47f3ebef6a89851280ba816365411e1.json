{"ast":null,"code":"var\n  /**\n   * @const\n   * @type {string}\n   */\n  FUNCTION = 'function',\n  /**\n   * @const\n   * @type {string}\n   */\n  STRING = 'string',\n  createReadStream; // function\n\n/**\n * Create readable stream for given file as well as detect possible file\n * read issues.\n *\n * @param {Object} resolver - External file resolver module\n * @param {String} fileSrc - File path\n * @param {Function} callback - Final callback\n *\n * @note This function is defined in the file's root because there is a need to\n * trap it within closure in order to append the stream clone functionalities.\n * This ensures lesser footprint in case we have a memory leak.\n */\ncreateReadStream = function (resolver, fileSrc, callback) {\n  var readStream;\n\n  // check for the existence of the file before creating read stream.\n  // eslint-disable-next-line security/detect-non-literal-fs-filename\n  resolver.stat(fileSrc, function (err, stats) {\n    if (err) {\n      // overwrite `ENOENT: no such file or directory` error message. Most likely the case.\n      err.code === 'ENOENT' && (err.message = `\"${fileSrc}\", no such file`);\n      return callback(err);\n    }\n\n    // check for a valid file.\n    if (stats && typeof stats.isFile === FUNCTION && !stats.isFile()) {\n      return callback(new Error(`\"${fileSrc}\", is not a file`));\n    }\n\n    // check read permissions for user.\n    // octal `400` signifies 'user permissions'. [4 0 0] -> [u g o]\n    // `4` signifies 'read permission'. [4] -> [1 0 0] -> [r w x]\n    if (stats && !(stats.mode & 0o400)) {\n      return callback(new Error(`\"${fileSrc}\", read permission denied`));\n    }\n\n    // @note Handle all the errors before `createReadStream` to avoid listening on stream error event.\n    // listening on error requires listening on end event as well. which will make this sync.\n    // @note In form-data mode stream error will be handled in postman-request but bails out ongoing request.\n    // eslint-disable-next-line security/detect-non-literal-fs-filename\n    readStream = resolver.createReadStream(fileSrc);\n\n    // We might have to read the file before making the actual request\n    // e.g, while calculating body hash during AWS auth or redirecting form-data params\n    // So, this method wraps the `createReadStream` function with fixed arguments.\n    // This makes sure that we don't have to pass `fileResolver` to\n    // internal modules (like auth plugins) for security reasons.\n    readStream.cloneReadStream = function (callback) {\n      // eslint-disable-next-line security/detect-non-literal-fs-filename\n      return createReadStream(resolver, fileSrc, callback);\n    };\n    callback(null, readStream);\n  });\n};\n\n/**\n * Utility functions that are required to be re-used throughout the runner\n *\n * @module Runner~util\n * @private\n *\n * @note Do not put module logic or business logic related functions here.\n * The functions here are purely decoupled and low-level functions.\n */\nmodule.exports = {\n  /**\n   * This function allows one to call another function by wrapping it within a try-catch block.\n   * The first parameter is the function itself, followed by the scope in which this function is to be executed.\n   * The third parameter onwards are blindly forwarded to the function being called\n   *\n   * @param {Function} fn -\n   * @param {*} ctx -\n   *\n   * @returns {Error} If there was an error executing the function, the error is returned.\n   * Note that if the function called here is asynchronous, it's errors will not be returned (for obvious reasons!)\n   */\n  safeCall(fn, ctx) {\n    // extract the arguments that are to be forwarded to the function to be called\n    var args = Array.prototype.slice.call(arguments, 2);\n    try {\n      typeof fn === FUNCTION && fn.apply(ctx || global, args);\n    } catch (err) {\n      return err;\n    }\n  },\n  /**\n   * Copies attributes from source object to destination object.\n   *\n   * @param {Object} dest -\n   * @param {Object} src -\n   *\n   * @return {Object}\n   */\n  syncObject(dest, src) {\n    var prop;\n\n    // update or add values from src\n    for (prop in src) {\n      if (Object.hasOwnProperty.call(src, prop)) {\n        dest[prop] = src[prop];\n      }\n    }\n\n    // remove values that no longer exist\n    for (prop in dest) {\n      if (Object.hasOwnProperty.call(dest, prop) && !Object.hasOwnProperty.call(src, prop)) {\n        delete dest[prop];\n      }\n    }\n    return dest;\n  },\n  /**\n   * Create readable stream for given file as well as detect possible file\n   * read issues. The resolver also attaches a clone function to the stream\n   * so that the stream can be restarted any time.\n   *\n   * @param {Object} resolver - External file resolver module\n   * @param {Function} resolver.stat - Resolver method to check for existence and permissions of file\n   * @param {Function} resolver.createReadStream - Resolver method for creating read stream\n   * @param {String} fileSrc - File path\n   * @param {Function} callback -\n   *\n   */\n  createReadStream(resolver, fileSrc, callback) {\n    // bail out if resolver not found.\n    if (!resolver) {\n      return callback(new Error('file resolver not supported'));\n    }\n\n    // bail out if resolver is not supported.\n    if (typeof resolver.stat !== FUNCTION || typeof resolver.createReadStream !== FUNCTION) {\n      return callback(new Error('file resolver interface mismatch'));\n    }\n\n    // bail out if file source is invalid or empty string.\n    if (!fileSrc || typeof fileSrc !== STRING) {\n      return callback(new Error('invalid or missing file source'));\n    }\n\n    // now that things are sanitized and validated, we transfer it to the\n    // stream reading utility function that does the heavy lifting of\n    // calling there resolver to return the stream\n    return createReadStream(resolver, fileSrc, callback);\n  }\n};","map":{"version":3,"names":["FUNCTION","STRING","createReadStream","resolver","fileSrc","callback","readStream","stat","err","stats","code","message","isFile","Error","mode","cloneReadStream","module","exports","safeCall","fn","ctx","args","Array","prototype","slice","call","arguments","apply","global","syncObject","dest","src","prop","Object","hasOwnProperty"],"sources":["/Users/Qusai.Qishta/node_modules/postman-runtime/lib/runner/util.js"],"sourcesContent":["var /**\n     * @const\n     * @type {string}\n     */\n    FUNCTION = 'function',\n\n    /**\n     * @const\n     * @type {string}\n     */\n    STRING = 'string',\n\n    createReadStream; // function\n\n/**\n * Create readable stream for given file as well as detect possible file\n * read issues.\n *\n * @param {Object} resolver - External file resolver module\n * @param {String} fileSrc - File path\n * @param {Function} callback - Final callback\n *\n * @note This function is defined in the file's root because there is a need to\n * trap it within closure in order to append the stream clone functionalities.\n * This ensures lesser footprint in case we have a memory leak.\n */\ncreateReadStream = function (resolver, fileSrc, callback) {\n    var readStream;\n\n    // check for the existence of the file before creating read stream.\n    // eslint-disable-next-line security/detect-non-literal-fs-filename\n    resolver.stat(fileSrc, function (err, stats) {\n        if (err) {\n            // overwrite `ENOENT: no such file or directory` error message. Most likely the case.\n            err.code === 'ENOENT' && (err.message = `\"${fileSrc}\", no such file`);\n\n            return callback(err);\n        }\n\n        // check for a valid file.\n        if (stats && typeof stats.isFile === FUNCTION && !stats.isFile()) {\n            return callback(new Error(`\"${fileSrc}\", is not a file`));\n        }\n\n        // check read permissions for user.\n        // octal `400` signifies 'user permissions'. [4 0 0] -> [u g o]\n        // `4` signifies 'read permission'. [4] -> [1 0 0] -> [r w x]\n        if (stats && !(stats.mode & 0o400)) {\n            return callback(new Error(`\"${fileSrc}\", read permission denied`));\n        }\n\n        // @note Handle all the errors before `createReadStream` to avoid listening on stream error event.\n        // listening on error requires listening on end event as well. which will make this sync.\n        // @note In form-data mode stream error will be handled in postman-request but bails out ongoing request.\n        // eslint-disable-next-line security/detect-non-literal-fs-filename\n        readStream = resolver.createReadStream(fileSrc);\n\n        // We might have to read the file before making the actual request\n        // e.g, while calculating body hash during AWS auth or redirecting form-data params\n        // So, this method wraps the `createReadStream` function with fixed arguments.\n        // This makes sure that we don't have to pass `fileResolver` to\n        // internal modules (like auth plugins) for security reasons.\n        readStream.cloneReadStream = function (callback) {\n            // eslint-disable-next-line security/detect-non-literal-fs-filename\n            return createReadStream(resolver, fileSrc, callback);\n        };\n\n        callback(null, readStream);\n    });\n};\n\n/**\n * Utility functions that are required to be re-used throughout the runner\n *\n * @module Runner~util\n * @private\n *\n * @note Do not put module logic or business logic related functions here.\n * The functions here are purely decoupled and low-level functions.\n */\nmodule.exports = {\n    /**\n     * This function allows one to call another function by wrapping it within a try-catch block.\n     * The first parameter is the function itself, followed by the scope in which this function is to be executed.\n     * The third parameter onwards are blindly forwarded to the function being called\n     *\n     * @param {Function} fn -\n     * @param {*} ctx -\n     *\n     * @returns {Error} If there was an error executing the function, the error is returned.\n     * Note that if the function called here is asynchronous, it's errors will not be returned (for obvious reasons!)\n     */\n    safeCall (fn, ctx) {\n        // extract the arguments that are to be forwarded to the function to be called\n        var args = Array.prototype.slice.call(arguments, 2);\n\n        try {\n            (typeof fn === FUNCTION) && fn.apply(ctx || global, args);\n        }\n        catch (err) {\n            return err;\n        }\n    },\n\n    /**\n     * Copies attributes from source object to destination object.\n     *\n     * @param {Object} dest -\n     * @param {Object} src -\n     *\n     * @return {Object}\n     */\n    syncObject (dest, src) {\n        var prop;\n\n        // update or add values from src\n        for (prop in src) {\n            if (Object.hasOwnProperty.call(src, prop)) {\n                dest[prop] = src[prop];\n            }\n        }\n\n        // remove values that no longer exist\n        for (prop in dest) {\n            if (Object.hasOwnProperty.call(dest, prop) && !Object.hasOwnProperty.call(src, prop)) {\n                delete dest[prop];\n            }\n        }\n\n        return dest;\n    },\n\n    /**\n     * Create readable stream for given file as well as detect possible file\n     * read issues. The resolver also attaches a clone function to the stream\n     * so that the stream can be restarted any time.\n     *\n     * @param {Object} resolver - External file resolver module\n     * @param {Function} resolver.stat - Resolver method to check for existence and permissions of file\n     * @param {Function} resolver.createReadStream - Resolver method for creating read stream\n     * @param {String} fileSrc - File path\n     * @param {Function} callback -\n     *\n     */\n    createReadStream (resolver, fileSrc, callback) {\n        // bail out if resolver not found.\n        if (!resolver) {\n            return callback(new Error('file resolver not supported'));\n        }\n\n        // bail out if resolver is not supported.\n        if (typeof resolver.stat !== FUNCTION || typeof resolver.createReadStream !== FUNCTION) {\n            return callback(new Error('file resolver interface mismatch'));\n        }\n\n        // bail out if file source is invalid or empty string.\n        if (!fileSrc || typeof fileSrc !== STRING) {\n            return callback(new Error('invalid or missing file source'));\n        }\n\n        // now that things are sanitized and validated, we transfer it to the\n        // stream reading utility function that does the heavy lifting of\n        // calling there resolver to return the stream\n        return createReadStream(resolver, fileSrc, callback);\n    }\n};\n"],"mappings":"AAAA;EAAI;AACJ;AACA;AACA;EACIA,QAAQ,GAAG,UAAU;EAErB;AACJ;AACA;AACA;EACIC,MAAM,GAAG,QAAQ;EAEjBC,gBAAgB,CAAC,CAAC;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,gBAAgB,GAAG,UAAUC,QAAQ,EAAEC,OAAO,EAAEC,QAAQ,EAAE;EACtD,IAAIC,UAAU;;EAEd;EACA;EACAH,QAAQ,CAACI,IAAI,CAACH,OAAO,EAAE,UAAUI,GAAG,EAAEC,KAAK,EAAE;IACzC,IAAID,GAAG,EAAE;MACL;MACAA,GAAG,CAACE,IAAI,KAAK,QAAQ,KAAKF,GAAG,CAACG,OAAO,GAAI,IAAGP,OAAQ,iBAAgB,CAAC;MAErE,OAAOC,QAAQ,CAACG,GAAG,CAAC;IACxB;;IAEA;IACA,IAAIC,KAAK,IAAI,OAAOA,KAAK,CAACG,MAAM,KAAKZ,QAAQ,IAAI,CAACS,KAAK,CAACG,MAAM,EAAE,EAAE;MAC9D,OAAOP,QAAQ,CAAC,IAAIQ,KAAK,CAAE,IAAGT,OAAQ,kBAAiB,CAAC,CAAC;IAC7D;;IAEA;IACA;IACA;IACA,IAAIK,KAAK,IAAI,EAAEA,KAAK,CAACK,IAAI,GAAG,KAAK,CAAC,EAAE;MAChC,OAAOT,QAAQ,CAAC,IAAIQ,KAAK,CAAE,IAAGT,OAAQ,2BAA0B,CAAC,CAAC;IACtE;;IAEA;IACA;IACA;IACA;IACAE,UAAU,GAAGH,QAAQ,CAACD,gBAAgB,CAACE,OAAO,CAAC;;IAE/C;IACA;IACA;IACA;IACA;IACAE,UAAU,CAACS,eAAe,GAAG,UAAUV,QAAQ,EAAE;MAC7C;MACA,OAAOH,gBAAgB,CAACC,QAAQ,EAAEC,OAAO,EAAEC,QAAQ,CAAC;IACxD,CAAC;IAEDA,QAAQ,CAAC,IAAI,EAAEC,UAAU,CAAC;EAC9B,CAAC,CAAC;AACN,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAU,MAAM,CAACC,OAAO,GAAG;EACb;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,QAAQ,CAAEC,EAAE,EAAEC,GAAG,EAAE;IACf;IACA,IAAIC,IAAI,GAAGC,KAAK,CAACC,SAAS,CAACC,KAAK,CAACC,IAAI,CAACC,SAAS,EAAE,CAAC,CAAC;IAEnD,IAAI;MACC,OAAOP,EAAE,KAAKnB,QAAQ,IAAKmB,EAAE,CAACQ,KAAK,CAACP,GAAG,IAAIQ,MAAM,EAAEP,IAAI,CAAC;IAC7D,CAAC,CACD,OAAOb,GAAG,EAAE;MACR,OAAOA,GAAG;IACd;EACJ,CAAC;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIqB,UAAU,CAAEC,IAAI,EAAEC,GAAG,EAAE;IACnB,IAAIC,IAAI;;IAER;IACA,KAAKA,IAAI,IAAID,GAAG,EAAE;MACd,IAAIE,MAAM,CAACC,cAAc,CAACT,IAAI,CAACM,GAAG,EAAEC,IAAI,CAAC,EAAE;QACvCF,IAAI,CAACE,IAAI,CAAC,GAAGD,GAAG,CAACC,IAAI,CAAC;MAC1B;IACJ;;IAEA;IACA,KAAKA,IAAI,IAAIF,IAAI,EAAE;MACf,IAAIG,MAAM,CAACC,cAAc,CAACT,IAAI,CAACK,IAAI,EAAEE,IAAI,CAAC,IAAI,CAACC,MAAM,CAACC,cAAc,CAACT,IAAI,CAACM,GAAG,EAAEC,IAAI,CAAC,EAAE;QAClF,OAAOF,IAAI,CAACE,IAAI,CAAC;MACrB;IACJ;IAEA,OAAOF,IAAI;EACf,CAAC;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI5B,gBAAgB,CAAEC,QAAQ,EAAEC,OAAO,EAAEC,QAAQ,EAAE;IAC3C;IACA,IAAI,CAACF,QAAQ,EAAE;MACX,OAAOE,QAAQ,CAAC,IAAIQ,KAAK,CAAC,6BAA6B,CAAC,CAAC;IAC7D;;IAEA;IACA,IAAI,OAAOV,QAAQ,CAACI,IAAI,KAAKP,QAAQ,IAAI,OAAOG,QAAQ,CAACD,gBAAgB,KAAKF,QAAQ,EAAE;MACpF,OAAOK,QAAQ,CAAC,IAAIQ,KAAK,CAAC,kCAAkC,CAAC,CAAC;IAClE;;IAEA;IACA,IAAI,CAACT,OAAO,IAAI,OAAOA,OAAO,KAAKH,MAAM,EAAE;MACvC,OAAOI,QAAQ,CAAC,IAAIQ,KAAK,CAAC,gCAAgC,CAAC,CAAC;IAChE;;IAEA;IACA;IACA;IACA,OAAOX,gBAAgB,CAACC,QAAQ,EAAEC,OAAO,EAAEC,QAAQ,CAAC;EACxD;AACJ,CAAC"},"metadata":{},"sourceType":"script"}