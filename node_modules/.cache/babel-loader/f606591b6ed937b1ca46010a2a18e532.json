{"ast":null,"code":"var\n  /**\n   * @private\n   * @const\n   * @type {Object}\n   */\n  db = require('./db.json'),\n  /**\n   * @private\n   * @const\n   * @type {String}\n   * @default\n   */\n  SEP = '/',\n  /**\n   * @private\n   * @const\n   * @type {String}\n   * @default\n   */\n  E = '',\n  /**\n   * @private\n   * @const\n   * @type {String}\n   * @default\n   */\n  TEXT = 'text',\n  /**\n   * @private\n   * @const\n   * @type {String}\n   * @default\n   */\n  RAW = 'raw',\n  /**\n   * @private\n   * @const\n   * @type {String}\n   * @default\n   */\n  UNKNOWN = 'unknown',\n  /**\n   * @private\n   * @const\n   * @type {String}\n   * @default\n   */\n  PLAIN = 'plain',\n  /**\n   * All the content type base types that mostly mean what they are meant to do!\n   *\n   * @private\n   * @const\n   * @type {RegExp}\n   * @default\n   */\n  AUDIO_VIDEO_IMAGE_TEXT = /(audio|video|image|text)/,\n  /**\n   * A blanket check for commonly used keywords that are associated with text content type\n   *\n   * @private\n   * @const\n   * @type {RegExp}\n   * @default\n   */\n  JSON_XML_SCRIPT_SIBLINGS = /(jsonp|json|xml|html|yaml|vml|webml|script)/,\n  /**\n   * Same check as the sure-shot bases, except that these must be sub-types\n   *\n   * @private\n   * @const\n   * @type {RegExp}\n   * @default\n   */\n  AUDIO_VIDEO_IMAGE_TEXT_SUBTYPE = /\\/[^\\/]*(audio|video|image|text)/,\n  /**\n   * The content type bases that are not well defined or ambiguous to classify\n   *\n   * @private\n   * @const\n   * @type {RegExp}\n   * @default\n   */\n  APPLICATION_MESSAGE_MULTIPART = /(application|message|multipart)/;\n\n/**\n * Simple module to lookup the base format of HTTP response bodies from the content-type header\n * @module mime-format\n */\n\nmodule.exports = {\n  /**\n   * Attempts to guess the format by analysing mime type and not a db lookup\n   * @private\n   * @param {String} mime - contentType header value\n   * @returns {Object}\n   */\n  guess: function (mime) {\n    var info = {\n        type: UNKNOWN,\n        format: RAW,\n        guessed: true\n      },\n      match,\n      base;\n\n    // extract the mime base\n    base = (base = mime.split(SEP)) && base[0] || E;\n\n    // bail out on the mime types that are sure-shot ones with no ambiguity\n    match = base.match(AUDIO_VIDEO_IMAGE_TEXT);\n    if (match && match[1]) {\n      info.type = info.format = match[1];\n\n      // we do special kane matching to extract the format in case the match was text\n      // this ensures that we get same formats like we will do in kane match later down the line\n      if (info.type === TEXT) {\n        match = mime.match(JSON_XML_SCRIPT_SIBLINGS);\n        info.format = match && match[1] || PLAIN;\n      }\n      return info;\n    }\n\n    // we do a kane match on entire mime (not just base) to find texts\n    match = mime.match(JSON_XML_SCRIPT_SIBLINGS);\n    if (match && match[1]) {\n      info.type = TEXT;\n      info.format = match[1];\n      return info;\n    }\n\n    // now we match the subtype having names from the sure shot bases\n    match = mime.match(AUDIO_VIDEO_IMAGE_TEXT_SUBTYPE);\n    if (match && match[1]) {\n      info.type = info.format = match[1];\n      return info;\n    }\n\n    // now that most text and sure-shot types and sub-types are out of our way, we detect standard bases\n    // and rest are unknown\n    match = base.match(APPLICATION_MESSAGE_MULTIPART);\n    if (match && match[1]) {\n      info.type = match[1];\n      info.format = RAW;\n      return info;\n    }\n\n    // at this point nothing has matched nothing. it is worth keeping a note of it\n    info.orphan = true;\n    return info;\n  },\n  /**\n   * Finds the mime-format of the provided Content-Type\n   * @param {String} mime - Content-Type for which you want to find the mime format. e.g <b><i>application/xml</i></b>.\n   * @returns {Object}\n   * @example <caption>Basic usage</caption>\n   * mimeFormat.lookup('application/xml');\n   *\n   * // Output\n   * // {\n   * //   \"type\": \"text\",\n   * //   \"format\": \"xml\"\n   * // }\n   *\n   * @example <caption>Content-Type with charset</caption>\n   * mimeFormat.lookup('application/xml; charset=gBk');\n   *\n   * // Output\n   * // {\n   * //   \"type\": \"text\",\n   * //   \"format\": \"xml\",\n   * //   \"charset\": \"gBk\"\n   * // }\n   *\n   * @example <caption>Unknown Content-Type</caption>\n   * mimeFormat.lookup('random/abc');\n   *\n   * // Output\n   * // {\n   * //   \"type\": \"unknown\",\n   * //   \"format\": \"raw\",\n   * //   \"guessed\": true,\n   * //   \"orphan\": true\n   * // }\n   *\n   */\n  lookup: function mimeFormatLookup(mime) {\n    var charset = require('charset')(mime),\n      result;\n\n    // sanitise the mime argument\n    mime = String(mime).toLowerCase().replace(/\\s/g, E).replace(/^([^;]+).*$/g, '$1');\n    result = db[mime];\n    result = result ? Object.assign({}, result) : module.exports.guess(mime);\n\n    // add the charset info to the mime.\n    result && charset && (result.charset = charset);\n    result && (result.source = mime); // store the sanitised mime\n    return result;\n  }\n};","map":{"version":3,"names":["db","require","SEP","E","TEXT","RAW","UNKNOWN","PLAIN","AUDIO_VIDEO_IMAGE_TEXT","JSON_XML_SCRIPT_SIBLINGS","AUDIO_VIDEO_IMAGE_TEXT_SUBTYPE","APPLICATION_MESSAGE_MULTIPART","module","exports","guess","mime","info","type","format","guessed","match","base","split","orphan","lookup","mimeFormatLookup","charset","result","String","toLowerCase","replace","Object","assign","source"],"sources":["/Users/Qusai.Qishta/node_modules/mime-format/index.js"],"sourcesContent":["var /**\n     * @private\n     * @const\n     * @type {Object}\n     */\n    db = require('./db.json'),\n    /**\n     * @private\n     * @const\n     * @type {String}\n     * @default\n     */\n    SEP = '/',\n    /**\n     * @private\n     * @const\n     * @type {String}\n     * @default\n     */\n    E = '',\n    /**\n     * @private\n     * @const\n     * @type {String}\n     * @default\n     */\n    TEXT = 'text',\n    /**\n     * @private\n     * @const\n     * @type {String}\n     * @default\n     */\n    RAW = 'raw',\n    /**\n     * @private\n     * @const\n     * @type {String}\n     * @default\n     */\n    UNKNOWN = 'unknown',\n    /**\n     * @private\n     * @const\n     * @type {String}\n     * @default\n     */\n    PLAIN = 'plain',\n\n    /**\n     * All the content type base types that mostly mean what they are meant to do!\n     *\n     * @private\n     * @const\n     * @type {RegExp}\n     * @default\n     */\n    AUDIO_VIDEO_IMAGE_TEXT = /(audio|video|image|text)/,\n    /**\n     * A blanket check for commonly used keywords that are associated with text content type\n     *\n     * @private\n     * @const\n     * @type {RegExp}\n     * @default\n     */\n    JSON_XML_SCRIPT_SIBLINGS = /(jsonp|json|xml|html|yaml|vml|webml|script)/,\n    /**\n     * Same check as the sure-shot bases, except that these must be sub-types\n     *\n     * @private\n     * @const\n     * @type {RegExp}\n     * @default\n     */\n    AUDIO_VIDEO_IMAGE_TEXT_SUBTYPE = /\\/[^\\/]*(audio|video|image|text)/,\n    /**\n     * The content type bases that are not well defined or ambiguous to classify\n     *\n     * @private\n     * @const\n     * @type {RegExp}\n     * @default\n     */\n    APPLICATION_MESSAGE_MULTIPART = /(application|message|multipart)/;\n\n/**\n * Simple module to lookup the base format of HTTP response bodies from the content-type header\n * @module mime-format\n */\n\nmodule.exports = {\n    /**\n     * Attempts to guess the format by analysing mime type and not a db lookup\n     * @private\n     * @param {String} mime - contentType header value\n     * @returns {Object}\n     */\n    guess: function (mime) {\n\n        var info = {\n                type: UNKNOWN,\n                format: RAW,\n                guessed: true\n            },\n            match,\n            base;\n\n        // extract the mime base\n        base = (base = mime.split(SEP)) && base[0] || E;\n\n        // bail out on the mime types that are sure-shot ones with no ambiguity\n        match = base.match(AUDIO_VIDEO_IMAGE_TEXT);\n        if (match && match[1]) {\n            info.type = info.format = match[1];\n\n            // we do special kane matching to extract the format in case the match was text\n            // this ensures that we get same formats like we will do in kane match later down the line\n            if (info.type === TEXT) {\n                match = mime.match(JSON_XML_SCRIPT_SIBLINGS);\n                info.format = match && match[1] || PLAIN;\n            }\n            return info;\n        }\n\n        // we do a kane match on entire mime (not just base) to find texts\n        match = mime.match(JSON_XML_SCRIPT_SIBLINGS);\n        if (match && match[1]) {\n            info.type = TEXT;\n            info.format = match[1];\n            return info;\n        }\n\n        // now we match the subtype having names from the sure shot bases\n        match = mime.match(AUDIO_VIDEO_IMAGE_TEXT_SUBTYPE);\n        if (match && match[1]) {\n            info.type = info.format = match[1];\n            return info;\n        }\n\n        // now that most text and sure-shot types and sub-types are out of our way, we detect standard bases\n        // and rest are unknown\n        match = base.match(APPLICATION_MESSAGE_MULTIPART);\n        if (match && match[1]) {\n            info.type = match[1];\n            info.format = RAW;\n            return info;\n        }\n\n        // at this point nothing has matched nothing. it is worth keeping a note of it\n        info.orphan = true;\n        return info;\n    },\n\n    /**\n     * Finds the mime-format of the provided Content-Type\n     * @param {String} mime - Content-Type for which you want to find the mime format. e.g <b><i>application/xml</i></b>.\n     * @returns {Object}\n     * @example <caption>Basic usage</caption>\n     * mimeFormat.lookup('application/xml');\n     *\n     * // Output\n     * // {\n     * //   \"type\": \"text\",\n     * //   \"format\": \"xml\"\n     * // }\n     *\n     * @example <caption>Content-Type with charset</caption>\n     * mimeFormat.lookup('application/xml; charset=gBk');\n     *\n     * // Output\n     * // {\n     * //   \"type\": \"text\",\n     * //   \"format\": \"xml\",\n     * //   \"charset\": \"gBk\"\n     * // }\n     *\n     * @example <caption>Unknown Content-Type</caption>\n     * mimeFormat.lookup('random/abc');\n     *\n     * // Output\n     * // {\n     * //   \"type\": \"unknown\",\n     * //   \"format\": \"raw\",\n     * //   \"guessed\": true,\n     * //   \"orphan\": true\n     * // }\n     *\n     */\n    lookup: function mimeFormatLookup (mime) {\n        var charset = require('charset')(mime),\n            result;\n\n        // sanitise the mime argument\n        mime = String(mime).toLowerCase().replace(/\\s/g, E).replace(/^([^;]+).*$/g, '$1');\n\n        result = db[mime];\n        result = result ? Object.assign({}, result) : module.exports.guess(mime);\n\n        // add the charset info to the mime.\n        result && charset && (result.charset = charset);\n        result && (result.source = mime); // store the sanitised mime\n        return result;\n    }\n};\n"],"mappings":"AAAA;EAAI;AACJ;AACA;AACA;AACA;EACIA,EAAE,GAAGC,OAAO,CAAC,WAAW,CAAC;EACzB;AACJ;AACA;AACA;AACA;AACA;EACIC,GAAG,GAAG,GAAG;EACT;AACJ;AACA;AACA;AACA;AACA;EACIC,CAAC,GAAG,EAAE;EACN;AACJ;AACA;AACA;AACA;AACA;EACIC,IAAI,GAAG,MAAM;EACb;AACJ;AACA;AACA;AACA;AACA;EACIC,GAAG,GAAG,KAAK;EACX;AACJ;AACA;AACA;AACA;AACA;EACIC,OAAO,GAAG,SAAS;EACnB;AACJ;AACA;AACA;AACA;AACA;EACIC,KAAK,GAAG,OAAO;EAEf;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,sBAAsB,GAAG,0BAA0B;EACnD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,wBAAwB,GAAG,6CAA6C;EACxE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,8BAA8B,GAAG,kCAAkC;EACnE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,6BAA6B,GAAG,iCAAiC;;AAErE;AACA;AACA;AACA;;AAEAC,MAAM,CAACC,OAAO,GAAG;EACb;AACJ;AACA;AACA;AACA;AACA;EACIC,KAAK,EAAE,UAAUC,IAAI,EAAE;IAEnB,IAAIC,IAAI,GAAG;QACHC,IAAI,EAAEX,OAAO;QACbY,MAAM,EAAEb,GAAG;QACXc,OAAO,EAAE;MACb,CAAC;MACDC,KAAK;MACLC,IAAI;;IAER;IACAA,IAAI,GAAG,CAACA,IAAI,GAAGN,IAAI,CAACO,KAAK,CAACpB,GAAG,CAAC,KAAKmB,IAAI,CAAC,CAAC,CAAC,IAAIlB,CAAC;;IAE/C;IACAiB,KAAK,GAAGC,IAAI,CAACD,KAAK,CAACZ,sBAAsB,CAAC;IAC1C,IAAIY,KAAK,IAAIA,KAAK,CAAC,CAAC,CAAC,EAAE;MACnBJ,IAAI,CAACC,IAAI,GAAGD,IAAI,CAACE,MAAM,GAAGE,KAAK,CAAC,CAAC,CAAC;;MAElC;MACA;MACA,IAAIJ,IAAI,CAACC,IAAI,KAAKb,IAAI,EAAE;QACpBgB,KAAK,GAAGL,IAAI,CAACK,KAAK,CAACX,wBAAwB,CAAC;QAC5CO,IAAI,CAACE,MAAM,GAAGE,KAAK,IAAIA,KAAK,CAAC,CAAC,CAAC,IAAIb,KAAK;MAC5C;MACA,OAAOS,IAAI;IACf;;IAEA;IACAI,KAAK,GAAGL,IAAI,CAACK,KAAK,CAACX,wBAAwB,CAAC;IAC5C,IAAIW,KAAK,IAAIA,KAAK,CAAC,CAAC,CAAC,EAAE;MACnBJ,IAAI,CAACC,IAAI,GAAGb,IAAI;MAChBY,IAAI,CAACE,MAAM,GAAGE,KAAK,CAAC,CAAC,CAAC;MACtB,OAAOJ,IAAI;IACf;;IAEA;IACAI,KAAK,GAAGL,IAAI,CAACK,KAAK,CAACV,8BAA8B,CAAC;IAClD,IAAIU,KAAK,IAAIA,KAAK,CAAC,CAAC,CAAC,EAAE;MACnBJ,IAAI,CAACC,IAAI,GAAGD,IAAI,CAACE,MAAM,GAAGE,KAAK,CAAC,CAAC,CAAC;MAClC,OAAOJ,IAAI;IACf;;IAEA;IACA;IACAI,KAAK,GAAGC,IAAI,CAACD,KAAK,CAACT,6BAA6B,CAAC;IACjD,IAAIS,KAAK,IAAIA,KAAK,CAAC,CAAC,CAAC,EAAE;MACnBJ,IAAI,CAACC,IAAI,GAAGG,KAAK,CAAC,CAAC,CAAC;MACpBJ,IAAI,CAACE,MAAM,GAAGb,GAAG;MACjB,OAAOW,IAAI;IACf;;IAEA;IACAA,IAAI,CAACO,MAAM,GAAG,IAAI;IAClB,OAAOP,IAAI;EACf,CAAC;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIQ,MAAM,EAAE,SAASC,gBAAgB,CAAEV,IAAI,EAAE;IACrC,IAAIW,OAAO,GAAGzB,OAAO,CAAC,SAAS,CAAC,CAACc,IAAI,CAAC;MAClCY,MAAM;;IAEV;IACAZ,IAAI,GAAGa,MAAM,CAACb,IAAI,CAAC,CAACc,WAAW,EAAE,CAACC,OAAO,CAAC,KAAK,EAAE3B,CAAC,CAAC,CAAC2B,OAAO,CAAC,cAAc,EAAE,IAAI,CAAC;IAEjFH,MAAM,GAAG3B,EAAE,CAACe,IAAI,CAAC;IACjBY,MAAM,GAAGA,MAAM,GAAGI,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEL,MAAM,CAAC,GAAGf,MAAM,CAACC,OAAO,CAACC,KAAK,CAACC,IAAI,CAAC;;IAExE;IACAY,MAAM,IAAID,OAAO,KAAKC,MAAM,CAACD,OAAO,GAAGA,OAAO,CAAC;IAC/CC,MAAM,KAAKA,MAAM,CAACM,MAAM,GAAGlB,IAAI,CAAC,CAAC,CAAC;IAClC,OAAOY,MAAM;EACjB;AACJ,CAAC"},"metadata":{},"sourceType":"script"}