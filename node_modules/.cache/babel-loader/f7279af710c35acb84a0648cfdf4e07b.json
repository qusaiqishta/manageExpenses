{"ast":null,"code":"/* eslint-disable jsdoc/require-param-type,jsdoc/require-param-description */\nvar dns = require('dns'),\n  constants = require('constants'),\n  _ = require('lodash'),\n  uuid = require('uuid'),\n  sdk = require('postman-collection'),\n  urlEncoder = require('postman-url-encoder'),\n  Socket = require('net').Socket,\n  requestBodyBuilders = require('./core-body-builder'),\n  version = require('../../package.json').version,\n  LOCAL_IPV6 = '::1',\n  LOCAL_IPV4 = '127.0.0.1',\n  LOCALHOST = 'localhost',\n  SOCKET_TIMEOUT = 500,\n  COLON = ':',\n  STRING = 'string',\n  HOSTS_TYPE = {\n    HOST_IP_MAP: 'hostIpMap'\n  },\n  HTTPS = 'https',\n  HTTPS_DEFAULT_PORT = 443,\n  HTTP_DEFAULT_PORT = 80,\n  S_CONNECT = 'connect',\n  S_ERROR = 'error',\n  S_TIMEOUT = 'timeout',\n  SSL_OP_NO = 'SSL_OP_NO_',\n  ERROR_ADDRESS_RESOLVE = 'NETERR: getaddrinfo ENOTFOUND ',\n  /**\n   * List of request methods without body.\n   *\n   * @private\n   * @type {Object}\n   *\n   * @note hash is used to reduce the lookup cost\n   *       these methods are picked from the app, which don't support body.\n   * @todo move this list to SDK for parity.\n   */\n  METHODS_WITHOUT_BODY = {\n    get: true,\n    copy: true,\n    head: true,\n    purge: true,\n    unlock: true\n  },\n  /**\n   * List of request options with their corresponding protocol profile behavior property name;\n   *\n   * @private\n   * @type {Object}\n   */\n  PPB_OPTS = {\n    // enable or disable certificate verification\n    strictSSL: 'strictSSL',\n    // maximum number of redirects to follow (default: 10)\n    maxRedirects: 'maxRedirects',\n    // controls redirect behavior\n    // keeping the same convention as Newman\n    followRedirect: 'followRedirects',\n    followAllRedirects: 'followRedirects',\n    // Use an insecure HTTP parser that accepts invalid HTTP headers\n    // Refer: https://nodejs.org/api/cli.html#--insecure-http-parser\n    insecureHTTPParser: 'insecureHTTPParser',\n    // retain `authorization` header when a redirect happens to a different hostname\n    followAuthorizationHeader: 'followAuthorizationHeader',\n    // redirect with the original HTTP method (default: redirects with GET)\n    followOriginalHttpMethod: 'followOriginalHttpMethod',\n    // removes the `referer` header when a redirect happens (default: false)\n    // @note `referer` header set in the initial request will be preserved during redirect chain\n    removeRefererHeader: 'removeRefererHeaderOnRedirect'\n  },\n  /**\n   * System headers which can be removed before sending the request if set\n   * in disabledSystemHeaders protocol profile behavior.\n   *\n   *\n   * @private\n   * @type {Array}\n   */\n  ALLOWED_BLACKLIST_HEADERS = ['content-type', 'content-length', 'accept-encoding', 'connection'],\n  /**\n   * Find the enabled header with the given name.\n   *\n   * @todo Add this helper in Collection SDK.\n   *\n   * @private\n   * @param {HeaderList} headers\n   * @param {String} name\n   * @returns {Header|undefined}\n   */\n  oneNormalizedHeader = function oneNormalizedHeader(headers, name) {\n    var i, header;\n\n    // get all headers with `name`\n    headers = headers.reference[name.toLowerCase()];\n    if (Array.isArray(headers)) {\n      // traverse the headers list in reverse direction in order to find the last enabled\n      for (i = headers.length - 1; i >= 0; i--) {\n        header = headers[i];\n        if (header && !header.disabled) {\n          return header;\n        }\n      }\n\n      // bail out if no enabled header was found\n      return;\n    }\n\n    // return the single enabled header\n    if (headers && !headers.disabled) {\n      return headers;\n    }\n  },\n  /**\n   * Add static system headers if they are not disable using `disabledSystemHeaders`\n   * protocol profile behavior.\n   * Add the system headers provided as requester configuration.\n   *\n   * @note Don't traverse the user provided `disabledSystemHeaders` object\n   * to ensure runtime allowed headers and also for security reasons.\n   *\n   * @private\n   * @param {Request} request\n   * @param {Object} options\n   * @param {Object} disabledHeaders\n   * @param {Object} systemHeaders\n   */\n  addSystemHeaders = function (request, options, disabledHeaders, systemHeaders) {\n    var key,\n      headers = request.headers;\n    [{\n      key: 'User-Agent',\n      value: `PostmanRuntime/${version}`\n    }, {\n      key: 'Accept',\n      value: '*/*'\n    }, {\n      key: 'Cache-Control',\n      value: 'no-cache'\n    }, {\n      key: 'Postman-Token',\n      value: uuid.v4()\n    }, {\n      key: 'Host',\n      value: options.url && options.url.host\n    }, {\n      key: 'Accept-Encoding',\n      value: 'gzip, deflate, br'\n    }, {\n      key: 'Connection',\n      value: 'keep-alive'\n    }].forEach(function (header) {\n      key = header.key.toLowerCase();\n\n      // add system header only if,\n      // 1. there's no user added header\n      // 2. not disabled using disabledSystemHeaders\n      !disabledHeaders[key] && !oneNormalizedHeader(headers, key) && headers.add({\n        key: header.key,\n        value: header.value,\n        system: true\n      });\n    });\n    for (key in systemHeaders) {\n      if (Object.hasOwnProperty.call(systemHeaders, key)) {\n        // upsert instead of add to replace user-defined headers also\n        headers.upsert({\n          key: key,\n          value: systemHeaders[key],\n          system: true\n        });\n      }\n    }\n  },\n  /**\n   * Helper function to extract top level domain for the given hostname\n   *\n   * @private\n   *\n   * @param {String} hostname\n   * @returns {String}\n   */\n  getTLD = function (hostname) {\n    if (!hostname) {\n      return '';\n    }\n    hostname = String(hostname);\n    return hostname.substring(hostname.lastIndexOf('.') + 1);\n  },\n  /**\n   * Abstracts out the logic for domain resolution\n   *\n   * @param options\n   * @param hostLookup\n   * @param hostLookup.type\n   * @param hostLookup.hostIpMap\n   * @param hostname\n   * @param callback\n   */\n  _lookup = function (options, hostLookup, hostname, callback) {\n    var hostIpMap,\n      resolvedFamily = 4,\n      resolvedAddr;\n\n    // first we try to resolve the hostname using hosts file configuration\n    hostLookup && hostLookup.type === HOSTS_TYPE.HOST_IP_MAP && (hostIpMap = hostLookup[HOSTS_TYPE.HOST_IP_MAP]) && (resolvedAddr = hostIpMap[hostname]);\n    if (resolvedAddr) {\n      // since we only get an string for the resolved ip address, we manually find it's family (4 or 6)\n      // there will be at-least one `:` in an IPv6 (https://en.wikipedia.org/wiki/IPv6_address#Representation)\n      resolvedAddr.indexOf(COLON) !== -1 && (resolvedFamily = 6); // eslint-disable-line lodash/prefer-includes\n\n      // returning error synchronously causes uncaught error because listeners are not attached to error events\n      // on socket yet\n      return setImmediate(function () {\n        callback(null, resolvedAddr, resolvedFamily);\n      });\n    }\n\n    // no hosts file configuration provided or no match found. Falling back to normal dns lookup\n    return dns.lookup(hostname, options, callback);\n  },\n  /**\n   * Tries to make a TCP connection to the given host and port. If successful, the connection is immediately\n   * destroyed.\n   *\n   * @param host\n   * @param port\n   * @param callback\n   */\n  connect = function (host, port, callback) {\n    var socket = new Socket(),\n      called,\n      done = function (type) {\n        if (!called) {\n          callback(type === S_CONNECT ? null : true); // eslint-disable-line callback-return\n          called = true;\n          this.destroy();\n        }\n      };\n    socket.setTimeout(SOCKET_TIMEOUT, done.bind(socket, S_TIMEOUT));\n    socket.once('connect', done.bind(socket, S_CONNECT));\n    socket.once('error', done.bind(socket, S_ERROR));\n    socket.connect(port, host);\n    socket = null;\n  },\n  /**\n   * Override DNS lookups in Node, to handle localhost as a special case.\n   * Chrome tries connecting to IPv6 by default, so we try the same thing.\n   *\n   * @param lookupOptions\n   * @param lookupOptions.port\n   * @param lookupOptions.network\n   * @param lookupOptions.network.restrictedAddresses\n   * @param lookupOptions.network.hostLookup\n   * @param lookupOptions.network.hostLookup.type\n   * @param lookupOptions.network.hostLookup.hostIpMap\n   * @param hostname\n   * @param options\n   * @param callback\n   */\n  lookup = function (lookupOptions, hostname, options, callback) {\n    var self = this,\n      lowercaseHost = hostname && hostname.toLowerCase(),\n      networkOpts = lookupOptions.network || {},\n      hostLookup = networkOpts.hostLookup;\n\n    // do dns.lookup if hostname is not one of:\n    // - localhost\n    // - *.localhost\n    if (getTLD(lowercaseHost) !== LOCALHOST) {\n      return _lookup(options, hostLookup, lowercaseHost, function (err, addr, family) {\n        if (err) {\n          return callback(err);\n        }\n        return callback(self.isAddressRestricted(addr, networkOpts) ? new Error(ERROR_ADDRESS_RESOLVE + hostname) : null, addr, family);\n      });\n    }\n\n    // Try checking if we can connect to IPv6 localhost ('::1')\n    connect(LOCAL_IPV6, lookupOptions.port, function (err) {\n      // use IPv4 if we cannot connect to IPv6\n      if (err) {\n        return callback(null, LOCAL_IPV4, 4);\n      }\n      callback(null, LOCAL_IPV6, 6);\n    });\n  },\n  /**\n   * Helper function to return postman-request compatible URL parser which\n   * respects the `disableUrlEncoding` protocol profile behavior.\n   *\n   * @private\n   * @param {Boolean} disableUrlEncoding\n   * @returns {Object}\n   */\n  urlParser = function (disableUrlEncoding) {\n    return {\n      parse(urlToParse) {\n        return urlEncoder.toNodeUrl(urlToParse, disableUrlEncoding);\n      },\n      resolve(base, relative) {\n        if (typeof base === STRING) {\n          // @note we parse base URL here to respect `disableUrlEncoding`\n          // option even though resolveNodeUrl() accepts it as a string\n          base = urlEncoder.toNodeUrl(base, disableUrlEncoding);\n        }\n        return urlEncoder.resolveNodeUrl(base, relative);\n      }\n    };\n  },\n  /**\n   * Resolves given property with protocol profile behavior.\n   * Returns protocolProfileBehavior value if the given property is present.\n   * Else, returns value defined in default options.\n   *\n   * @param {String} property - Property name to look for\n   * @param {Object} defaultOpts - Default request options\n   * @param {Object} protocolProfileBehavior - Protocol profile behaviors\n   * @returns {*} - Resolved request option value\n   */\n  resolveWithProtocolProfileBehavior = function (property, defaultOpts, protocolProfileBehavior) {\n    // bail out if property or defaultOpts is not defined\n    if (!(property && defaultOpts)) {\n      return;\n    }\n    if (Object.hasOwnProperty.call(protocolProfileBehavior, property)) {\n      return protocolProfileBehavior[property];\n    }\n    return defaultOpts[property];\n  };\nmodule.exports = {\n  /**\n   * Creates a node request compatible options object from a request.\n   *\n   * @param request\n   * @param defaultOpts\n   * @param defaultOpts.agents\n   * @param defaultOpts.network\n   * @param defaultOpts.keepAlive\n   * @param defaultOpts.timeout\n   * @param defaultOpts.strictSSL\n   * @param defaultOpts.cookieJar The cookie jar to use (if any).\n   * @param defaultOpts.followRedirects\n   * @param defaultOpts.followOriginalHttpMethod\n   * @param defaultOpts.maxRedirects\n   * @param defaultOpts.maxResponseSize\n   * @param defaultOpts.implicitCacheControl\n   * @param defaultOpts.implicitTraceHeader\n   * @param defaultOpts.removeRefererHeaderOnRedirect\n   * @param defaultOpts.timings\n   * @param protocolProfileBehavior\n   * @returns {{}}\n   */\n  getRequestOptions(request, defaultOpts, protocolProfileBehavior) {\n    !defaultOpts && (defaultOpts = {});\n    !protocolProfileBehavior && (protocolProfileBehavior = {});\n    var options = {},\n      networkOptions = defaultOpts.network || {},\n      self = this,\n      bodyParams,\n      useWhatWGUrlParser = defaultOpts.useWhatWGUrlParser,\n      disableUrlEncoding = protocolProfileBehavior.disableUrlEncoding,\n      disabledSystemHeaders = protocolProfileBehavior.disabledSystemHeaders || {},\n      // the system headers provided in requester configuration\n      systemHeaders = defaultOpts.systemHeaders || {},\n      url = useWhatWGUrlParser ? urlEncoder.toNodeUrl(request.url, disableUrlEncoding) : urlEncoder.toLegacyNodeUrl(request.url.toString(true)),\n      isSSL = _.startsWith(url.protocol, HTTPS),\n      isTunnelingProxy = request.proxy && (request.proxy.tunnel || isSSL),\n      header,\n      reqOption,\n      portNumber,\n      behaviorName,\n      port = url && url.port,\n      hostname = url && url.hostname && url.hostname.toLowerCase(),\n      proxyHostname = request.proxy && request.proxy.host;\n\n    // resolve all *.localhost to localhost itself\n    // RFC: 6761 section 6.3 (https://tools.ietf.org/html/rfc6761#section-6.3)\n    if (getTLD(hostname) === LOCALHOST) {\n      // @note setting hostname to localhost ensures that we override lookup function\n      hostname = LOCALHOST;\n    }\n    if (getTLD(proxyHostname) === LOCALHOST) {\n      proxyHostname = LOCALHOST;\n    }\n    options.url = url;\n    options.method = request.method;\n    options.timeout = defaultOpts.timeout;\n    options.gzip = true;\n    options.brotli = true;\n    options.time = defaultOpts.timings;\n    options.verbose = defaultOpts.verbose;\n    options.agents = defaultOpts.agents;\n    options.extraCA = defaultOpts.extendedRootCA;\n    options.ignoreProxyEnvironmentVariables = defaultOpts.ignoreProxyEnvironmentVariables;\n\n    // Disable encoding of URL in postman-request in order to use pre-encoded URL object returned from\n    // toNodeUrl() function of postman-url-encoder\n    options.disableUrlEncoding = true;\n\n    // Ensures that \"request\" creates URL encoded formdata or querystring as\n    // foo=bar&foo=baz instead of foo[0]=bar&foo[1]=baz\n    options.useQuerystring = true;\n\n    // set encoding to null so that the response is a stream\n    options.encoding = null;\n\n    // Re-encode status message using `utf8` character encoding in postman-request.\n    // This is done to  correctly represent status messages with characters that lie outside\n    // the range of `latin1` encoding (which is the default encoding in which status message is returned)\n    options.statusMessageEncoding = 'utf8';\n\n    // eslint-disable-next-line guard-for-in\n    for (reqOption in PPB_OPTS) {\n      behaviorName = PPB_OPTS[reqOption];\n      options[reqOption] = resolveWithProtocolProfileBehavior(behaviorName, defaultOpts, protocolProfileBehavior);\n    }\n\n    // set cookie jar if not disabled\n    if (!protocolProfileBehavior.disableCookies) {\n      options.jar = defaultOpts.cookieJar || true;\n    }\n\n    // use the server's cipher suite order instead of the client's during negotiation\n    if (protocolProfileBehavior.tlsPreferServerCiphers) {\n      options.honorCipherOrder = true;\n    }\n\n    // the SSL and TLS protocol versions to disabled during negotiation\n    if (Array.isArray(protocolProfileBehavior.tlsDisabledProtocols)) {\n      protocolProfileBehavior.tlsDisabledProtocols.forEach(function (protocol) {\n        // since secure options doesn't support TLSv1.3 before Node 14\n        // @todo remove the if condition when we drop support for Node 12\n        if (protocol === 'TLSv1_3' && !constants[SSL_OP_NO + protocol]) {\n          options.maxVersion = 'TLSv1.2';\n        } else {\n          options.secureOptions |= constants[SSL_OP_NO + protocol];\n        }\n      });\n    }\n\n    // order of cipher suites that the SSL server profile uses to establish a secure connection\n    if (Array.isArray(protocolProfileBehavior.tlsCipherSelection)) {\n      options.ciphers = protocolProfileBehavior.tlsCipherSelection.join(':');\n    }\n    if (typeof defaultOpts.maxResponseSize === 'number') {\n      options.maxResponseSize = defaultOpts.maxResponseSize;\n    }\n\n    // Request body may return different options depending on the type of the body.\n    // @note getRequestBody may add system headers based on intent\n    bodyParams = self.getRequestBody(request, protocolProfileBehavior);\n\n    // Disable 'Cache-Control' and 'Postman-Token' based on global options\n    // @note this also make 'cache-control' and 'postman-token' part of `disabledSystemHeaders`\n    !defaultOpts.implicitCacheControl && (disabledSystemHeaders['cache-control'] = true);\n    !defaultOpts.implicitTraceHeader && (disabledSystemHeaders['postman-token'] = true);\n\n    // Add additional system headers to the request instance\n    addSystemHeaders(request, options, disabledSystemHeaders, systemHeaders);\n\n    // Don't add `Host` header if disabled using disabledSystemHeaders\n    // @note This can't be part of `blacklistHeaders` option as `setHost` is\n    // a Node.js http.request option to specifies whether or not to\n    // automatically add the Host header or not.\n    if (disabledSystemHeaders.host) {\n      header = oneNormalizedHeader(request.headers, 'host');\n\n      // only possible with AWS auth\n      header && header.system && (header.disabled = true);\n\n      // set `setHost` to false if there's no host header defined by the user\n      // or, the present host is added by the system.\n      (!header || header.system) && (options.setHost = false);\n    }\n\n    // Set `allowContentTypeOverride` if content-type header is disabled,\n    // this allows overriding (if invalid) the content-type for form-data\n    // and urlencoded request body.\n    if (disabledSystemHeaders['content-type']) {\n      options.allowContentTypeOverride = true;\n    }\n    options.blacklistHeaders = [];\n    ALLOWED_BLACKLIST_HEADERS.forEach(function (headerKey) {\n      if (!disabledSystemHeaders[headerKey]) {\n        return;\n      } // not disabled\n\n      header = oneNormalizedHeader(request.headers, headerKey);\n\n      // content-type added by body helper\n      header && header.system && (header.disabled = true);\n\n      // blacklist only if it's missing or part of system added headers\n      (!header || header.system) && options.blacklistHeaders.push(headerKey);\n\n      // @note for non-GET requests if no 'content-length' is set, it\n      // it assumes to be chucked request body and add 'transfer-encoding'\n      // here, we ensure blacklisting 'content-length' will also blacklist\n      // 'transfer-encoding' header.\n      if (headerKey === 'content-length') {\n        header = oneNormalizedHeader(request.headers, 'transfer-encoding');\n        (!header || header.system) && options.blacklistHeaders.push('transfer-encoding');\n      }\n    });\n\n    // Finally, get headers object\n    options.headers = request.getHeaders({\n      enabled: true,\n      sanitizeKeys: true\n    });\n\n    // override URL parser to WhatWG URL parser\n    if (useWhatWGUrlParser) {\n      options.urlParser = urlParser(disableUrlEncoding);\n    }\n\n    // override DNS lookup\n    if (networkOptions.restrictedAddresses || hostname === LOCALHOST || !isTunnelingProxy && proxyHostname === LOCALHOST || networkOptions.hostLookup) {\n      // Use proxy port for localhost resolution in case of non-tunneling proxy\n      // because the request will be sent to proxy server by postman-request\n      if (request.proxy && !isTunnelingProxy) {\n        portNumber = Number(request.proxy.port);\n      }\n      // Otherwise, use request's port\n      else {\n        portNumber = Number(port) || (isSSL ? HTTPS_DEFAULT_PORT : HTTP_DEFAULT_PORT);\n      }\n      _.isFinite(portNumber) && (options.lookup = lookup.bind(this, {\n        port: portNumber,\n        network: networkOptions\n      }));\n    }\n    _.assign(options, bodyParams, {\n      // @note these common agent options can be overridden by specifying\n      // custom http/https agents using requester option `agents`\n      agentOptions: {\n        keepAlive: defaultOpts.keepAlive\n      }\n    });\n    return options;\n  },\n  /**\n   * Processes a request body and puts it in a format compatible with\n   * the \"request\" library.\n   *\n   * @todo: Move this to the SDK.\n   * @param request - Request object\n   * @param protocolProfileBehavior - Protocol profile behaviors\n   *\n   * @returns {Object}\n   */\n  getRequestBody(request, protocolProfileBehavior) {\n    if (!(request && request.body)) {\n      return;\n    }\n    var i,\n      property,\n      requestBody = request.body,\n      requestBodyType = requestBody.mode,\n      requestMethod = typeof request.method === STRING ? request.method.toLowerCase() : undefined,\n      bodyIsEmpty = requestBody.isEmpty(),\n      bodyIsDisabled = requestBody.disabled,\n      bodyContent = requestBody[requestBodyType],\n      // flag to decide body pruning for METHODS_WITHOUT_BODY\n      // @note this will be `true` even if protocolProfileBehavior is undefined\n      pruneBody = protocolProfileBehavior ? !protocolProfileBehavior.disableBodyPruning : true;\n\n    // early bailout for empty or disabled body (this area has some legacy shenanigans)\n    if (bodyIsEmpty || bodyIsDisabled) {\n      return;\n    }\n\n    // body is empty if all the params in urlencoded and formdata body are disabled\n    // @todo update Collection SDK isEmpty method to account for this\n    if (sdk.PropertyList.isPropertyList(bodyContent)) {\n      bodyIsEmpty = true;\n      for (i = bodyContent.members.length - 1; i >= 0; i--) {\n        property = bodyContent.members[i];\n        // bail out if a single enabled property is present\n        if (property && !property.disabled) {\n          bodyIsEmpty = false;\n          break;\n        }\n      }\n\n      // bail out if body is empty\n      if (bodyIsEmpty) {\n        return;\n      }\n    }\n\n    // bail out if request method doesn't support body and pruneBody is true.\n    if (METHODS_WITHOUT_BODY[requestMethod] && pruneBody) {\n      return;\n    }\n\n    // even if body is not empty, but the body type is not known, we do not know how to parse the same\n    //\n    // @note if you'd like to support additional body types beyond formdata, url-encoding, etc, add the same to\n    //       the builder module\n    if (!Object.hasOwnProperty.call(requestBodyBuilders, requestBodyType)) {\n      return;\n    }\n    return requestBodyBuilders[requestBodyType](bodyContent, request);\n  },\n  /**\n   * Returns a JSON compatible with the Node's request library. (Also contains the original request)\n   *\n   * @param rawResponse Can be an XHR response or a Node request compatible response.\n   *              about the actual request that was sent.\n   * @param requestOptions Options that were used to send the request.\n   * @param responseBody Body as a string.\n   */\n  jsonifyResponse(rawResponse, requestOptions, responseBody) {\n    if (!rawResponse) {\n      return;\n    }\n    var responseJSON;\n    if (rawResponse.toJSON) {\n      responseJSON = rawResponse.toJSON();\n      responseJSON.request && _.assign(responseJSON.request, {\n        data: requestOptions.form || requestOptions.formData || requestOptions.body || {},\n        uri: {\n          // @todo remove this\n          href: requestOptions.url && requestOptions.url.href || requestOptions.url\n        },\n        url: requestOptions.url && requestOptions.url.href || requestOptions.url\n      });\n      rawResponse.rawHeaders && (responseJSON.headers = this.arrayPairsToObject(rawResponse.rawHeaders) || responseJSON.headers);\n      return responseJSON;\n    }\n    responseBody = responseBody || '';\n\n    // @todo drop support or isolate XHR requester in v8\n    // XHR :/\n    return {\n      statusCode: rawResponse.status,\n      body: responseBody,\n      headers: _.transform(sdk.Header.parse(rawResponse.getAllResponseHeaders()), function (acc, header) {\n        if (acc[header.key]) {\n          !Array.isArray(acc[header.key]) && (acc[header.key] = [acc[header.key]]);\n          acc[header.key].push(header.value);\n        } else {\n          acc[header.key] = header.value;\n        }\n      }, {}),\n      request: {\n        method: requestOptions.method || 'GET',\n        headers: requestOptions.headers,\n        uri: {\n          // @todo remove this\n          href: requestOptions.url && requestOptions.url.href || requestOptions.url\n        },\n        url: requestOptions.url && requestOptions.url.href || requestOptions.url,\n        data: requestOptions.form || requestOptions.formData || requestOptions.body || {}\n      }\n    };\n  },\n  /**\n   * ArrayBuffer to String\n   *\n   * @param {ArrayBuffer} buffer\n   * @returns {String}\n   */\n  arrayBufferToString(buffer) {\n    var str = '',\n      uArrayVal = new Uint8Array(buffer),\n      i,\n      ii;\n    for (i = 0, ii = uArrayVal.length; i < ii; i++) {\n      str += String.fromCharCode(uArrayVal[i]);\n    }\n    return str;\n  },\n  /**\n   * Converts an array of sequential pairs to an object.\n   *\n   * @param arr\n   * @returns {{}}\n   *\n   * @example\n   * ['a', 'b', 'c', 'd'] ====> {a: 'b', c: 'd' }\n   */\n  arrayPairsToObject(arr) {\n    if (!_.isArray(arr)) {\n      return;\n    }\n    var obj = {},\n      key,\n      val,\n      i,\n      ii;\n    for (i = 0, ii = arr.length; i < ii; i += 2) {\n      key = arr[i];\n      val = arr[i + 1];\n      if (_.has(obj, key)) {\n        !_.isArray(obj[key]) && (obj[key] = [obj[key]]);\n        obj[key].push(val);\n      } else {\n        obj[key] = val;\n      }\n    }\n    return obj;\n  },\n  /**\n   * Checks if a given host or IP is has been restricted in the options.\n   *\n   * @param {String} host\n   * @param {Object} networkOptions\n   * @param {Array<String>} networkOptions.restrictedAddresses\n   *\n   * @returns {Boolean}\n   */\n  isAddressRestricted(host, networkOptions) {\n    return networkOptions.restrictedAddresses && networkOptions.restrictedAddresses[host && host.toLowerCase()];\n  }\n};","map":{"version":3,"names":["dns","require","constants","_","uuid","sdk","urlEncoder","Socket","requestBodyBuilders","version","LOCAL_IPV6","LOCAL_IPV4","LOCALHOST","SOCKET_TIMEOUT","COLON","STRING","HOSTS_TYPE","HOST_IP_MAP","HTTPS","HTTPS_DEFAULT_PORT","HTTP_DEFAULT_PORT","S_CONNECT","S_ERROR","S_TIMEOUT","SSL_OP_NO","ERROR_ADDRESS_RESOLVE","METHODS_WITHOUT_BODY","get","copy","head","purge","unlock","PPB_OPTS","strictSSL","maxRedirects","followRedirect","followAllRedirects","insecureHTTPParser","followAuthorizationHeader","followOriginalHttpMethod","removeRefererHeader","ALLOWED_BLACKLIST_HEADERS","oneNormalizedHeader","headers","name","i","header","reference","toLowerCase","Array","isArray","length","disabled","addSystemHeaders","request","options","disabledHeaders","systemHeaders","key","value","v4","url","host","forEach","add","system","Object","hasOwnProperty","call","upsert","getTLD","hostname","String","substring","lastIndexOf","_lookup","hostLookup","callback","hostIpMap","resolvedFamily","resolvedAddr","type","indexOf","setImmediate","lookup","connect","port","socket","called","done","destroy","setTimeout","bind","once","lookupOptions","self","lowercaseHost","networkOpts","network","err","addr","family","isAddressRestricted","Error","urlParser","disableUrlEncoding","parse","urlToParse","toNodeUrl","resolve","base","relative","resolveNodeUrl","resolveWithProtocolProfileBehavior","property","defaultOpts","protocolProfileBehavior","module","exports","getRequestOptions","networkOptions","bodyParams","useWhatWGUrlParser","disabledSystemHeaders","toLegacyNodeUrl","toString","isSSL","startsWith","protocol","isTunnelingProxy","proxy","tunnel","reqOption","portNumber","behaviorName","proxyHostname","method","timeout","gzip","brotli","time","timings","verbose","agents","extraCA","extendedRootCA","ignoreProxyEnvironmentVariables","useQuerystring","encoding","statusMessageEncoding","disableCookies","jar","cookieJar","tlsPreferServerCiphers","honorCipherOrder","tlsDisabledProtocols","maxVersion","secureOptions","tlsCipherSelection","ciphers","join","maxResponseSize","getRequestBody","implicitCacheControl","implicitTraceHeader","setHost","allowContentTypeOverride","blacklistHeaders","headerKey","push","getHeaders","enabled","sanitizeKeys","restrictedAddresses","Number","isFinite","assign","agentOptions","keepAlive","body","requestBody","requestBodyType","mode","requestMethod","undefined","bodyIsEmpty","isEmpty","bodyIsDisabled","bodyContent","pruneBody","disableBodyPruning","PropertyList","isPropertyList","members","jsonifyResponse","rawResponse","requestOptions","responseBody","responseJSON","toJSON","data","form","formData","uri","href","rawHeaders","arrayPairsToObject","statusCode","status","transform","Header","getAllResponseHeaders","acc","arrayBufferToString","buffer","str","uArrayVal","Uint8Array","ii","fromCharCode","arr","obj","val","has"],"sources":["/Users/Qusai.Qishta/node_modules/postman-runtime/lib/requester/core.js"],"sourcesContent":["/* eslint-disable jsdoc/require-param-type,jsdoc/require-param-description */\nvar dns = require('dns'),\n    constants = require('constants'),\n\n    _ = require('lodash'),\n    uuid = require('uuid'),\n    sdk = require('postman-collection'),\n    urlEncoder = require('postman-url-encoder'),\n\n    Socket = require('net').Socket,\n\n    requestBodyBuilders = require('./core-body-builder'),\n    version = require('../../package.json').version,\n\n    LOCAL_IPV6 = '::1',\n    LOCAL_IPV4 = '127.0.0.1',\n    LOCALHOST = 'localhost',\n    SOCKET_TIMEOUT = 500,\n\n    COLON = ':',\n    STRING = 'string',\n    HOSTS_TYPE = {\n        HOST_IP_MAP: 'hostIpMap'\n    },\n    HTTPS = 'https',\n    HTTPS_DEFAULT_PORT = 443,\n    HTTP_DEFAULT_PORT = 80,\n\n    S_CONNECT = 'connect',\n    S_ERROR = 'error',\n    S_TIMEOUT = 'timeout',\n\n    SSL_OP_NO = 'SSL_OP_NO_',\n\n    ERROR_ADDRESS_RESOLVE = 'NETERR: getaddrinfo ENOTFOUND ',\n\n    /**\n     * List of request methods without body.\n     *\n     * @private\n     * @type {Object}\n     *\n     * @note hash is used to reduce the lookup cost\n     *       these methods are picked from the app, which don't support body.\n     * @todo move this list to SDK for parity.\n     */\n    METHODS_WITHOUT_BODY = {\n        get: true,\n        copy: true,\n        head: true,\n        purge: true,\n        unlock: true\n    },\n\n    /**\n     * List of request options with their corresponding protocol profile behavior property name;\n     *\n     * @private\n     * @type {Object}\n     */\n    PPB_OPTS = {\n        // enable or disable certificate verification\n        strictSSL: 'strictSSL',\n\n        // maximum number of redirects to follow (default: 10)\n        maxRedirects: 'maxRedirects',\n\n        // controls redirect behavior\n        // keeping the same convention as Newman\n        followRedirect: 'followRedirects',\n        followAllRedirects: 'followRedirects',\n\n        // Use an insecure HTTP parser that accepts invalid HTTP headers\n        // Refer: https://nodejs.org/api/cli.html#--insecure-http-parser\n        insecureHTTPParser: 'insecureHTTPParser',\n\n        // retain `authorization` header when a redirect happens to a different hostname\n        followAuthorizationHeader: 'followAuthorizationHeader',\n\n        // redirect with the original HTTP method (default: redirects with GET)\n        followOriginalHttpMethod: 'followOriginalHttpMethod',\n\n        // removes the `referer` header when a redirect happens (default: false)\n        // @note `referer` header set in the initial request will be preserved during redirect chain\n        removeRefererHeader: 'removeRefererHeaderOnRedirect'\n    },\n\n    /**\n     * System headers which can be removed before sending the request if set\n     * in disabledSystemHeaders protocol profile behavior.\n     *\n     *\n     * @private\n     * @type {Array}\n     */\n    ALLOWED_BLACKLIST_HEADERS = ['content-type', 'content-length', 'accept-encoding', 'connection'],\n\n    /**\n     * Find the enabled header with the given name.\n     *\n     * @todo Add this helper in Collection SDK.\n     *\n     * @private\n     * @param {HeaderList} headers\n     * @param {String} name\n     * @returns {Header|undefined}\n     */\n    oneNormalizedHeader = function oneNormalizedHeader (headers, name) {\n        var i,\n            header;\n\n        // get all headers with `name`\n        headers = headers.reference[name.toLowerCase()];\n\n        if (Array.isArray(headers)) {\n            // traverse the headers list in reverse direction in order to find the last enabled\n            for (i = headers.length - 1; i >= 0; i--) {\n                header = headers[i];\n\n                if (header && !header.disabled) {\n                    return header;\n                }\n            }\n\n            // bail out if no enabled header was found\n            return;\n        }\n\n        // return the single enabled header\n        if (headers && !headers.disabled) {\n            return headers;\n        }\n    },\n\n    /**\n     * Add static system headers if they are not disable using `disabledSystemHeaders`\n     * protocol profile behavior.\n     * Add the system headers provided as requester configuration.\n     *\n     * @note Don't traverse the user provided `disabledSystemHeaders` object\n     * to ensure runtime allowed headers and also for security reasons.\n     *\n     * @private\n     * @param {Request} request\n     * @param {Object} options\n     * @param {Object} disabledHeaders\n     * @param {Object} systemHeaders\n     */\n    addSystemHeaders = function (request, options, disabledHeaders, systemHeaders) {\n        var key,\n            headers = request.headers;\n\n        [\n            { key: 'User-Agent', value: `PostmanRuntime/${version}` },\n            { key: 'Accept', value: '*/*' },\n            { key: 'Cache-Control', value: 'no-cache' },\n            { key: 'Postman-Token', value: uuid.v4() },\n            { key: 'Host', value: options.url && options.url.host },\n            { key: 'Accept-Encoding', value: 'gzip, deflate, br' },\n            { key: 'Connection', value: 'keep-alive' }\n        ].forEach(function (header) {\n            key = header.key.toLowerCase();\n\n            // add system header only if,\n            // 1. there's no user added header\n            // 2. not disabled using disabledSystemHeaders\n            !disabledHeaders[key] && !oneNormalizedHeader(headers, key) &&\n                headers.add({\n                    key: header.key,\n                    value: header.value,\n                    system: true\n                });\n        });\n\n        for (key in systemHeaders) {\n            if (Object.hasOwnProperty.call(systemHeaders, key)) {\n                // upsert instead of add to replace user-defined headers also\n                headers.upsert({\n                    key: key,\n                    value: systemHeaders[key],\n                    system: true\n                });\n            }\n        }\n    },\n\n    /**\n     * Helper function to extract top level domain for the given hostname\n     *\n     * @private\n     *\n     * @param {String} hostname\n     * @returns {String}\n     */\n    getTLD = function (hostname) {\n        if (!hostname) {\n            return '';\n        }\n\n        hostname = String(hostname);\n\n        return hostname.substring(hostname.lastIndexOf('.') + 1);\n    },\n\n    /**\n     * Abstracts out the logic for domain resolution\n     *\n     * @param options\n     * @param hostLookup\n     * @param hostLookup.type\n     * @param hostLookup.hostIpMap\n     * @param hostname\n     * @param callback\n     */\n    _lookup = function (options, hostLookup, hostname, callback) {\n        var hostIpMap,\n            resolvedFamily = 4,\n            resolvedAddr;\n\n        // first we try to resolve the hostname using hosts file configuration\n        hostLookup && hostLookup.type === HOSTS_TYPE.HOST_IP_MAP &&\n            (hostIpMap = hostLookup[HOSTS_TYPE.HOST_IP_MAP]) && (resolvedAddr = hostIpMap[hostname]);\n\n        if (resolvedAddr) {\n            // since we only get an string for the resolved ip address, we manually find it's family (4 or 6)\n            // there will be at-least one `:` in an IPv6 (https://en.wikipedia.org/wiki/IPv6_address#Representation)\n            resolvedAddr.indexOf(COLON) !== -1 && (resolvedFamily = 6); // eslint-disable-line lodash/prefer-includes\n\n            // returning error synchronously causes uncaught error because listeners are not attached to error events\n            // on socket yet\n            return setImmediate(function () {\n                callback(null, resolvedAddr, resolvedFamily);\n            });\n        }\n\n        // no hosts file configuration provided or no match found. Falling back to normal dns lookup\n        return dns.lookup(hostname, options, callback);\n    },\n\n    /**\n     * Tries to make a TCP connection to the given host and port. If successful, the connection is immediately\n     * destroyed.\n     *\n     * @param host\n     * @param port\n     * @param callback\n     */\n    connect = function (host, port, callback) {\n        var socket = new Socket(),\n            called,\n\n            done = function (type) {\n                if (!called) {\n                    callback(type === S_CONNECT ? null : true); // eslint-disable-line callback-return\n                    called = true;\n                    this.destroy();\n                }\n            };\n\n        socket.setTimeout(SOCKET_TIMEOUT, done.bind(socket, S_TIMEOUT));\n        socket.once('connect', done.bind(socket, S_CONNECT));\n        socket.once('error', done.bind(socket, S_ERROR));\n        socket.connect(port, host);\n        socket = null;\n    },\n\n    /**\n     * Override DNS lookups in Node, to handle localhost as a special case.\n     * Chrome tries connecting to IPv6 by default, so we try the same thing.\n     *\n     * @param lookupOptions\n     * @param lookupOptions.port\n     * @param lookupOptions.network\n     * @param lookupOptions.network.restrictedAddresses\n     * @param lookupOptions.network.hostLookup\n     * @param lookupOptions.network.hostLookup.type\n     * @param lookupOptions.network.hostLookup.hostIpMap\n     * @param hostname\n     * @param options\n     * @param callback\n     */\n    lookup = function (lookupOptions, hostname, options, callback) {\n        var self = this,\n            lowercaseHost = hostname && hostname.toLowerCase(),\n            networkOpts = lookupOptions.network || {},\n            hostLookup = networkOpts.hostLookup;\n\n        // do dns.lookup if hostname is not one of:\n        // - localhost\n        // - *.localhost\n        if (getTLD(lowercaseHost) !== LOCALHOST) {\n            return _lookup(options, hostLookup, lowercaseHost, function (err, addr, family) {\n                if (err) { return callback(err); }\n\n                return callback(self.isAddressRestricted(addr, networkOpts) ?\n                    new Error(ERROR_ADDRESS_RESOLVE + hostname) : null, addr, family);\n            });\n        }\n\n        // Try checking if we can connect to IPv6 localhost ('::1')\n        connect(LOCAL_IPV6, lookupOptions.port, function (err) {\n            // use IPv4 if we cannot connect to IPv6\n            if (err) { return callback(null, LOCAL_IPV4, 4); }\n\n            callback(null, LOCAL_IPV6, 6);\n        });\n    },\n\n    /**\n     * Helper function to return postman-request compatible URL parser which\n     * respects the `disableUrlEncoding` protocol profile behavior.\n     *\n     * @private\n     * @param {Boolean} disableUrlEncoding\n     * @returns {Object}\n     */\n    urlParser = function (disableUrlEncoding) {\n        return {\n            parse (urlToParse) {\n                return urlEncoder.toNodeUrl(urlToParse, disableUrlEncoding);\n            },\n\n            resolve (base, relative) {\n                if (typeof base === STRING) {\n                    // @note we parse base URL here to respect `disableUrlEncoding`\n                    // option even though resolveNodeUrl() accepts it as a string\n                    base = urlEncoder.toNodeUrl(base, disableUrlEncoding);\n                }\n\n                return urlEncoder.resolveNodeUrl(base, relative);\n            }\n        };\n    },\n\n    /**\n     * Resolves given property with protocol profile behavior.\n     * Returns protocolProfileBehavior value if the given property is present.\n     * Else, returns value defined in default options.\n     *\n     * @param {String} property - Property name to look for\n     * @param {Object} defaultOpts - Default request options\n     * @param {Object} protocolProfileBehavior - Protocol profile behaviors\n     * @returns {*} - Resolved request option value\n     */\n    resolveWithProtocolProfileBehavior = function (property, defaultOpts, protocolProfileBehavior) {\n        // bail out if property or defaultOpts is not defined\n        if (!(property && defaultOpts)) { return; }\n\n        if (Object.hasOwnProperty.call(protocolProfileBehavior, property)) {\n            return protocolProfileBehavior[property];\n        }\n\n        return defaultOpts[property];\n    };\n\nmodule.exports = {\n\n    /**\n     * Creates a node request compatible options object from a request.\n     *\n     * @param request\n     * @param defaultOpts\n     * @param defaultOpts.agents\n     * @param defaultOpts.network\n     * @param defaultOpts.keepAlive\n     * @param defaultOpts.timeout\n     * @param defaultOpts.strictSSL\n     * @param defaultOpts.cookieJar The cookie jar to use (if any).\n     * @param defaultOpts.followRedirects\n     * @param defaultOpts.followOriginalHttpMethod\n     * @param defaultOpts.maxRedirects\n     * @param defaultOpts.maxResponseSize\n     * @param defaultOpts.implicitCacheControl\n     * @param defaultOpts.implicitTraceHeader\n     * @param defaultOpts.removeRefererHeaderOnRedirect\n     * @param defaultOpts.timings\n     * @param protocolProfileBehavior\n     * @returns {{}}\n     */\n    getRequestOptions (request, defaultOpts, protocolProfileBehavior) {\n        !defaultOpts && (defaultOpts = {});\n        !protocolProfileBehavior && (protocolProfileBehavior = {});\n\n        var options = {},\n            networkOptions = defaultOpts.network || {},\n            self = this,\n            bodyParams,\n            useWhatWGUrlParser = defaultOpts.useWhatWGUrlParser,\n            disableUrlEncoding = protocolProfileBehavior.disableUrlEncoding,\n            disabledSystemHeaders = protocolProfileBehavior.disabledSystemHeaders || {},\n            // the system headers provided in requester configuration\n            systemHeaders = defaultOpts.systemHeaders || {},\n            url = useWhatWGUrlParser ? urlEncoder.toNodeUrl(request.url, disableUrlEncoding) :\n                urlEncoder.toLegacyNodeUrl(request.url.toString(true)),\n            isSSL = _.startsWith(url.protocol, HTTPS),\n            isTunnelingProxy = request.proxy && (request.proxy.tunnel || isSSL),\n            header,\n            reqOption,\n            portNumber,\n            behaviorName,\n            port = url && url.port,\n            hostname = url && url.hostname && url.hostname.toLowerCase(),\n            proxyHostname = request.proxy && request.proxy.host;\n\n        // resolve all *.localhost to localhost itself\n        // RFC: 6761 section 6.3 (https://tools.ietf.org/html/rfc6761#section-6.3)\n        if (getTLD(hostname) === LOCALHOST) {\n            // @note setting hostname to localhost ensures that we override lookup function\n            hostname = LOCALHOST;\n        }\n\n        if (getTLD(proxyHostname) === LOCALHOST) {\n            proxyHostname = LOCALHOST;\n        }\n\n        options.url = url;\n        options.method = request.method;\n        options.timeout = defaultOpts.timeout;\n        options.gzip = true;\n        options.brotli = true;\n        options.time = defaultOpts.timings;\n        options.verbose = defaultOpts.verbose;\n        options.agents = defaultOpts.agents;\n        options.extraCA = defaultOpts.extendedRootCA;\n        options.ignoreProxyEnvironmentVariables = defaultOpts.ignoreProxyEnvironmentVariables;\n\n        // Disable encoding of URL in postman-request in order to use pre-encoded URL object returned from\n        // toNodeUrl() function of postman-url-encoder\n        options.disableUrlEncoding = true;\n\n        // Ensures that \"request\" creates URL encoded formdata or querystring as\n        // foo=bar&foo=baz instead of foo[0]=bar&foo[1]=baz\n        options.useQuerystring = true;\n\n        // set encoding to null so that the response is a stream\n        options.encoding = null;\n\n        // Re-encode status message using `utf8` character encoding in postman-request.\n        // This is done to  correctly represent status messages with characters that lie outside\n        // the range of `latin1` encoding (which is the default encoding in which status message is returned)\n        options.statusMessageEncoding = 'utf8';\n\n        // eslint-disable-next-line guard-for-in\n        for (reqOption in PPB_OPTS) {\n            behaviorName = PPB_OPTS[reqOption];\n            options[reqOption] = resolveWithProtocolProfileBehavior(behaviorName, defaultOpts, protocolProfileBehavior);\n        }\n\n        // set cookie jar if not disabled\n        if (!protocolProfileBehavior.disableCookies) {\n            options.jar = defaultOpts.cookieJar || true;\n        }\n\n        // use the server's cipher suite order instead of the client's during negotiation\n        if (protocolProfileBehavior.tlsPreferServerCiphers) {\n            options.honorCipherOrder = true;\n        }\n\n        // the SSL and TLS protocol versions to disabled during negotiation\n        if (Array.isArray(protocolProfileBehavior.tlsDisabledProtocols)) {\n            protocolProfileBehavior.tlsDisabledProtocols.forEach(function (protocol) {\n                // since secure options doesn't support TLSv1.3 before Node 14\n                // @todo remove the if condition when we drop support for Node 12\n                if (protocol === 'TLSv1_3' && !constants[SSL_OP_NO + protocol]) {\n                    options.maxVersion = 'TLSv1.2';\n                }\n                else {\n                    options.secureOptions |= constants[SSL_OP_NO + protocol];\n                }\n            });\n        }\n\n        // order of cipher suites that the SSL server profile uses to establish a secure connection\n        if (Array.isArray(protocolProfileBehavior.tlsCipherSelection)) {\n            options.ciphers = protocolProfileBehavior.tlsCipherSelection.join(':');\n        }\n\n        if (typeof defaultOpts.maxResponseSize === 'number') {\n            options.maxResponseSize = defaultOpts.maxResponseSize;\n        }\n\n        // Request body may return different options depending on the type of the body.\n        // @note getRequestBody may add system headers based on intent\n        bodyParams = self.getRequestBody(request, protocolProfileBehavior);\n\n        // Disable 'Cache-Control' and 'Postman-Token' based on global options\n        // @note this also make 'cache-control' and 'postman-token' part of `disabledSystemHeaders`\n        !defaultOpts.implicitCacheControl && (disabledSystemHeaders['cache-control'] = true);\n        !defaultOpts.implicitTraceHeader && (disabledSystemHeaders['postman-token'] = true);\n\n        // Add additional system headers to the request instance\n        addSystemHeaders(request, options, disabledSystemHeaders, systemHeaders);\n\n\n        // Don't add `Host` header if disabled using disabledSystemHeaders\n        // @note This can't be part of `blacklistHeaders` option as `setHost` is\n        // a Node.js http.request option to specifies whether or not to\n        // automatically add the Host header or not.\n        if (disabledSystemHeaders.host) {\n            header = oneNormalizedHeader(request.headers, 'host');\n\n            // only possible with AWS auth\n            header && header.system && (header.disabled = true);\n\n            // set `setHost` to false if there's no host header defined by the user\n            // or, the present host is added by the system.\n            (!header || header.system) && (options.setHost = false);\n        }\n\n        // Set `allowContentTypeOverride` if content-type header is disabled,\n        // this allows overriding (if invalid) the content-type for form-data\n        // and urlencoded request body.\n        if (disabledSystemHeaders['content-type']) {\n            options.allowContentTypeOverride = true;\n        }\n\n        options.blacklistHeaders = [];\n        ALLOWED_BLACKLIST_HEADERS.forEach(function (headerKey) {\n            if (!disabledSystemHeaders[headerKey]) { return; } // not disabled\n\n            header = oneNormalizedHeader(request.headers, headerKey);\n\n            // content-type added by body helper\n            header && header.system && (header.disabled = true);\n\n            // blacklist only if it's missing or part of system added headers\n            (!header || header.system) && options.blacklistHeaders.push(headerKey);\n\n            // @note for non-GET requests if no 'content-length' is set, it\n            // it assumes to be chucked request body and add 'transfer-encoding'\n            // here, we ensure blacklisting 'content-length' will also blacklist\n            // 'transfer-encoding' header.\n            if (headerKey === 'content-length') {\n                header = oneNormalizedHeader(request.headers, 'transfer-encoding');\n                (!header || header.system) && options.blacklistHeaders.push('transfer-encoding');\n            }\n        });\n\n        // Finally, get headers object\n        options.headers = request.getHeaders({ enabled: true, sanitizeKeys: true });\n\n        // override URL parser to WhatWG URL parser\n        if (useWhatWGUrlParser) {\n            options.urlParser = urlParser(disableUrlEncoding);\n        }\n\n        // override DNS lookup\n        if (networkOptions.restrictedAddresses || hostname === LOCALHOST ||\n            (!isTunnelingProxy && proxyHostname === LOCALHOST) || networkOptions.hostLookup) {\n            // Use proxy port for localhost resolution in case of non-tunneling proxy\n            // because the request will be sent to proxy server by postman-request\n            if (request.proxy && !isTunnelingProxy) {\n                portNumber = Number(request.proxy.port);\n            }\n            // Otherwise, use request's port\n            else {\n                portNumber = Number(port) || (isSSL ? HTTPS_DEFAULT_PORT : HTTP_DEFAULT_PORT);\n            }\n\n            _.isFinite(portNumber) && (options.lookup = lookup.bind(this, {\n                port: portNumber,\n                network: networkOptions\n            }));\n        }\n\n        _.assign(options, bodyParams, {\n            // @note these common agent options can be overridden by specifying\n            // custom http/https agents using requester option `agents`\n            agentOptions: {\n                keepAlive: defaultOpts.keepAlive\n            }\n        });\n\n        return options;\n    },\n\n    /**\n     * Processes a request body and puts it in a format compatible with\n     * the \"request\" library.\n     *\n     * @todo: Move this to the SDK.\n     * @param request - Request object\n     * @param protocolProfileBehavior - Protocol profile behaviors\n     *\n     * @returns {Object}\n     */\n    getRequestBody (request, protocolProfileBehavior) {\n        if (!(request && request.body)) {\n            return;\n        }\n\n        var i,\n            property,\n            requestBody = request.body,\n            requestBodyType = requestBody.mode,\n            requestMethod = (typeof request.method === STRING) ? request.method.toLowerCase() : undefined,\n            bodyIsEmpty = requestBody.isEmpty(),\n            bodyIsDisabled = requestBody.disabled,\n            bodyContent = requestBody[requestBodyType],\n\n            // flag to decide body pruning for METHODS_WITHOUT_BODY\n            // @note this will be `true` even if protocolProfileBehavior is undefined\n            pruneBody = protocolProfileBehavior ? !protocolProfileBehavior.disableBodyPruning : true;\n\n        // early bailout for empty or disabled body (this area has some legacy shenanigans)\n        if (bodyIsEmpty || bodyIsDisabled) {\n            return;\n        }\n\n        // body is empty if all the params in urlencoded and formdata body are disabled\n        // @todo update Collection SDK isEmpty method to account for this\n        if (sdk.PropertyList.isPropertyList(bodyContent)) {\n            bodyIsEmpty = true;\n\n            for (i = bodyContent.members.length - 1; i >= 0; i--) {\n                property = bodyContent.members[i];\n                // bail out if a single enabled property is present\n                if (property && !property.disabled) {\n                    bodyIsEmpty = false;\n                    break;\n                }\n            }\n\n            // bail out if body is empty\n            if (bodyIsEmpty) {\n                return;\n            }\n        }\n\n        // bail out if request method doesn't support body and pruneBody is true.\n        if (METHODS_WITHOUT_BODY[requestMethod] && pruneBody) {\n            return;\n        }\n\n        // even if body is not empty, but the body type is not known, we do not know how to parse the same\n        //\n        // @note if you'd like to support additional body types beyond formdata, url-encoding, etc, add the same to\n        //       the builder module\n        if (!Object.hasOwnProperty.call(requestBodyBuilders, requestBodyType)) {\n            return;\n        }\n\n        return requestBodyBuilders[requestBodyType](bodyContent, request);\n    },\n\n    /**\n     * Returns a JSON compatible with the Node's request library. (Also contains the original request)\n     *\n     * @param rawResponse Can be an XHR response or a Node request compatible response.\n     *              about the actual request that was sent.\n     * @param requestOptions Options that were used to send the request.\n     * @param responseBody Body as a string.\n     */\n    jsonifyResponse (rawResponse, requestOptions, responseBody) {\n        if (!rawResponse) {\n            return;\n        }\n\n        var responseJSON;\n\n        if (rawResponse.toJSON) {\n            responseJSON = rawResponse.toJSON();\n            responseJSON.request && _.assign(responseJSON.request, {\n                data: requestOptions.form || requestOptions.formData || requestOptions.body || {},\n                uri: { // @todo remove this\n                    href: requestOptions.url && requestOptions.url.href || requestOptions.url\n                },\n                url: requestOptions.url && requestOptions.url.href || requestOptions.url\n            });\n\n            rawResponse.rawHeaders &&\n                (responseJSON.headers = this.arrayPairsToObject(rawResponse.rawHeaders) || responseJSON.headers);\n\n            return responseJSON;\n        }\n\n        responseBody = responseBody || '';\n\n        // @todo drop support or isolate XHR requester in v8\n        // XHR :/\n        return {\n            statusCode: rawResponse.status,\n            body: responseBody,\n            headers: _.transform(sdk.Header.parse(rawResponse.getAllResponseHeaders()), function (acc, header) {\n                if (acc[header.key]) {\n                    !Array.isArray(acc[header.key]) && (acc[header.key] = [acc[header.key]]);\n                    acc[header.key].push(header.value);\n                }\n                else {\n                    acc[header.key] = header.value;\n                }\n            }, {}),\n            request: {\n                method: requestOptions.method || 'GET',\n                headers: requestOptions.headers,\n                uri: { // @todo remove this\n                    href: requestOptions.url && requestOptions.url.href || requestOptions.url\n                },\n                url: requestOptions.url && requestOptions.url.href || requestOptions.url,\n                data: requestOptions.form || requestOptions.formData || requestOptions.body || {}\n            }\n        };\n    },\n\n    /**\n     * ArrayBuffer to String\n     *\n     * @param {ArrayBuffer} buffer\n     * @returns {String}\n     */\n    arrayBufferToString (buffer) {\n        var str = '',\n            uArrayVal = new Uint8Array(buffer),\n\n            i,\n            ii;\n\n        for (i = 0, ii = uArrayVal.length; i < ii; i++) {\n            str += String.fromCharCode(uArrayVal[i]);\n        }\n\n        return str;\n    },\n\n    /**\n     * Converts an array of sequential pairs to an object.\n     *\n     * @param arr\n     * @returns {{}}\n     *\n     * @example\n     * ['a', 'b', 'c', 'd'] ====> {a: 'b', c: 'd' }\n     */\n    arrayPairsToObject (arr) {\n        if (!_.isArray(arr)) {\n            return;\n        }\n\n        var obj = {},\n            key,\n            val,\n            i,\n            ii;\n\n        for (i = 0, ii = arr.length; i < ii; i += 2) {\n            key = arr[i];\n            val = arr[i + 1];\n\n            if (_.has(obj, key)) {\n                !_.isArray(obj[key]) && (obj[key] = [obj[key]]);\n                obj[key].push(val);\n            }\n            else {\n                obj[key] = val;\n            }\n        }\n\n        return obj;\n    },\n\n    /**\n     * Checks if a given host or IP is has been restricted in the options.\n     *\n     * @param {String} host\n     * @param {Object} networkOptions\n     * @param {Array<String>} networkOptions.restrictedAddresses\n     *\n     * @returns {Boolean}\n     */\n    isAddressRestricted (host, networkOptions) {\n        return networkOptions.restrictedAddresses &&\n            networkOptions.restrictedAddresses[(host && host.toLowerCase())];\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}