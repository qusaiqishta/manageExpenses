{"ast":null,"code":"var _ = require('lodash'),\n  uuid = require('uuid'),\n  async = require('async'),\n  util = require('../util'),\n  sdk = require('postman-collection'),\n  sandbox = require('postman-sandbox'),\n  serialisedError = require('serialised-error'),\n  ToughCookie = require('tough-cookie').Cookie,\n  createItemContext = require('../create-item-context'),\n  ASSERTION_FAILURE = 'AssertionFailure',\n  SAFE_CONTEXT_VARIABLES = ['_variables', 'environment', 'globals', 'collectionVariables', 'cookies', 'data', 'request', 'response'],\n  EXECUTION_REQUEST_EVENT_BASE = 'execution.request.',\n  EXECUTION_RESPONSE_EVENT_BASE = 'execution.response.',\n  EXECUTION_ASSERTION_EVENT_BASE = 'execution.assertion.',\n  EXECUTION_ERROR_EVENT_BASE = 'execution.error.',\n  EXECUTION_COOKIES_EVENT_BASE = 'execution.cookies.',\n  COOKIES_EVENT_STORE_ACTION = 'store',\n  COOKIE_STORE_PUT_METHOD = 'putCookie',\n  COOKIE_STORE_UPDATE_METHOD = 'updateCookie',\n  FILE = 'file',\n  REQUEST_BODY_MODE_FILE = 'file',\n  REQUEST_BODY_MODE_FORMDATA = 'formdata',\n  getCookieDomain,\n  // fn\n  postProcessContext,\n  // fn\n  sanitizeFiles; // fn\n\npostProcessContext = function (execution, failures) {\n  // function determines whether the event needs to abort\n  var error;\n  if (failures && failures.length) {\n    error = new Error(failures.join(', '));\n    error.name = ASSERTION_FAILURE;\n  }\n  return error ? serialisedError(error, true) : undefined;\n};\n\n/**\n * Removes files in Request body if any.\n *\n * @private\n *\n * @param {Request~definition} request Request JSON representation to be sanitized\n * @param {Function} callback function invoked with error, request and sanitisedFiles.\n * sanitisedFiles is the list of files removed from request.\n *\n * @note this function mutates the request\n * @todo remove files path from request.certificate\n */\nsanitizeFiles = function (request, callback) {\n  if (!request) {\n    return callback(new Error('Could not complete pm.sendRequest. Request is empty.'));\n  }\n  var sanitisedFiles = [];\n\n  // do nothing if request body is empty\n  if (!request.body) {\n    // send request as such\n    return callback(null, request, sanitisedFiles);\n  }\n\n  // in case of request body mode is file, we strip it out\n  if (request.body.mode === REQUEST_BODY_MODE_FILE) {\n    sanitisedFiles.push(_.get(request, 'body.file.src'));\n    request.body = null; // mutate the request for body\n  }\n\n  // if body is form-data then we deep dive into the data items and remove the entries that have file data\n  else if (request.body.mode === REQUEST_BODY_MODE_FORMDATA) {\n    // eslint-disable-next-line lodash/prefer-immutable-method\n    _.remove(request.body.formdata, function (param) {\n      // blank param and non-file param is removed\n      if (!param || param.type !== FILE) {\n        return false;\n      }\n\n      // at this point the param needs to be removed\n      sanitisedFiles.push(param.src);\n      return true;\n    });\n  }\n  return callback(null, request, sanitisedFiles);\n};\n\n/**\n * Fetch domain name from CookieStore event arguments.\n *\n * @private\n * @param {String} fnName - CookieStore method name\n * @param {Array} args - CookieStore method arguments\n * @returns {String|Undefined} - Domain name\n */\ngetCookieDomain = function (fnName, args) {\n  if (!(fnName && args)) {\n    return;\n  }\n  var domain;\n  switch (fnName) {\n    case 'findCookie':\n    case 'findCookies':\n    case 'removeCookie':\n    case 'removeCookies':\n      domain = args[0];\n      break;\n    case 'putCookie':\n    case 'updateCookie':\n      domain = args[0] && args[0].domain;\n      break;\n    default:\n      return;\n  }\n  return domain;\n};\n\n/**\n * Script execution extension of the runner.\n * This module exposes processors for executing scripts before and after requests. Essentially, the processors are\n * itself not aware of other processors and simply allow running of a script and then queue a procesor as defined in\n * payload.\n *\n * Adds options\n * - stopOnScriptError:Boolean [false]\n * - host:Object [undefined]\n */\nmodule.exports = {\n  init: function (done) {\n    var run = this;\n\n    // if this run object already has a host, we do not need to create one.\n    if (run.host) {\n      return done();\n    }\n\n    // @todo - remove this when chrome app and electron host creation is offloaded to runner\n    // @todo - can this be removed now in runtime v4?\n    if (run.options.host && run.options.host.external === true) {\n      run.host = run.options.host.instance;\n      return done();\n    }\n    sandbox.createContext(_.merge({\n      timeout: _(run.options.timeout).pick(['script', 'global']).values().min()\n      // debug: true\n    }, run.options.host), function (err, context) {\n      if (err) {\n        return done(err);\n      }\n      // store the host in run object for future use and move on\n      run.host = context;\n      context.on('console', function () {\n        run.triggers.console(...arguments);\n      });\n      context.on('error', function () {\n        run.triggers.error(...arguments);\n      });\n      context.on('execution.error', function () {\n        run.triggers.exception(...arguments);\n      });\n      context.on('execution.assertion', function () {\n        run.triggers.assertion(...arguments);\n      });\n      done();\n    });\n  },\n  /**\n   * This lists the name of the events that the script processors are likely to trigger\n   *\n   * @type {Array}\n   */\n  triggers: ['beforeScript', 'script', 'assertion', 'exception', 'console'],\n  process: {\n    /**\n     * This processors job is to do the following:\n     * - trigger event by its name\n     * - execute all scripts that the event listens to and return execution results\n     *\n     * @param {Object} payload -\n     * @param {String} payload.name -\n     * @param {Item} payload.item -\n     * @param {Object} [payload.context] -\n     * @param {Cursor} [payload.coords] -\n     * @param {Number} [payload.scriptTimeout] - The millisecond timeout for the current running script.\n     * @param {Array.<String>} [payload.trackContext] -\n     * @param {Boolean} [payload.stopOnScriptError] - if set to true, then a synchronous error encountered during\n     * execution of a script will stop executing any further scripts\n     * @param {Boolean} [payload.abortOnFailure] -\n     * @param {Boolean} [payload.stopOnFailure] -\n     * @param {Function} next -\n     *\n     * @note - in order to raise trigger for the entire event, ensure your extension has registered the triggers\n     */\n    event(payload, next) {\n      var item = payload.item,\n        eventName = payload.name,\n        cursor = payload.coords,\n        // the payload can have a list of variables to track from the context post execution, ensure that\n        // those are accurately set\n        track = _.isArray(payload.trackContext) && _.isObject(payload.context) &&\n        // ensure that only those variables that are defined in the context are synced\n        payload.trackContext.filter(function (variable) {\n          return _.isObject(payload.context[variable]);\n        }),\n        stopOnScriptError = _.has(payload, 'stopOnScriptError') ? payload.stopOnScriptError : this.options.stopOnScriptError,\n        abortOnError = _.has(payload, 'abortOnError') ? payload.abortOnError : this.options.abortOnError,\n        // @todo: find a better home for this option processing\n        abortOnFailure = payload.abortOnFailure,\n        stopOnFailure = payload.stopOnFailure,\n        events;\n\n      // @todo: find a better place to code this so that event is not aware of such options\n      if (abortOnFailure) {\n        abortOnError = true;\n      }\n\n      // validate the payload\n      if (!eventName) {\n        return next(new Error('runner.extension~events: event payload is missing the event name.'));\n      }\n      if (!item) {\n        return next(new Error('runner.extension~events: event payload is missing the triggered item.'));\n      }\n\n      // get the list of events to be executed\n      // includes events in parent as well\n      events = item.events.listeners(eventName, {\n        excludeDisabled: true\n      });\n\n      // call the \"before\" event trigger by its event name.\n      // at this point, the one who queued this event, must ensure that the trigger for it is defined in its\n      // 'trigger' interface\n      this.triggers[_.camelCase('before-' + eventName)](null, cursor, events, item);\n\n      // with all the event listeners in place, we now iterate on them and execute its scripts. post execution,\n      // we accumulate the results in order to be passed on to the event callback trigger.\n      async.mapSeries(events, function (event, next) {\n        // in case the event has no script we bail out early\n        if (!event.script) {\n          return next(null, {\n            event\n          });\n        }\n\n        // get access to the script from the event.\n        var script = event.script,\n          executionId = uuid.v4(),\n          assertionFailed = [],\n          asyncScriptError,\n          // create copy of cursor so we don't leak script ids outside `event.command`\n          // and across scripts\n          scriptCursor = _.clone(cursor);\n\n        // store the execution id in script\n        script._lastExecutionId = executionId; // please don't use it anywhere else!\n\n        // if we can find an id on script or event we add them to the cursor\n        // so logs and errors can be traced back to the script they came from\n        event.id && (scriptCursor.eventId = event.id);\n        event.script.id && (scriptCursor.scriptId = event.script.id);\n\n        // trigger the \"beforeScript\" callback\n        this.triggers.beforeScript(null, scriptCursor, script, event, item);\n\n        // add event listener to trap all assertion events, but only if needed. to avoid needlessly accumulate\n        // stuff in memory.\n        (abortOnFailure || stopOnFailure) && this.host.on(EXECUTION_ASSERTION_EVENT_BASE + executionId, function (scriptCursor, assertions) {\n          _.forEach(assertions, function (assertion) {\n            assertion && !assertion.passed && assertionFailed.push(assertion.name);\n          });\n        });\n\n        // To store error event, but only if needed. Because error in callback of host.execute()\n        // don't show execution errors for async scripts\n        (abortOnError || stopOnScriptError) &&\n        // only store first async error in case of multiple errors\n        this.host.once(EXECUTION_ERROR_EVENT_BASE + executionId, function (scriptCursor, error) {\n          if (error && !(error instanceof Error)) {\n            error = new Error(error.message || error);\n          }\n          asyncScriptError = error;\n\n          // @todo: Figure out a way to abort the script execution here as soon as we get an error.\n          //        We can send `execution.abort.` event to sandbox for this, but currently it silently\n          //        terminates the script execution without triggering the callback.\n        });\n\n        this.host.on(EXECUTION_COOKIES_EVENT_BASE + executionId, function (eventId, action, fnName, args) {\n          // only store action is supported, might need to support\n          // more cookie actions in next 2 years ¯\\_(ツ)_/¯\n          if (action !== COOKIES_EVENT_STORE_ACTION) {\n            return;\n          }\n          var self = this,\n            dispatchEvent = EXECUTION_COOKIES_EVENT_BASE + executionId,\n            cookieJar = _.get(self, 'requester.options.cookieJar'),\n            cookieStore = cookieJar && cookieJar.store,\n            cookieDomain;\n          if (!cookieStore) {\n            return self.host.dispatch(dispatchEvent, eventId, 'CookieStore: no store found');\n          }\n          if (typeof cookieStore[fnName] !== 'function') {\n            return self.host.dispatch(dispatchEvent, eventId, `CookieStore: invalid method name '${fnName}'`);\n          }\n          !Array.isArray(args) && (args = []);\n\n          // set expected args length to make sure callback is always called\n          args.length = cookieStore[fnName].length - 1;\n\n          // there's no way cookie store can identify the difference\n          // between regular and programmatic access. So, for now\n          // we check for programmatic access using the cookieJar\n          // helper method and emit the default empty value for that\n          // method.\n          // @note we don't emit access denied error here because\n          // that might blocks users use-case while accessing\n          // cookies for a sub-domain.\n          cookieDomain = getCookieDomain(fnName, args);\n          if (cookieJar && typeof cookieJar.allowProgrammaticAccess === 'function' && !cookieJar.allowProgrammaticAccess(cookieDomain)) {\n            return self.host.dispatch(dispatchEvent, eventId, `CookieStore: programmatic access to \"${cookieDomain}\" is denied`);\n          }\n\n          // serialize cookie object\n          if (fnName === COOKIE_STORE_PUT_METHOD && args[0]) {\n            args[0] = ToughCookie.fromJSON(args[0]);\n          }\n          if (fnName === COOKIE_STORE_UPDATE_METHOD && args[0] && args[1]) {\n            args[0] = ToughCookie.fromJSON(args[0]);\n            args[1] = ToughCookie.fromJSON(args[1]);\n          }\n\n          // add store method's callback argument\n          args.push(function (err, res) {\n            // serialize error message\n            if (err && err instanceof Error) {\n              err = err.message || String(err);\n            }\n            self.host.dispatch(dispatchEvent, eventId, err, res);\n          });\n          try {\n            cookieStore[fnName](...args);\n          } catch (error) {\n            self.host.dispatch(dispatchEvent, eventId, `runtime~CookieStore: error executing \"${fnName}\"`);\n          }\n        }.bind(this));\n        this.host.on(EXECUTION_REQUEST_EVENT_BASE + executionId, function (scriptCursor, id, requestId, request) {\n          // remove files in request body if any\n          sanitizeFiles(request, function (err, request, sanitisedFiles) {\n            if (err) {\n              return this.host.dispatch(EXECUTION_RESPONSE_EVENT_BASE + id, requestId, err);\n            }\n            var nextPayload;\n\n            // if request is sanitized send a warning\n            if (!_.isEmpty(sanitisedFiles)) {\n              this.triggers.console(scriptCursor, 'warn', 'uploading files from scripts is not allowed');\n            }\n            nextPayload = {\n              item: new sdk.Item({\n                request: request,\n                // Allow request body in methods like GET, HEAD, etc.\n                // when explicitly provided via script\n                // @todo make protocolProfileBehavior configurable via scripts\n                protocolProfileBehavior: {\n                  disableBodyPruning: true\n                }\n              }),\n              coords: scriptCursor,\n              // @todo - get script type from the sandbox\n              source: 'script',\n              // abortOnError makes sure request command bubbles errors\n              // so we can pass it on to the callback\n              abortOnError: true\n            };\n\n            // create context for executing this request\n            nextPayload.context = createItemContext(nextPayload);\n            this.immediate('httprequest', nextPayload).done(function (result) {\n              this.host.dispatch(EXECUTION_RESPONSE_EVENT_BASE + id, requestId, null, result && result.response,\n              // @todo get cookies from result.history or pass PostmanHistory\n              // instance once it is fully supported\n              result && {\n                cookies: result.cookies\n              });\n            }).catch(function (err) {\n              this.host.dispatch(EXECUTION_RESPONSE_EVENT_BASE + id, requestId, err);\n            });\n          }.bind(this));\n        }.bind(this));\n\n        // finally execute the script\n        this.host.execute(event, {\n          id: executionId,\n          // debug: true,\n          timeout: payload.scriptTimeout,\n          // @todo: Expose this as a property in Collection SDK's Script\n          cursor: scriptCursor,\n          context: _.pick(payload.context, SAFE_CONTEXT_VARIABLES),\n          serializeLogs: _.get(this, 'options.script.serializeLogs'),\n          // legacy options\n          legacy: {\n            _itemId: item.id,\n            _itemName: item.name\n          }\n        }, function (err, result) {\n          this.host.removeAllListeners(EXECUTION_REQUEST_EVENT_BASE + executionId);\n          this.host.removeAllListeners(EXECUTION_ASSERTION_EVENT_BASE + executionId);\n          this.host.removeAllListeners(EXECUTION_RESPONSE_EVENT_BASE + executionId);\n          this.host.removeAllListeners(EXECUTION_COOKIES_EVENT_BASE + executionId);\n          this.host.removeAllListeners(EXECUTION_ERROR_EVENT_BASE + executionId);\n\n          // Handle async errors as well.\n          // If there was an error running the script itself, that takes precedence\n          if (!err && asyncScriptError) {\n            err = asyncScriptError;\n          }\n\n          // electron IPC does not bubble errors to the browser process, so we serialize it here.\n          err && (err = serialisedError(err, true));\n\n          // if it is defined that certain variables are to be synced back to result, we do the same\n          track && result && track.forEach(function (variable) {\n            if (!(_.isObject(result[variable]) && payload.context[variable])) {\n              return;\n            }\n            var contextVariable = payload.context[variable],\n              mutations = result[variable].mutations;\n\n            // bail out if there are no mutations\n            if (!mutations) {\n              return;\n            }\n\n            // ensure that variable scope is treated accordingly\n            if (_.isFunction(contextVariable.applyMutation)) {\n              mutations = new sdk.MutationTracker(result[variable].mutations);\n              mutations.applyOn(contextVariable);\n            }\n\n            // @todo: unify the non variable scope flows and consume diff always\n            // and drop sending the full variable scope from sandbox\n            else {\n              util.syncObject(contextVariable, result[variable]);\n            }\n          });\n\n          // Get the failures. If there was an error running the script itself, that takes precedence\n          if (!err && (abortOnFailure || stopOnFailure)) {\n            err = postProcessContext(result, assertionFailed); // also use async assertions\n          }\n\n          // Ensure that we have SDK instances, not serialized plain objects.\n          // @todo - should this be handled by the sandbox?\n          result && result._variables && (result._variables = new sdk.VariableScope(result._variables));\n          result && result.environment && (result.environment = new sdk.VariableScope(result.environment));\n          result && result.globals && (result.globals = new sdk.VariableScope(result.globals));\n          result && result.collectionVariables && (result.collectionVariables = new sdk.VariableScope(result.collectionVariables));\n          result && result.request && (result.request = new sdk.Request(result.request));\n\n          // @note Since postman-sandbox@3.5.2, response object is not included in the execution result.\n          // Refer: https://github.com/postmanlabs/postman-sandbox/pull/512\n          // Adding back here to avoid breaking change in `script` callback.\n          // @todo revisit script callback args in runtime v8.\n          result && payload.context && payload.context.response && (result.response = new sdk.Response(payload.context.response));\n\n          // persist the pm.variables for the next script\n          result && result._variables && (payload.context._variables = new sdk.VariableScope(result._variables));\n\n          // persist the pm.variables for the next request\n          result && result._variables && (this.state._variables = new sdk.VariableScope(result._variables));\n\n          // persist the mutated request in payload context,\n          // @note this will be used for the next prerequest script or\n          // upcoming commands(request, httprequest).\n          result && result.request && (payload.context.request = result.request);\n\n          // now that this script is done executing, we trigger the event and move to the next script\n          this.triggers.script(err || null, scriptCursor, result, script, event, item);\n\n          // move to next script and pass on the results for accumulation\n          next((stopOnScriptError || abortOnError || stopOnFailure) && err ? err : null, _.assign({\n            event,\n            script,\n            result\n          }, err && {\n            error: err\n          })); // we use assign here to avoid needless error property\n        }.bind(this));\n      }.bind(this), function (err, results) {\n        // trigger the event completion callback\n        this.triggers[eventName](null, cursor, results, item);\n        next(abortOnError && err ? err : null, results, err);\n      }.bind(this));\n    }\n  }\n};","map":{"version":3,"names":["_","require","uuid","async","util","sdk","sandbox","serialisedError","ToughCookie","Cookie","createItemContext","ASSERTION_FAILURE","SAFE_CONTEXT_VARIABLES","EXECUTION_REQUEST_EVENT_BASE","EXECUTION_RESPONSE_EVENT_BASE","EXECUTION_ASSERTION_EVENT_BASE","EXECUTION_ERROR_EVENT_BASE","EXECUTION_COOKIES_EVENT_BASE","COOKIES_EVENT_STORE_ACTION","COOKIE_STORE_PUT_METHOD","COOKIE_STORE_UPDATE_METHOD","FILE","REQUEST_BODY_MODE_FILE","REQUEST_BODY_MODE_FORMDATA","getCookieDomain","postProcessContext","sanitizeFiles","execution","failures","error","length","Error","join","name","undefined","request","callback","sanitisedFiles","body","mode","push","get","remove","formdata","param","type","src","fnName","args","domain","module","exports","init","done","run","host","options","external","instance","createContext","merge","timeout","pick","values","min","err","context","on","triggers","console","arguments","exception","assertion","process","event","payload","next","item","eventName","cursor","coords","track","isArray","trackContext","isObject","filter","variable","stopOnScriptError","has","abortOnError","abortOnFailure","stopOnFailure","events","listeners","excludeDisabled","camelCase","mapSeries","script","executionId","v4","assertionFailed","asyncScriptError","scriptCursor","clone","_lastExecutionId","id","eventId","scriptId","beforeScript","assertions","forEach","passed","once","message","action","self","dispatchEvent","cookieJar","cookieStore","store","cookieDomain","dispatch","Array","allowProgrammaticAccess","fromJSON","res","String","bind","requestId","nextPayload","isEmpty","Item","protocolProfileBehavior","disableBodyPruning","source","immediate","result","response","cookies","catch","execute","scriptTimeout","serializeLogs","legacy","_itemId","_itemName","removeAllListeners","contextVariable","mutations","isFunction","applyMutation","MutationTracker","applyOn","syncObject","_variables","VariableScope","environment","globals","collectionVariables","Request","Response","state","assign","results"],"sources":["/Users/Qusai.Qishta/node_modules/postman-runtime/lib/runner/extensions/event.command.js"],"sourcesContent":["var _ = require('lodash'),\n    uuid = require('uuid'),\n    async = require('async'),\n\n    util = require('../util'),\n    sdk = require('postman-collection'),\n    sandbox = require('postman-sandbox'),\n    serialisedError = require('serialised-error'),\n    ToughCookie = require('tough-cookie').Cookie,\n\n    createItemContext = require('../create-item-context'),\n\n    ASSERTION_FAILURE = 'AssertionFailure',\n    SAFE_CONTEXT_VARIABLES = ['_variables', 'environment', 'globals', 'collectionVariables', 'cookies', 'data',\n        'request', 'response'],\n\n    EXECUTION_REQUEST_EVENT_BASE = 'execution.request.',\n    EXECUTION_RESPONSE_EVENT_BASE = 'execution.response.',\n    EXECUTION_ASSERTION_EVENT_BASE = 'execution.assertion.',\n    EXECUTION_ERROR_EVENT_BASE = 'execution.error.',\n    EXECUTION_COOKIES_EVENT_BASE = 'execution.cookies.',\n\n    COOKIES_EVENT_STORE_ACTION = 'store',\n    COOKIE_STORE_PUT_METHOD = 'putCookie',\n    COOKIE_STORE_UPDATE_METHOD = 'updateCookie',\n\n    FILE = 'file',\n\n    REQUEST_BODY_MODE_FILE = 'file',\n    REQUEST_BODY_MODE_FORMDATA = 'formdata',\n\n    getCookieDomain, // fn\n    postProcessContext, // fn\n    sanitizeFiles; // fn\n\npostProcessContext = function (execution, failures) { // function determines whether the event needs to abort\n    var error;\n\n    if (failures && failures.length) {\n        error = new Error(failures.join(', '));\n        error.name = ASSERTION_FAILURE;\n    }\n\n    return error ? serialisedError(error, true) : undefined;\n};\n\n/**\n * Removes files in Request body if any.\n *\n * @private\n *\n * @param {Request~definition} request Request JSON representation to be sanitized\n * @param {Function} callback function invoked with error, request and sanitisedFiles.\n * sanitisedFiles is the list of files removed from request.\n *\n * @note this function mutates the request\n * @todo remove files path from request.certificate\n */\nsanitizeFiles = function (request, callback) {\n    if (!request) {\n        return callback(new Error('Could not complete pm.sendRequest. Request is empty.'));\n    }\n\n    var sanitisedFiles = [];\n\n    // do nothing if request body is empty\n    if (!request.body) {\n        // send request as such\n        return callback(null, request, sanitisedFiles);\n    }\n\n    // in case of request body mode is file, we strip it out\n    if (request.body.mode === REQUEST_BODY_MODE_FILE) {\n        sanitisedFiles.push(_.get(request, 'body.file.src'));\n        request.body = null; // mutate the request for body\n    }\n\n    // if body is form-data then we deep dive into the data items and remove the entries that have file data\n    else if (request.body.mode === REQUEST_BODY_MODE_FORMDATA) {\n        // eslint-disable-next-line lodash/prefer-immutable-method\n        _.remove(request.body.formdata, function (param) {\n            // blank param and non-file param is removed\n            if (!param || param.type !== FILE) { return false; }\n\n            // at this point the param needs to be removed\n            sanitisedFiles.push(param.src);\n\n            return true;\n        });\n    }\n\n    return callback(null, request, sanitisedFiles);\n};\n\n/**\n * Fetch domain name from CookieStore event arguments.\n *\n * @private\n * @param {String} fnName - CookieStore method name\n * @param {Array} args - CookieStore method arguments\n * @returns {String|Undefined} - Domain name\n */\ngetCookieDomain = function (fnName, args) {\n    if (!(fnName && args)) {\n        return;\n    }\n\n    var domain;\n\n    switch (fnName) {\n        case 'findCookie':\n        case 'findCookies':\n        case 'removeCookie':\n        case 'removeCookies':\n            domain = args[0];\n            break;\n        case 'putCookie':\n        case 'updateCookie':\n            domain = args[0] && args[0].domain;\n            break;\n        default:\n            return;\n    }\n\n    return domain;\n};\n\n/**\n * Script execution extension of the runner.\n * This module exposes processors for executing scripts before and after requests. Essentially, the processors are\n * itself not aware of other processors and simply allow running of a script and then queue a procesor as defined in\n * payload.\n *\n * Adds options\n * - stopOnScriptError:Boolean [false]\n * - host:Object [undefined]\n */\nmodule.exports = {\n    init: function (done) {\n        var run = this;\n\n        // if this run object already has a host, we do not need to create one.\n        if (run.host) {\n            return done();\n        }\n\n        // @todo - remove this when chrome app and electron host creation is offloaded to runner\n        // @todo - can this be removed now in runtime v4?\n        if (run.options.host && run.options.host.external === true) {\n            run.host = run.options.host.instance;\n\n            return done();\n        }\n\n        sandbox.createContext(_.merge({\n            timeout: _(run.options.timeout).pick(['script', 'global']).values().min()\n            // debug: true\n        }, run.options.host), function (err, context) {\n            if (err) { return done(err); }\n            // store the host in run object for future use and move on\n            run.host = context;\n\n            context.on('console', function () {\n                run.triggers.console(...arguments);\n            });\n\n            context.on('error', function () {\n                run.triggers.error(...arguments);\n            });\n\n            context.on('execution.error', function () {\n                run.triggers.exception(...arguments);\n            });\n\n            context.on('execution.assertion', function () {\n                run.triggers.assertion(...arguments);\n            });\n\n            done();\n        });\n    },\n\n    /**\n     * This lists the name of the events that the script processors are likely to trigger\n     *\n     * @type {Array}\n     */\n    triggers: ['beforeScript', 'script', 'assertion', 'exception', 'console'],\n\n    process: {\n        /**\n         * This processors job is to do the following:\n         * - trigger event by its name\n         * - execute all scripts that the event listens to and return execution results\n         *\n         * @param {Object} payload -\n         * @param {String} payload.name -\n         * @param {Item} payload.item -\n         * @param {Object} [payload.context] -\n         * @param {Cursor} [payload.coords] -\n         * @param {Number} [payload.scriptTimeout] - The millisecond timeout for the current running script.\n         * @param {Array.<String>} [payload.trackContext] -\n         * @param {Boolean} [payload.stopOnScriptError] - if set to true, then a synchronous error encountered during\n         * execution of a script will stop executing any further scripts\n         * @param {Boolean} [payload.abortOnFailure] -\n         * @param {Boolean} [payload.stopOnFailure] -\n         * @param {Function} next -\n         *\n         * @note - in order to raise trigger for the entire event, ensure your extension has registered the triggers\n         */\n        event (payload, next) {\n            var item = payload.item,\n                eventName = payload.name,\n                cursor = payload.coords,\n                // the payload can have a list of variables to track from the context post execution, ensure that\n                // those are accurately set\n                track = _.isArray(payload.trackContext) && _.isObject(payload.context) &&\n                    // ensure that only those variables that are defined in the context are synced\n                    payload.trackContext.filter(function (variable) {\n                        return _.isObject(payload.context[variable]);\n                    }),\n                stopOnScriptError = (_.has(payload, 'stopOnScriptError') ? payload.stopOnScriptError :\n                    this.options.stopOnScriptError),\n                abortOnError = (_.has(payload, 'abortOnError') ? payload.abortOnError : this.options.abortOnError),\n\n                // @todo: find a better home for this option processing\n                abortOnFailure = payload.abortOnFailure,\n                stopOnFailure = payload.stopOnFailure,\n\n                events;\n\n            // @todo: find a better place to code this so that event is not aware of such options\n            if (abortOnFailure) {\n                abortOnError = true;\n            }\n\n            // validate the payload\n            if (!eventName) {\n                return next(new Error('runner.extension~events: event payload is missing the event name.'));\n            }\n            if (!item) {\n                return next(new Error('runner.extension~events: event payload is missing the triggered item.'));\n            }\n\n            // get the list of events to be executed\n            // includes events in parent as well\n            events = item.events.listeners(eventName, { excludeDisabled: true });\n\n            // call the \"before\" event trigger by its event name.\n            // at this point, the one who queued this event, must ensure that the trigger for it is defined in its\n            // 'trigger' interface\n            this.triggers[_.camelCase('before-' + eventName)](null, cursor, events, item);\n\n            // with all the event listeners in place, we now iterate on them and execute its scripts. post execution,\n            // we accumulate the results in order to be passed on to the event callback trigger.\n            async.mapSeries(events, function (event, next) {\n                // in case the event has no script we bail out early\n                if (!event.script) {\n                    return next(null, { event });\n                }\n\n                // get access to the script from the event.\n                var script = event.script,\n                    executionId = uuid.v4(),\n                    assertionFailed = [],\n                    asyncScriptError,\n\n                    // create copy of cursor so we don't leak script ids outside `event.command`\n                    // and across scripts\n                    scriptCursor = _.clone(cursor);\n\n                // store the execution id in script\n                script._lastExecutionId = executionId; // please don't use it anywhere else!\n\n                // if we can find an id on script or event we add them to the cursor\n                // so logs and errors can be traced back to the script they came from\n                event.id && (scriptCursor.eventId = event.id);\n                event.script.id && (scriptCursor.scriptId = event.script.id);\n\n                // trigger the \"beforeScript\" callback\n                this.triggers.beforeScript(null, scriptCursor, script, event, item);\n\n                // add event listener to trap all assertion events, but only if needed. to avoid needlessly accumulate\n                // stuff in memory.\n                (abortOnFailure || stopOnFailure) &&\n                    this.host.on(EXECUTION_ASSERTION_EVENT_BASE + executionId, function (scriptCursor, assertions) {\n                        _.forEach(assertions, function (assertion) {\n                            assertion && !assertion.passed && assertionFailed.push(assertion.name);\n                        });\n                    });\n\n                // To store error event, but only if needed. Because error in callback of host.execute()\n                // don't show execution errors for async scripts\n                (abortOnError || stopOnScriptError) &&\n                    // only store first async error in case of multiple errors\n                    this.host.once(EXECUTION_ERROR_EVENT_BASE + executionId, function (scriptCursor, error) {\n                        if (error && !(error instanceof Error)) {\n                            error = new Error(error.message || error);\n                        }\n\n                        asyncScriptError = error;\n\n                        // @todo: Figure out a way to abort the script execution here as soon as we get an error.\n                        //        We can send `execution.abort.` event to sandbox for this, but currently it silently\n                        //        terminates the script execution without triggering the callback.\n                    });\n\n                this.host.on(EXECUTION_COOKIES_EVENT_BASE + executionId,\n                    function (eventId, action, fnName, args) {\n                        // only store action is supported, might need to support\n                        // more cookie actions in next 2 years ¯\\_(ツ)_/¯\n                        if (action !== COOKIES_EVENT_STORE_ACTION) { return; }\n\n                        var self = this,\n                            dispatchEvent = EXECUTION_COOKIES_EVENT_BASE + executionId,\n                            cookieJar = _.get(self, 'requester.options.cookieJar'),\n                            cookieStore = cookieJar && cookieJar.store,\n                            cookieDomain;\n\n                        if (!cookieStore) {\n                            return self.host.dispatch(dispatchEvent, eventId, 'CookieStore: no store found');\n                        }\n\n                        if (typeof cookieStore[fnName] !== 'function') {\n                            return self.host.dispatch(dispatchEvent, eventId,\n                                `CookieStore: invalid method name '${fnName}'`);\n                        }\n\n                        !Array.isArray(args) && (args = []);\n\n                        // set expected args length to make sure callback is always called\n                        args.length = cookieStore[fnName].length - 1;\n\n                        // there's no way cookie store can identify the difference\n                        // between regular and programmatic access. So, for now\n                        // we check for programmatic access using the cookieJar\n                        // helper method and emit the default empty value for that\n                        // method.\n                        // @note we don't emit access denied error here because\n                        // that might blocks users use-case while accessing\n                        // cookies for a sub-domain.\n                        cookieDomain = getCookieDomain(fnName, args);\n                        if (cookieJar && typeof cookieJar.allowProgrammaticAccess === 'function' &&\n                            !cookieJar.allowProgrammaticAccess(cookieDomain)) {\n                            return self.host.dispatch(dispatchEvent, eventId,\n                                `CookieStore: programmatic access to \"${cookieDomain}\" is denied`);\n                        }\n\n                        // serialize cookie object\n                        if (fnName === COOKIE_STORE_PUT_METHOD && args[0]) {\n                            args[0] = ToughCookie.fromJSON(args[0]);\n                        }\n\n                        if (fnName === COOKIE_STORE_UPDATE_METHOD && args[0] && args[1]) {\n                            args[0] = ToughCookie.fromJSON(args[0]);\n                            args[1] = ToughCookie.fromJSON(args[1]);\n                        }\n\n                        // add store method's callback argument\n                        args.push(function (err, res) {\n                            // serialize error message\n                            if (err && err instanceof Error) {\n                                err = err.message || String(err);\n                            }\n\n                            self.host.dispatch(dispatchEvent, eventId, err, res);\n                        });\n\n                        try {\n                            cookieStore[fnName](...args);\n                        }\n                        catch (error) {\n                            self.host.dispatch(dispatchEvent, eventId,\n                                `runtime~CookieStore: error executing \"${fnName}\"`);\n                        }\n                    }.bind(this));\n\n                this.host.on(EXECUTION_REQUEST_EVENT_BASE + executionId,\n                    function (scriptCursor, id, requestId, request) {\n                        // remove files in request body if any\n                        sanitizeFiles(request, function (err, request, sanitisedFiles) {\n                            if (err) {\n                                return this.host.dispatch(EXECUTION_RESPONSE_EVENT_BASE + id, requestId, err);\n                            }\n\n                            var nextPayload;\n\n                            // if request is sanitized send a warning\n                            if (!_.isEmpty(sanitisedFiles)) {\n                                this.triggers.console(scriptCursor, 'warn',\n                                    'uploading files from scripts is not allowed');\n                            }\n\n                            nextPayload = {\n                                item: new sdk.Item({\n                                    request: request,\n                                    // Allow request body in methods like GET, HEAD, etc.\n                                    // when explicitly provided via script\n                                    // @todo make protocolProfileBehavior configurable via scripts\n                                    protocolProfileBehavior: {\n                                        disableBodyPruning: true\n                                    }\n                                }),\n                                coords: scriptCursor,\n                                // @todo - get script type from the sandbox\n                                source: 'script',\n                                // abortOnError makes sure request command bubbles errors\n                                // so we can pass it on to the callback\n                                abortOnError: true\n                            };\n\n                            // create context for executing this request\n                            nextPayload.context = createItemContext(nextPayload);\n\n                            this.immediate('httprequest', nextPayload).done(function (result) {\n                                this.host.dispatch(EXECUTION_RESPONSE_EVENT_BASE + id,\n                                    requestId,\n                                    null,\n                                    result && result.response,\n\n                                    // @todo get cookies from result.history or pass PostmanHistory\n                                    // instance once it is fully supported\n                                    result && { cookies: result.cookies });\n                            }).catch(function (err) {\n                                this.host.dispatch(EXECUTION_RESPONSE_EVENT_BASE + id, requestId, err);\n                            });\n                        }.bind(this));\n                    }.bind(this));\n\n                // finally execute the script\n                this.host.execute(event, {\n                    id: executionId,\n                    // debug: true,\n                    timeout: payload.scriptTimeout, // @todo: Expose this as a property in Collection SDK's Script\n                    cursor: scriptCursor,\n                    context: _.pick(payload.context, SAFE_CONTEXT_VARIABLES),\n                    serializeLogs: _.get(this, 'options.script.serializeLogs'),\n\n                    // legacy options\n                    legacy: {\n                        _itemId: item.id,\n                        _itemName: item.name\n                    }\n                }, function (err, result) {\n                    this.host.removeAllListeners(EXECUTION_REQUEST_EVENT_BASE + executionId);\n                    this.host.removeAllListeners(EXECUTION_ASSERTION_EVENT_BASE + executionId);\n                    this.host.removeAllListeners(EXECUTION_RESPONSE_EVENT_BASE + executionId);\n                    this.host.removeAllListeners(EXECUTION_COOKIES_EVENT_BASE + executionId);\n                    this.host.removeAllListeners(EXECUTION_ERROR_EVENT_BASE + executionId);\n\n                    // Handle async errors as well.\n                    // If there was an error running the script itself, that takes precedence\n                    if (!err && asyncScriptError) {\n                        err = asyncScriptError;\n                    }\n\n                    // electron IPC does not bubble errors to the browser process, so we serialize it here.\n                    err && (err = serialisedError(err, true));\n\n                    // if it is defined that certain variables are to be synced back to result, we do the same\n                    track && result && track.forEach(function (variable) {\n                        if (!(_.isObject(result[variable]) && payload.context[variable])) { return; }\n\n                        var contextVariable = payload.context[variable],\n                            mutations = result[variable].mutations;\n\n                        // bail out if there are no mutations\n                        if (!mutations) {\n                            return;\n                        }\n\n                        // ensure that variable scope is treated accordingly\n                        if (_.isFunction(contextVariable.applyMutation)) {\n                            mutations = new sdk.MutationTracker(result[variable].mutations);\n\n                            mutations.applyOn(contextVariable);\n                        }\n\n                        // @todo: unify the non variable scope flows and consume diff always\n                        // and drop sending the full variable scope from sandbox\n                        else {\n                            util.syncObject(contextVariable, result[variable]);\n                        }\n                    });\n\n                    // Get the failures. If there was an error running the script itself, that takes precedence\n                    if (!err && (abortOnFailure || stopOnFailure)) {\n                        err = postProcessContext(result, assertionFailed); // also use async assertions\n                    }\n\n                    // Ensure that we have SDK instances, not serialized plain objects.\n                    // @todo - should this be handled by the sandbox?\n                    result && result._variables && (result._variables = new sdk.VariableScope(result._variables));\n                    result && result.environment && (result.environment = new sdk.VariableScope(result.environment));\n                    result && result.globals && (result.globals = new sdk.VariableScope(result.globals));\n                    result && result.collectionVariables &&\n                        (result.collectionVariables = new sdk.VariableScope(result.collectionVariables));\n                    result && result.request && (result.request = new sdk.Request(result.request));\n\n                    // @note Since postman-sandbox@3.5.2, response object is not included in the execution result.\n                    // Refer: https://github.com/postmanlabs/postman-sandbox/pull/512\n                    // Adding back here to avoid breaking change in `script` callback.\n                    // @todo revisit script callback args in runtime v8.\n                    result && payload.context && payload.context.response &&\n                        (result.response = new sdk.Response(payload.context.response));\n\n                    // persist the pm.variables for the next script\n                    result && result._variables &&\n                        (payload.context._variables = new sdk.VariableScope(result._variables));\n\n                    // persist the pm.variables for the next request\n                    result && result._variables && (this.state._variables = new sdk.VariableScope(result._variables));\n\n                    // persist the mutated request in payload context,\n                    // @note this will be used for the next prerequest script or\n                    // upcoming commands(request, httprequest).\n                    result && result.request && (payload.context.request = result.request);\n\n                    // now that this script is done executing, we trigger the event and move to the next script\n                    this.triggers.script(err || null, scriptCursor, result, script, event, item);\n\n                    // move to next script and pass on the results for accumulation\n                    next(((stopOnScriptError || abortOnError || stopOnFailure) && err) ? err : null, _.assign({\n                        event,\n                        script,\n                        result\n                    }, err && { error: err })); // we use assign here to avoid needless error property\n                }.bind(this));\n            }.bind(this), function (err, results) {\n                // trigger the event completion callback\n                this.triggers[eventName](null, cursor, results, item);\n                next((abortOnError && err) ? err : null, results, err);\n            }.bind(this));\n        }\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}